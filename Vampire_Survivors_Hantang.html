<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ÌïúÌÉïÏù¥Ïùò ÏÉùÏ°¥ Ïã†Í≥† (Vampire Survivors Style)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #101020; font-family: 'Black Han Sans', sans-serif; user-select: none; }
        
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Gowun+Batang&display=swap');

        /* UI Î†àÏù¥ÏïÑÏõÉ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* ÏÉÅÎã® Ï†ïÎ≥¥Î∞î */
        #top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; align-items: center;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 15px;
            color: #fff; border: 2px solid #555; font-size: 20px; text-shadow: 1px 1px 2px black;
            display: flex; align-items: center; gap: 10px;
        }
        #score { color: #ffd700; }
        #timer { color: #fff; min-width: 60px; text-align: center; }
        #hp-box { color: #ff5555; border-color: #ff5555; }
        #bomb-box { color: #00ffaa; border-color: #00ffaa; }

        /* Í≤ΩÌóòÏπò Î∞î */
        #exp-bar-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10;
        }
        #exp-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); transition: width 0.2s;
        }
        #level-indicator {
            position: absolute; top: 15px; right: 20px; color: #00f2fe; font-size: 30px; text-shadow: 2px 2px 0 #000;
        }

        /* Î†àÎ≤®ÏóÖ ÏÑ†ÌÉùÏ∞Ω */
        #levelup-modal {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
            pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .modal-title { font-size: 50px; color: #ffd700; margin-bottom: 30px; text-shadow: 0 0 10px orange; animation: float 2s infinite; }
        .card-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card {
            width: 200px; height: 280px; background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #666; border-radius: 10px; padding: 15px;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .upgrade-card:hover { transform: translateY(-10px); border-color: #fff; background: #333; }
        .card-icon { font-size: 50px; margin-bottom: 10px; }
        .card-name { font-size: 24px; color: #fff; margin-bottom: 10px; color: #00ff00; }
        .card-desc { font-size: 16px; color: #ccc; font-family: 'Gowun Batang', serif; line-height: 1.4; }
        .card-level { margin-top: auto; font-size: 14px; color: #888; }

        /* Í≤åÏûÑÏò§Î≤Ñ */
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.8); z-index: 200; pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        .go-title { font-size: 80px; color: #ff0055; margin-bottom: 20px; }
        .go-score { font-size: 30px; margin-bottom: 40px; }
        button {
            padding: 15px 40px; font-size: 24px; background: #fff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-family: 'Black Han Sans';
        }
        button:hover { background: #ddd; }

        /* ÌïÑÏÇ¥Í∏∞ ÏïàÎÇ¥ */
        #ult-guide {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 18px; text-align: center;
        }

        @keyframes float { 0% { transform: translateY(0); } 50% { transform: translateY(-10px); } 100% { transform: translateY(0); } }

        /* Îç∞ÎØ∏ÏßÄ ÌÖçÏä§Ìä∏ */
        .damage-text {
            position: absolute; color: white; font-weight: bold; font-size: 20px;
            pointer-events: none; text-shadow: 1px 1px 0 #000;
            animation: popUp 0.8s forwards; white-space: nowrap;
        }
        .mincho-text {
            color: #00ffaa !important; font-size: 24px !important; text-shadow: 0 0 5px #00ffaa;
        }
        .death-quote {
            color: #ffff00; font-size: 18px; font-family: 'Gowun Batang', serif;
            text-shadow: 1px 1px 2px #000; z-index: 5;
        }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-40px) scale(0.8); } }

        /* Ï≤¥Î†•Î∞î Ïä§ÌÉÄÏùº */
        .hp-bar-container {
            position: absolute;
            width: 50px; height: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #000;
            border-radius: 3px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none; /* JSÎ°ú Ï†úÏñ¥ */
        }
        .hp-bar-fill {
            height: 100%;
            background: #ff0000;
            width: 100%;
            border-radius: 2px;
            transition: width 0.1s;
        }
        .player-hp-bar .hp-bar-fill {
            background: #00ff00; /* ÌîåÎ†àÏù¥Ïñ¥Îäî Ï¥àÎ°ùÏÉâ */
        }
        .boss-hp-bar {
            width: 100px; height: 10px; border: 2px solid #ffaa00;
        }
        .boss-hp-bar .hp-bar-fill {
            background: #ffaa00;
        }
    </style>
</head>
<body>
    <!-- 3D Ï∫îÎ≤ÑÏä§ -->
    <div id="canvas-container"></div>

    <!-- UI Î†àÏù¥Ïñ¥ -->
    <div id="exp-bar-container"><div id="exp-bar"></div></div>
    
    <div id="ui-layer">
        <div id="level-indicator">LV. <span id="level-val">1</span></div>
        
        <div id="top-bar">
            <div class="stat-box" id="hp-box">HP <span id="hp-val">100</span></div>
            <div class="stat-box" id="bomb-box">üí£ <span id="bomb-val">1</span> <span id="bomb-cooldown" style="font-size:14px; color:#aaa; margin-left:5px;">(0%)</span></div>
            <div class="stat-box">TIME <span id="timer">00:00</span></div>
            <div class="stat-box">KILL <span id="kill-count">0</span></div>
        </div>
        
        <div id="ult-guide">
            [SPACE] ÌïÑÏÇ¥Í∏∞: ÌôîÎ©¥ Ï†ÑÏ≤¥ Í≥µÍ≤© (5Î∂Ñ Ïø®ÌÉÄÏûÑ / ÎØºÏ¥à ÌöçÎìù Ïãú Ï∂©Ï†Ñ)
        </div>

        <div id="damage-layer"></div>
        <div id="hp-bars-layer"></div> <!-- Ï≤¥Î†•Î∞î Î†àÏù¥Ïñ¥ -->
    </div>

    <!-- Î†àÎ≤®ÏóÖ Î™®Îã¨ -->
    <div id="levelup-modal">
        <div class="modal-title">Î†àÎ≤® ÏóÖ!</div>
        <div class="card-container" id="upgrade-cards"></div>
    </div>

    <!-- Í≤åÏûÑ Ïò§Î≤Ñ ÌôîÎ©¥ -->
    <div id="game-over-screen">
        <div class="go-title">ÏÇ¨ Îßù</div>
        <div class="go-score">ÏµúÏ¢Ö Í∏∞Î°ù: <span id="final-time">00:00</span> / Ï≤òÏπò: <span id="final-kills">0</span></div>
        <button onclick="location.reload()">Îã§Ïãú ÎèÑÏ†ÑÌïòÍ∏∞</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // ==========================================
        // 1. Í≤åÏûÑ ÏÑ§Ï†ï Î∞è Ï¥àÍ∏∞Ìôî
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e); 
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 60);

        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -40, window.innerWidth / 40,
            window.innerHeight / 40, window.innerHeight / -40,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);
        camera.zoom = 1.2;
        camera.updateProjectionMatrix();

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(200, 100, 0x444444, 0x333333));

        // ==========================================
        // 2. Î™®Îç∏ Î°úÎî© (ÌîåÎ†àÏù¥Ïñ¥ Î∞è Ï†Å)
        // ==========================================
        const loader = new GLTFLoader();
        const loadedModels = { player: null, maleEnemy: null, femaleEnemy: null, boss: null };

        // ÌîåÎ†àÏù¥Ïñ¥
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        const pGeo = new THREE.BoxGeometry(1, 1, 1);
        const pMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const playerFallback = new THREE.Mesh(pGeo, pMat);
        playerFallback.position.y = 0.5;
        playerFallback.castShadow = true;
        playerGroup.add(playerFallback);

        // ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†•Î∞î ÏÉùÏÑ±
        const playerHpBar = document.createElement('div');
        playerHpBar.className = 'hp-bar-container player-hp-bar';
        playerHpBar.innerHTML = '<div class="hp-bar-fill"></div>';
        document.getElementById('hp-bars-layer').appendChild(playerHpBar);
        playerHpBar.style.display = 'block';

        let playerMixer;
        loader.load('./player.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(1, 1, 1);
            model.traverse(o => { if(o.isMesh) o.castShadow = true; });
            playerGroup.remove(playerFallback);
            playerGroup.add(model);
            playerMixer = new THREE.AnimationMixer(model);
            if(gltf.animations.length > 0) playerMixer.clipAction(gltf.animations[0]).play();
        }, undefined, () => console.log('Player model not found. Using box.'));

        // Ï†Å Î™®Îç∏ ÎØ∏Î¶¨ Î°úÎìú
        loader.load('./male_enemy.glb', (gltf) => { loadedModels.maleEnemy = gltf; }, undefined, () => {});
        loader.load('./female_enemy.glb', (gltf) => { loadedModels.femaleEnemy = gltf; }, undefined, () => {});

        // ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏ ÏãúÍ∞ÅÌö®Í≥º
        const mistGeo = new THREE.RingGeometry(0.5, 4, 32);
        const mistMat = new THREE.MeshBasicMaterial({ color: 0x800080, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
        const mistMesh = new THREE.Mesh(mistGeo, mistMat);
        mistMesh.rotation.x = -Math.PI / 2;
        mistMesh.position.y = 0.1;
        playerGroup.add(mistMesh);

        // ==========================================
        // 3. Í≤åÏûÑ ÏÉÅÌÉú Î∞è Î≥ÄÏàò
        // ==========================================
        const gameState = {
            isPlaying: true, isPaused: false, time: 0,
            level: 1, exp: 0, maxExp: 10, kills: 0,
            hp: 100, maxHp: 100,
            bombs: 1, // Ï¥àÍ∏∞ ÌïÑÏÇ¥Í∏∞ Í∞úÏàò
            bombTimer: 0, // ÏûêÎèô Ï∂©Ï†Ñ ÌÉÄÏù¥Î®∏
            quoteChance: 0 // ÎåÄÏÇ¨ Ï∂úÎ†• ÌôïÎ•† (0 ~ 20)
        };
        const BOMB_COOLDOWN_TIME = 300; // 300Ï¥à = 5Î∂Ñ

        const playerStats = {
            moveSpeed: 0.15, 
            damageMult: 1.0, 
            pickupRange: 3.0, 
            luck: 1.0,
            attackSpeed: 1.0 
        };

        const inventory = {
            qrBeam: { level: 1, active: true, name: "QRÏΩîÎìú Îπî", type: "weapon", cooldown: 0.8, lastShot: 0, damage: 10 },
            // NFT Í≥ÑÏïΩÏÑú: Í∏∞Î≥∏ Ìå®ÏãúÎ∏å. Î†àÎ≤®ÏóÖ Ïãú ÎçòÏßà ÌôïÎ•†Í≥º Î≥¥Ïä§ Îç∞ÎØ∏ÏßÄ Ï¶ùÍ∞Ä.
            nftContract: { 
                level: 0, active: true, name: "NFT Í≥ÑÏïΩÏÑú", type: "passive", 
                desc: "Í≥µÍ≤© Ïãú ÏùºÏ†ï ÌôïÎ•†Î°ú Í≥ÑÏïΩÏÑú Ìà¨Ï≤ô. ÏùºÎ∞òÏ†Å Ï¶âÏÇ¨, Î≥¥Ïä§ ÏµúÎåÄ Ï≤¥Î†• ÎπÑÎ°Ä ÌîºÌï¥.", 
                throwChance: 0.01, // Í∏∞Î≥∏ ÎçòÏßà ÌôïÎ•† 1%
                bossDmgRate: 0.10 // Í∏∞Î≥∏ Î≥¥Ïä§ Îç∞ÎØ∏ÏßÄ 10%
            },
            mist: { level: 0, active: false, name: "ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏", type: "weapon", cooldown: 0.5, lastTick: 0, damage: 3, range: 4 },
            chunjat: { level: 0, active: false, name: "Ï∂òÏû£", type: "passive", effect: "speed", val: 0.05 },
            movingMan: { level: 0, active: false, name: "Î¨¥ÎπôÎß®", type: "passive", effect: "haste", val: 0.1 }, 
            clover: { level: 0, active: false, name: "ÌñâÏö¥Ïùò ÌÅ¥Î°úÎ≤Ñ", type: "passive", effect: "might", val: 0.2 }
        };

        const enemies = [];
        const projectiles = [];
        const enemyProjectiles = []; 
        const gems = [];
        const minchos = []; 
        const keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowLeft:false, ArrowDown:false, ArrowRight:false, " ": false };

        const deathQuotes = {
            female: ["Ïó¨ÏûêÎäî ÏïàÎêòÎÇòÏöî", "Í≤∏ÏÉÅÌï¥Ïöî"],
            male: ["Í≤åÏù¥Ï°∞Ïù¥Í≥†", "Ï£ÑÏÜ°Ìï©ÎãàÎã§ Ï†úÍ∞Ä ....", "Îãà.ÎãàÍ≤å Í∑∏Îü∞ ÏÇ¨ÎùºÎØ∏", "Ïñ¥~~~~~‚ô¨"],
            boss: ["ÎÇ¥Í∞Ä.. ÎÇ¥Í∞Ä Ìï¥Í≥†ÎùºÎãà!!", "Ìá¥ÏßÅÍ∏àÏùÄ..?", "ÌöåÏãù.. Í∞ÄÏïºÏßÄ.."]
        };

        // ==========================================
        // 4. Í≤åÏûÑ Î°úÏßÅ
        // ==========================================
        window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = true; });
        window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = false; });

        function createHpBar(entity, isPlayer = false, isBoss = false) {
            if (isPlayer) return playerHpBar;
            const bar = document.createElement('div');
            bar.className = isBoss ? 'hp-bar-container boss-hp-bar' : 'hp-bar-container';
            bar.innerHTML = '<div class="hp-bar-fill"></div>';
            document.getElementById('hp-bars-layer').appendChild(bar);
            bar.style.display = 'block';
            return bar;
        }

        function updateHpBar(entity, bar, offsetY = 2.0) {
            if (!entity || !bar) return;
            // 3D Ï¢åÌëúÎ•º 2D ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò
            const pos = entity.position.clone();
            pos.y += offsetY; // Î®∏Î¶¨ ÏúÑ
            pos.project(camera);
            
            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(pos.y * 0.5) + 0.5) * window.innerHeight;

            // ÌôîÎ©¥ Î∞ñÏù¥Î©¥ Ïà®ÍπÄ
            if (pos.z > 1 || x < 0 || x > window.innerWidth || y < 0 || y > window.innerHeight) {
                bar.style.display = 'none';
            } else {
                bar.style.display = 'block';
                bar.style.left = `${x}px`;
                bar.style.top = `${y}px`;
            }

            // Ï≤¥Î†• ÎπÑÏú® ÏóÖÎç∞Ïù¥Ìä∏
            const hp = isNaN(entity.userData.hp) ? gameState.hp : entity.userData.hp;
            const maxHp = isNaN(entity.userData.maxHp) ? gameState.maxHp : entity.userData.maxHp;
            const pct = Math.max(0, (hp / maxHp) * 100);
            bar.querySelector('.hp-bar-fill').style.width = `${pct}%`;
        }

        function spawnEnemy(isBoss = false) {
            if (gameState.isPaused) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = 15 + Math.random() * 10;
            const x = playerGroup.position.x + Math.cos(angle) * distance;
            const z = playerGroup.position.z + Math.sin(angle) * distance;
            
            let type = 'male';
            if (!isBoss) {
                const isRanged = Math.random() > 0.7;
                type = isRanged ? 'female' : 'male';
            } else {
                type = 'boss';
            }
            
            let enemyMesh;
            let mixer = null;

            if (type === 'boss') {
                // Î≥¥Ïä§: Í±∞ÎåÄÌïú Îπ®Í∞Ñ Î∞ïÏä§ or Î™®Îç∏
                const geo = new THREE.BoxGeometry(2, 4, 2);
                const mat = new THREE.MeshStandardMaterial({ color: 0xff4400 });
                enemyMesh = new THREE.Mesh(geo, mat);
                enemyMesh.position.y = 2;
            } else if (type === 'male') {
                if (loadedModels.maleEnemy) {
                    enemyMesh = SkeletonUtils.clone(loadedModels.maleEnemy.scene);
                    enemyMesh.scale.set(1, 1, 1);
                    const clips = loadedModels.maleEnemy.animations;
                    if(clips && clips.length > 0) { mixer = new THREE.AnimationMixer(enemyMesh); mixer.clipAction(clips[0]).play(); }
                } else {
                    const geo = new THREE.BoxGeometry(1, 1.5, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x3366ff });
                    enemyMesh = new THREE.Mesh(geo, mat);
                    enemyMesh.position.y = 0.75;
                }
            } else {
                if (loadedModels.femaleEnemy) {
                    enemyMesh = SkeletonUtils.clone(loadedModels.femaleEnemy.scene);
                    enemyMesh.scale.set(1, 1, 1);
                    const clips = loadedModels.femaleEnemy.animations;
                    if(clips && clips.length > 0) { mixer = new THREE.AnimationMixer(enemyMesh); mixer.clipAction(clips[0]).play(); }
                } else {
                    const geo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 12);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xff66cc });
                    enemyMesh = new THREE.Mesh(geo, mat);
                    enemyMesh.position.y = 0.75;
                }
            }
            enemyMesh.traverse(o => { if(o.isMesh) o.castShadow = true; });
            enemyMesh.position.set(x, isBoss ? 2 : 0, z);
            if (!loadedModels[type + 'Enemy'] && type !== 'boss') enemyMesh.position.y = 0.75;

            let hp = 15 + (gameState.time * 0.5);
            if (type === 'female') hp *= 0.7;
            if (type === 'boss') hp = hp * 50 + 500; // Î≥¥Ïä§ Ï≤¥Î†• ÎπµÎπµÌïòÍ≤å

            // Ï≤¥Î†•Î∞î ÏÉùÏÑ±
            const hpBar = createHpBar(enemyMesh, false, isBoss);

            enemyMesh.userData = { 
                type: type, 
                hp: hp, 
                maxHp: hp, 
                speed: type === 'boss' ? 0.03 : (type === 'female' ? 0.04 : 0.05), 
                attackCooldown: 0, 
                mixer: mixer, 
                hpBar: hpBar,
                isBoss: isBoss // Î≥¥Ïä§ ÌîåÎûòÍ∑∏
            };
            scene.add(enemyMesh);
            enemies.push(enemyMesh);
        }

        function createDamageText(position, damage, isMincho = false, isDeathQuote = false) {
            const div = document.createElement('div');
            if (isDeathQuote) {
                div.className = 'damage-text death-quote';
                div.innerText = damage; 
            } else if (isMincho) {
                div.className = 'damage-text mincho-text';
                div.innerText = "ÎØºÏ¥à ÌöçÎìù! (+1 ÌïÑÏÇ¥Í∏∞)";
            } else {
                div.className = 'damage-text';
                div.innerText = Math.floor(damage);
            }
            
            const vec = position.clone();
            if(isDeathQuote) vec.y += 2; 
            
            vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            div.style.left = `${x}px`; div.style.top = `${y}px`;
            
            document.getElementById('damage-layer').appendChild(div);
            setTimeout(() => div.remove(), isDeathQuote ? 2000 : 1000); 
        }

        function spawnGem(position, value) {
            const geo = new THREE.OctahedronGeometry(0.3);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa });
            const gem = new THREE.Mesh(geo, mat);
            gem.position.copy(position); gem.position.y = 0.5; gem.userData = { value: value };
            scene.add(gem); gems.push(gem);
        }

        function spawnMincho(position) {
            const group = new THREE.Group();
            const iceGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const iceMat = new THREE.MeshStandardMaterial({ color: 0x00ffaa, roughness: 0.5 });
            const ice = new THREE.Mesh(iceGeo, iceMat);
            group.add(ice);
            const chipGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const chipMat = new THREE.MeshStandardMaterial({ color: 0x3e2723 });
            for(let i=0; i<5; i++) {
                const chip = new THREE.Mesh(chipGeo, chipMat);
                chip.position.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.35);
                group.add(chip);
            }
            group.position.copy(position); group.position.y = 0.5;
            const light = new THREE.PointLight(0x00ffaa, 1, 3);
            group.add(light);
            scene.add(group); minchos.push(group);
        }

        function getNearestEnemy() {
            let nearest = null; let minDist = Infinity;
            enemies.forEach(e => {
                const d = playerGroup.position.distanceTo(e.position);
                if (d < minDist) { minDist = d; nearest = e; }
            });
            return { enemy: nearest, dist: minDist };
        }

        function useBomb() {
            if (gameState.bombs <= 0) return;
            gameState.bombs--;
            updateBombUI();
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // HPÎ∞î Ï†úÍ±∞
                if(enemy.userData.hpBar) enemy.userData.hpBar.remove();
                
                spawnGem(enemy.position, 1);
                gameState.kills++;
                scene.remove(enemy);
                enemies.splice(i, 1);
            }
            document.getElementById('kill-count').innerText = gameState.kills;
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) { scene.remove(enemyProjectiles[i]); }
            enemyProjectiles.length = 0;
            const blastGeo = new THREE.SphereGeometry(1, 32, 32);
            const blastMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const blast = new THREE.Mesh(blastGeo, blastMat);
            blast.position.copy(playerGroup.position);
            scene.add(blast);
            let scale = 1;
            const expandInterval = setInterval(() => {
                scale += 2; blast.scale.set(scale, scale, scale); blast.material.opacity -= 0.05;
                if (blast.material.opacity <= 0) { clearInterval(expandInterval); scene.remove(blast); }
            }, 16);
        }

        function updateBombUI() { document.getElementById('bomb-val').innerText = gameState.bombs; }

        function fireWeapons(delta) {
            const atkSpeed = playerStats.attackSpeed;

            if (inventory.qrBeam.active) {
                inventory.qrBeam.lastShot += delta * atkSpeed; 
                if (inventory.qrBeam.lastShot >= inventory.qrBeam.cooldown) {
                    const info = getNearestEnemy();
                    if (info.enemy && info.dist < 15) { 
                        shootQR(info.enemy); 
                        
                        // NFT Í≥ÑÏïΩÏÑú Î∞úÎèô Î°úÏßÅ (ÎçòÏßà ÌôïÎ•† Ï≤¥ÌÅ¨)
                        // Î†àÎ≤® 0(ÎØ∏ÏäµÎìù)Ïù¥Ïñ¥ÎèÑ Í∏∞Î≥∏ ÌôïÎ•† 1%Î°ú Î∞úÎèô
                        // Î†àÎ≤® 1~5: ÌôïÎ•† Î∞è Îç∞ÎØ∏ÏßÄ Ï¶ùÍ∞Ä
                        const chance = inventory.nftContract.throwChance;
                        if (Math.random() < chance) {
                            throwContract();
                        }

                        inventory.qrBeam.lastShot = 0; 
                    }
                }
            }

            if (inventory.mist.active) {
                mistMesh.material.opacity = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                mistMesh.scale.set(inventory.mist.range, inventory.mist.range, 1);
                inventory.mist.lastTick += delta * atkSpeed; 
                if (inventory.mist.lastTick >= inventory.mist.cooldown) {
                    enemies.forEach(e => {
                        if (playerGroup.position.distanceTo(e.position) <= inventory.mist.range) takeDamage(e, inventory.mist.damage * playerStats.damageMult);
                    });
                    inventory.mist.lastTick = 0;
                }
            } else { mistMesh.material.opacity = 0; }
        }

        function shootQR(target) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const beam = new THREE.Mesh(geo, mat);
            beam.position.copy(playerGroup.position); beam.position.y = 1;
            beam.lookAt(target.position.x, 1, target.position.z);
            const dir = new THREE.Vector3(target.position.x - playerGroup.position.x, 0, target.position.z - playerGroup.position.z).normalize();
            beam.userData = { velocity: dir.multiplyScalar(0.4), damage: inventory.qrBeam.damage * playerStats.damageMult, duration: 2, hitList: [] };
            scene.add(beam); projectiles.push(beam);
        }

        function throwContract() {
            const geo = new THREE.BoxGeometry(0.8, 0.1, 0.5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const paper = new THREE.Mesh(geo, mat);
            paper.position.copy(playerGroup.position); paper.position.y = 1;
            const angle = Math.random() * Math.PI * 2;
            const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).normalize();
            
            // NFT Í≥ÑÏïΩÏÑúÎäî Ï¶âÏÇ¨(ÏùºÎ∞ò) or ÎπÑÎ°ÄÎç∞ÎØ∏ÏßÄ(Î≥¥Ïä§)
            // Ìà¨ÏÇ¨Ï≤¥ Ï†ïÎ≥¥Ïóê Î≥¥Ïä§ Îç∞ÎØ∏ÏßÄ ÎπÑÏú® Ï†ÄÏû•
            paper.userData = { 
                type: 'contract', 
                velocity: dir.multiplyScalar(0.3), 
                bossDmgRate: inventory.nftContract.bossDmgRate,
                duration: 3, 
                pierce: 5, // Í¥ÄÌÜµÎ†• ÎÜíÍ≤å
                hitList: [] 
            };
            scene.add(paper); projectiles.push(paper);
        }

        function enemyShootHeart(enemy) {
            const geo = new THREE.SphereGeometry(0.4, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0x550000 });
            const heart = new THREE.Mesh(geo, mat);
            heart.position.copy(enemy.position); heart.position.y = 1;
            const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position).normalize();
            heart.userData = { velocity: dir.multiplyScalar(0.15), damage: 10, duration: 4 };
            scene.add(heart); enemyProjectiles.push(heart);
        }

        function takeDamage(enemy, amount) {
            enemy.userData.hp -= amount;
            createDamageText(enemy.position, amount);
            enemy.traverse(child => { if(child.isMesh) {
                child.material.emissive.setHex(0xff0000);
                setTimeout(() => child.material.emissive.setHex(0x000000), 100);
            }});

            if (enemy.userData.hp <= 0) {
                // ÏÇ¨Îßù ÎåÄÏÇ¨ Ï∂úÎ†• (ÌôïÎ•†: gameState.quoteChance %)
                if (Math.random() * 100 < gameState.quoteChance) {
                    const quotes = deathQuotes[enemy.userData.type];
                    if (quotes) {
                        const quote = quotes[Math.floor(Math.random() * quotes.length)];
                        createDamageText(enemy.position, quote, false, true); 
                    }
                }

                // Ï≤¥Î†•Î∞î Ï†úÍ±∞
                if(enemy.userData.hpBar) enemy.userData.hpBar.remove();

                spawnGem(enemy.position, enemy.userData.isBoss ? 50 : 1); // Î≥¥Ïä§Îäî Í≤ΩÌóòÏπò ÎßéÏù¥
                
                // ÎØºÏ¥à ÎìúÎûç (1% ÌôïÎ•†)
                if (Math.random() < 0.01) spawnMincho(enemy.position);

                gameState.kills++;
                document.getElementById('kill-count').innerText = gameState.kills;
                scene.remove(enemy);
                const idx = enemies.indexOf(enemy);
                if (idx > -1) enemies.splice(idx, 1);
            }
        }

        function damagePlayer(amount) {
            gameState.hp = Math.max(0, gameState.hp - amount);
            document.getElementById('hp-val').innerText = Math.floor(gameState.hp);
            if(playerGroup.children[0]) {
                const mesh = playerGroup.children[0];
                mesh.traverse(o => {
                    if(o.isMesh) {
                        const oldColor = o.material.color.getHex();
                        o.material.color.setHex(0xff0000);
                        setTimeout(() => o.material.color.setHex(oldColor), 100);
                    }
                });
            }
            if (gameState.hp <= 0) gameOver();
        }

        function checkLevelUp() {
            if (gameState.exp >= gameState.maxExp) {
                gameState.exp -= gameState.maxExp;
                gameState.level++;
                gameState.maxExp = Math.floor(gameState.maxExp * 1.5);
                document.getElementById('level-val').innerText = gameState.level;
                showLevelUpModal();
            }
            document.getElementById('exp-bar').style.width = `${(gameState.exp / gameState.maxExp) * 100}%`;
        }

        function showLevelUpModal() {
            gameState.isPaused = true;
            const modal = document.getElementById('levelup-modal');
            const container = document.getElementById('upgrade-cards');
            container.innerHTML = '';
            modal.style.display = 'flex';

            const options = [
                { key: 'qrBeam', title: 'QRÏΩîÎìú Îπî', desc: 'Í∏∞Î≥∏ Í≥µÍ≤© ÏÜçÎèÑ/Îç∞ÎØ∏ÏßÄ Ï¶ùÍ∞Ä', icon: 'üì±' },
                { key: 'nftContract', title: 'NFT Í≥ÑÏïΩÏÑú', desc: 'ÎçòÏßà ÌôïÎ•†/Î≥¥Ïä§ Îç∞ÎØ∏ÏßÄ Ï¶ùÍ∞Ä', icon: 'üìÑ' },
                { key: 'mist', title: 'ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏', desc: 'Ï£ºÎ≥Ä ÏßÄÏÜç Îç∞ÎØ∏ÏßÄ Ïò§Îùº', icon: '‚ò†Ô∏è' },
                { key: 'chunjat', title: 'Ï∂òÏû£', desc: 'Ïù¥Îèô ÏÜçÎèÑ 5% Ï¶ùÍ∞Ä', icon: 'üå∞' },
                { key: 'movingMan', title: 'Î¨¥ÎπôÎß®', desc: 'Í≥µÍ≤© ÏÜçÎèÑ 10% Ï¶ùÍ∞Ä', icon: 'üèÉ' },
                { key: 'clover', title: 'ÌñâÏö¥Ïùò ÌÅ¥Î°úÎ≤Ñ', desc: 'Í≥µÍ≤©Î†• 20% Ï¶ùÍ∞Ä', icon: 'üçÄ' }
            ];
            options.sort(() => Math.random() - 0.5);
            
            options.slice(0, 3).forEach(opt => {
                const item = inventory[opt.key];
                let btnText = item.level === 0 ? "Ïã†Í∑ú ÏäµÎìù" : `Lv.${item.level} -> Lv.${item.level+1}`;
                if (item.type === 'passive') btnText = "Í∞ïÌôî";
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `<div class="card-icon">${opt.icon}</div><div class="card-name">${opt.title}</div><div class="card-desc">${opt.desc}</div><div class="card-level">${btnText}</div>`;
                card.onclick = () => { applyUpgrade(opt.key); modal.style.display = 'none'; gameState.isPaused = false; };
                container.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            const item = inventory[key];
            item.active = true; item.level++;
            if (key === 'qrBeam') { item.damage += 5; item.cooldown *= 0.9; }
            else if (key === 'nftContract') { 
                // Î†àÎ≤®ÏóÖ Ïãú ÎçòÏßà ÌôïÎ•† 1% Ï¶ùÍ∞Ä (ÏµúÎåÄ 5%)
                item.throwChance = Math.min(0.05, 0.01 * (item.level + 1)); // Lv0->1%.. Lv4->5%
                // Î≥¥Ïä§ Îç∞ÎØ∏ÏßÄ ÎπÑÏú® Ï¶ùÍ∞Ä (ÏµúÎåÄ 25%)
                item.bossDmgRate = Math.min(0.25, 0.10 + (item.level * 0.03)); 
            }
            else if (key === 'mist') { item.damage += 2; item.range += 0.5; }
            else if (key === 'chunjat') { playerStats.moveSpeed += item.val; }
            else if (key === 'movingMan') { playerStats.attackSpeed += item.val; } 
            else if (key === 'clover') { playerStats.damageMult += item.val; }
        }

        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('final-time').innerText = document.getElementById('timer').innerText;
            document.getElementById('final-kills').innerText = gameState.kills;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        // ==========================================
        // 6. Î©îÏù∏ Î£®ÌîÑ
        // ==========================================
        const clock = new THREE.Clock();
        
        setInterval(() => {
            if (!gameState.isPlaying || gameState.isPaused) return;
            // Ï†Å ÏÉùÏÑ± Î¨ºÎüâ ÎåÄÌè≠ Ï¶ùÍ∞Ä
            const spawnCount = 2 + Math.floor(gameState.time / 20); 
            for(let i=0; i<spawnCount; i++) spawnEnemy();
            
            // 60Ï¥àÎßàÎã§ Î≥¥Ïä§(Î∂ÄÏû•Îãò) Îì±Ïû•
            if (gameState.time > 0 && gameState.time % 60 === 0) {
                spawnEnemy(true);
            }

            gameState.time++;

            // ÎåÄÏÇ¨ Ï∂úÎ†• ÌôïÎ•† ÏóÖÎç∞Ïù¥Ìä∏ (10Ï¥àÎßàÎã§ 1% Ï¶ùÍ∞Ä, ÏµúÎåÄ 20%)
            if (gameState.time % 10 === 0) {
                gameState.quoteChance = Math.min(20, gameState.quoteChance + 1);
            }

            const m = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const s = (gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            if (!gameState.isPlaying || gameState.isPaused) return;

            const delta = clock.getDelta();

            // ÌïÑÏÇ¥Í∏∞ ÏûÖÎ†•
            if (keys[' ']) {
                useBomb();
                keys[' '] = false;
            }

            // ÌïÑÏÇ¥Í∏∞ ÏûêÎèô Ï∂©Ï†Ñ
            gameState.bombTimer += delta;
            if (gameState.bombTimer >= BOMB_COOLDOWN_TIME) {
                gameState.bombs++;
                gameState.bombTimer = 0;
                updateBombUI();
            }
            const bombPct = Math.min(100, Math.floor((gameState.bombTimer / BOMB_COOLDOWN_TIME) * 100));
            document.getElementById('bomb-cooldown').innerText = `(${bombPct}%)`;

            // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys.w || keys.ArrowUp) moveDir.z -= 1;
            if (keys.s || keys.ArrowDown) moveDir.z += 1;
            if (keys.a || keys.ArrowLeft) moveDir.x -= 1;
            if (keys.d || keys.ArrowRight) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(playerStats.moveSpeed);
                playerGroup.position.add(moveDir);
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                if(playerMixer) playerGroup.children.forEach(c => { if(c.isGroup) c.rotation.y = targetRot; });
            }

            // Ïπ¥Î©îÎùº ÌåîÎ°úÏö∞
            camera.position.x = playerGroup.position.x + 20;
            camera.position.z = playerGroup.position.z + 20;
            dirLight.position.x = playerGroup.position.x + 10;
            dirLight.position.z = playerGroup.position.z + 10;
            ground.position.x = playerGroup.position.x;
            ground.position.z = playerGroup.position.z;

            // Î°úÏßÅ ÏóÖÎç∞Ïù¥Ìä∏
            fireWeapons(delta);
            if (playerMixer) playerMixer.update(delta);

            // ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†•Î∞î ÏóÖÎç∞Ïù¥Ìä∏
            updateHpBar(playerGroup.children[0], playerHpBar); 

            // Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.velocity);
                if (p.userData.type === 'contract') p.rotation.y += 0.2;
                p.userData.duration -= delta;
                if (p.userData.duration <= 0) { scene.remove(p); projectiles.splice(i, 1); continue; }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const distSq = (p.position.x - enemy.position.x)**2 + (p.position.z - enemy.position.z)**2;
                    if (distSq < 1.5 * 1.5) {
                        if (p.userData.hitList && p.userData.hitList.includes(enemy.id)) continue;
                        
                        // Îç∞ÎØ∏ÏßÄ Í≥ÑÏÇ∞ (Í≥ÑÏïΩÏÑú ÌäπÏàò Î°úÏßÅ)
                        let damage = p.userData.damage;
                        if (p.userData.type === 'contract') {
                            if (enemy.userData.isBoss) {
                                // Î≥¥Ïä§: ÏµúÎåÄ Ï≤¥Î†• ÎπÑÎ°Ä Îç∞ÎØ∏ÏßÄ
                                damage = enemy.userData.maxHp * p.userData.bossDmgRate;
                            } else {
                                // ÏùºÎ∞ò: Ï¶âÏÇ¨ (HPÎßåÌÅº Îç∞ÎØ∏ÏßÄ)
                                damage = enemy.userData.hp;
                            }
                        }

                        takeDamage(enemy, damage);
                        if (p.userData.hitList) p.userData.hitList.push(enemy.id);
                        
                        // Í¥ÄÌÜµ Ï≤òÎ¶¨
                        if (p.userData.type !== 'contract') { scene.remove(p); projectiles.splice(i, 1); break; }
                        else if (p.userData.hitList.length >= p.userData.pierce) { scene.remove(p); projectiles.splice(i, 1); break; }
                    }
                }
            }

            // Ï†Å Ìà¨ÏÇ¨Ï≤¥
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const ep = enemyProjectiles[i];
                ep.position.add(ep.userData.velocity);
                ep.userData.duration -= delta;
                const pDist = ep.position.distanceTo(playerGroup.position);
                if (pDist < 1.0) {
                    damagePlayer(ep.userData.damage);
                    scene.remove(ep);
                    enemyProjectiles.splice(i, 1);
                    continue;
                }
                if (ep.userData.duration <= 0) { scene.remove(ep); enemyProjectiles.splice(i, 1); }
            }

            // Ï†Å AI
            enemies.forEach(enemy => {
                // Ï≤¥Î†•Î∞î ÏóÖÎç∞Ïù¥Ìä∏
                updateHpBar(enemy, enemy.userData.hpBar, enemy.userData.isBoss ? 4.5 : 2.0);

                if (enemy.userData.mixer) enemy.userData.mixer.update(delta);
                const distToPlayer = enemy.position.distanceTo(playerGroup.position);
                const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position).normalize();

                if (enemy.userData.type === 'male' || enemy.userData.type === 'boss') {
                    enemy.position.add(dir.multiplyScalar(enemy.userData.speed));
                    if (distToPlayer < (enemy.userData.isBoss ? 2.5 : 0.8)) damagePlayer(enemy.userData.isBoss ? 5 : 0.5);
                } else {
                    if (distToPlayer > 8) enemy.position.add(dir.multiplyScalar(enemy.userData.speed));
                    enemy.userData.attackCooldown -= delta;
                    if (enemy.userData.attackCooldown <= 0 && distToPlayer < 12) {
                        enemyShootHeart(enemy);
                        enemy.userData.attackCooldown = 2.0;
                    }
                }
                enemy.lookAt(playerGroup.position);
            });

            // Î≥¥ÏÑù ÏäµÎìù
            for (let i = gems.length - 1; i >= 0; i--) {
                const gem = gems[i];
                const dist = playerGroup.position.distanceTo(gem.position);
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(playerGroup.position, gem.position).normalize();
                    gem.position.add(dir.multiplyScalar(0.3));
                    if (dist < 0.5) { gameState.exp += gem.userData.value; scene.remove(gem); gems.splice(i, 1); checkLevelUp(); }
                } else { gem.rotation.y += 0.05; }
            }

            // ÎØºÏ¥à ÏäµÎìù
            for (let i = minchos.length - 1; i >= 0; i--) {
                const m = minchos[i];
                const dist = playerGroup.position.distanceTo(m.position);
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(playerGroup.position, m.position).normalize();
                    m.position.add(dir.multiplyScalar(0.3));
                    if (dist < 0.5) { 
                        gameState.bombs++;
                        updateBombUI();
                        createDamageText(playerGroup.position, 0, true); 
                        scene.remove(m); minchos.splice(i, 1); 
                    }
                } else { m.rotation.y += 0.05; }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 40;
            camera.left = -viewSize * aspect; camera.right = viewSize * aspect;
            camera.top = viewSize; camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>