<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>í•œíƒ•ì´ì˜ ìƒì¡´ ì‹ ê³  (Vampire Survivors Style)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #101020; font-family: 'Black Han Sans', sans-serif; user-select: none; }
        
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Gowun+Batang&display=swap');

        /* UI ë ˆì´ì•„ì›ƒ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* ìƒë‹¨ ì •ë³´ë°” */
        #top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; align-items: center;
            opacity: 0; transition: opacity 0.5s; /* ì‹œì‘ ì „ì—” ìˆ¨ê¹€ */
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 15px;
            color: #fff; border: 2px solid #555; font-size: 20px; text-shadow: 1px 1px 2px black;
            display: flex; align-items: center; gap: 10px;
        }
        #score { color: #ffd700; }
        #timer { color: #fff; min-width: 60px; text-align: center; }
        #hp-box { color: #ff5555; border-color: #ff5555; }
        #bomb-box { color: #00ffaa; border-color: #00ffaa; }

        /* ê²½í—˜ì¹˜ ë°” */
        #exp-bar-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10;
            opacity: 0; transition: opacity 0.5s;
        }
        #exp-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); transition: width 0.2s;
        }
        #level-indicator {
            position: absolute; top: 15px; right: 20px; color: #00f2fe; font-size: 30px; text-shadow: 2px 2px 0 #000;
            opacity: 0; transition: opacity 0.5s;
        }

        /* ì‹œì‘ í™”ë©´ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4); 
            z-index: 300; pointer-events: auto;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            backdrop-filter: blur(2px);
        }
        .start-title {
            font-size: 80px; color: #ffd700; text-shadow: 0 0 20px #ff5500;
            margin-bottom: 20px; animation: float 3s infinite ease-in-out;
        }
        .start-btn {
            padding: 20px 60px; font-size: 30px; background: linear-gradient(45deg, #ff0055, #ff5500);
            color: white; border: 4px solid white; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Black Han Sans', sans-serif;
        }
        .start-btn:hover { transform: scale(1.1); box-shadow: 0 0 40px rgba(255, 0, 85, 0.8); }
        .camera-label-container {
            position: absolute; bottom: 10%; width: 100%; display: flex; justify-content: center; gap: 40px;
            pointer-events: none; color: rgba(255,255,255,0.3); font-size: 20px;
        }
        .cam-label { transition: all 0.5s; }
        .cam-active { color: #00ffff; font-weight: bold; transform: scale(1.2); text-shadow: 0 0 10px #00ffff; opacity: 1; }

        /* ë ˆë²¨ì—… ì„ íƒì°½ */
        #levelup-modal {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
            pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .modal-title { font-size: 50px; color: #ffd700; margin-bottom: 30px; text-shadow: 0 0 10px orange; animation: float 2s infinite; }
        .card-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card {
            width: 200px; height: 280px; background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #666; border-radius: 10px; padding: 15px;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .upgrade-card:hover { transform: translateY(-10px); border-color: #fff; background: #333; }
        .card-icon { font-size: 50px; margin-bottom: 10px; }
        .card-name { font-size: 24px; color: #fff; margin-bottom: 10px; color: #00ff00; }
        .card-desc { font-size: 16px; color: #ccc; font-family: 'Gowun Batang', serif; line-height: 1.4; }
        .card-level { margin-top: auto; font-size: 14px; color: #888; }

        /* ê²Œì„ì˜¤ë²„ */
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.8); z-index: 200; pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        .go-title { font-size: 80px; color: #ff0055; margin-bottom: 20px; }
        .go-score { font-size: 30px; margin-bottom: 40px; }
        button {
            padding: 15px 40px; font-size: 24px; background: #fff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-family: 'Black Han Sans';
        }
        button:hover { background: #ddd; }

        /* í•„ì‚´ê¸° ì•ˆë‚´ */
        #ult-guide {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 18px; text-align: center;
            opacity: 0; transition: opacity 0.5s;
        }

        @keyframes float { 0% { transform: translateY(0); } 50% { transform: translateY(-10px); } 100% { transform: translateY(0); } }

        /* ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ */
        .damage-text {
            position: absolute; color: white; font-weight: bold; font-size: 20px;
            pointer-events: none; text-shadow: 1px 1px 0 #000;
            animation: popUp 0.8s forwards; white-space: nowrap;
        }
        .mincho-text {
            color: #00ffaa !important; font-size: 24px !important; text-shadow: 0 0 5px #00ffaa;
        }
        .death-quote {
            color: #ffff00; font-size: 18px; font-family: 'Gowun Batang', serif;
            text-shadow: 1px 1px 2px #000; z-index: 5;
        }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-40px) scale(0.8); } }

        /* ì²´ë ¥ë°” ìŠ¤íƒ€ì¼ */
        .hp-bar-container {
            position: absolute;
            width: 50px; height: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #000;
            border-radius: 3px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none; /* JSë¡œ ì œì–´ */
        }
        .hp-bar-fill {
            height: 100%;
            background: #ff0000;
            width: 100%;
            border-radius: 2px;
            transition: width 0.1s;
        }
        .player-hp-bar .hp-bar-fill {
            background: #00ff00; /* í”Œë ˆì´ì–´ëŠ” ì´ˆë¡ìƒ‰ */
        }
        .boss-hp-bar {
            width: 100px; height: 10px; border: 2px solid #ffaa00;
        }
        .boss-hp-bar .hp-bar-fill {
            background: #ffaa00;
        }
    </style>
</head>
<body>
    <!-- 3D ìº”ë²„ìŠ¤ -->
    <div id="canvas-container"></div>

    <!-- UI ë ˆì´ì–´ -->
    <div id="exp-bar-container"><div id="exp-bar"></div></div>
    
    <div id="ui-layer">
        <div id="level-indicator">LV. <span id="level-val">1</span></div>
        
        <div id="top-bar">
            <div class="stat-box" id="hp-box">HP <span id="hp-val">100</span></div>
            <div class="stat-box" id="bomb-box">ğŸ’£ <span id="bomb-val">1</span> <span id="bomb-cooldown" style="font-size:14px; color:#aaa; margin-left:5px;">(0%)</span></div>
            <div class="stat-box">TIME <span id="timer">00:00</span></div>
            <div class="stat-box">KILL <span id="kill-count">0</span></div>
        </div>
        
        <div id="ult-guide">
            [SPACE] í•„ì‚´ê¸°: í™”ë©´ ì „ì²´ ê³µê²© (5ë¶„ ì¿¨íƒ€ì„ / ë¯¼ì´ˆ íšë“ ì‹œ ì¶©ì „)
        </div>

        <div id="damage-layer"></div>
        <!-- hp-bars-layer: 3D ì²´ë ¥ë°”ë¡œ ëŒ€ì²´ë˜ì–´ ë” ìš”ì†ŒëŠ” ì œê±°í•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ë‘ë˜ ê²Œì„ ì‹œì‘ ì „ì—ëŠ” ìˆ¨ê¹€ ì²˜ë¦¬ -->
        <div id="hp-bars-layer" style="display:none"></div> 
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="start-screen">
        <div class="start-title">í•œíƒ•ì´ì˜ ìƒì¡´ ì‹ ê³ </div>
        <button class="start-btn" id="start-btn">ìƒì¡´ ì‹œì‘</button>
        <div class="camera-label-container">
            <div id="cam-label-0" class="cam-label cam-active">CAM 1: ì–¼ì§± ê°ë„</div>
            <div id="cam-label-1" class="cam-label">CAM 2: ì „ì‹  ìŠ¤ìº”</div>
            <div id="cam-label-2" class="cam-label">CAM 3: ìœ„ì„± ê°ì‹œ</div>
        </div>
    </div>

    <!-- ë ˆë²¨ì—… ëª¨ë‹¬ -->
    <div id="levelup-modal">
        <div class="modal-title">ë ˆë²¨ ì—…!</div>
        <div class="card-container" id="upgrade-cards"></div>
    </div>

    <!-- ê²Œì„ ì˜¤ë²„ í™”ë©´ -->
    <div id="game-over-screen">
        <div class="go-title">ì‚¬ ë§</div>
        <div class="go-score">ìµœì¢… ê¸°ë¡: <span id="final-time">00:00</span> / ì²˜ì¹˜: <span id="final-kills">0</span></div>
        <button onclick="location.reload()">ë‹¤ì‹œ ë„ì „í•˜ê¸°</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // ==========================================
        // 1. ê²Œì„ ì„¤ì • ë° ì´ˆê¸°í™”
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e); 
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 60);

        // ë©”ì¸ ê²Œì„ ì¹´ë©”ë¼ (Orthographic)
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -40, window.innerWidth / 40,
            window.innerHeight / 40, window.innerHeight / -40,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);
        camera.zoom = 1.2;
        camera.updateProjectionMatrix();

        // â˜… ì‹œì‘ í™”ë©´ìš© ì¹´ë©”ë¼ 3ê°œ ìƒì„± (Perspective) â˜…
        const startCam1 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        startCam1.position.set(2, 1.5, 2); // ì–¼êµ´/ìƒì²´ ê·¼ì ‘
        startCam1.lookAt(0, 1, 0);

        const startCam2 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        startCam2.position.set(0, 2, 6); // ì „ì‹  ì •ë©´
        startCam2.lookAt(0, 1, 0);

        const startCam3 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        startCam3.position.set(0, 10, 0); // ì™„ì „ íƒ‘ë·°
        startCam3.lookAt(0, 0, 0);


        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(200, 100, 0x444444, 0x333333));

        // ==========================================
        // 2. ëª¨ë¸ ë¡œë”© (í”Œë ˆì´ì–´ ë° ì )
        // ==========================================
        const loader = new GLTFLoader();
        const loadedModels = { player: null, maleEnemy: null, femaleEnemy: null, boss: null };

        // í”Œë ˆì´ì–´
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        const pGeo = new THREE.BoxGeometry(1, 1, 1);
        const pMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const playerFallback = new THREE.Mesh(pGeo, pMat);
        playerFallback.position.y = 0.5;
        playerFallback.castShadow = true;
        playerGroup.add(playerFallback);

        // â˜… ìµœì í™”: 3D ì²´ë ¥ë°” ì§€ì˜¤ë©”íŠ¸ë¦¬ ë° ì¬ì§ˆ ë¯¸ë¦¬ ìƒì„± (ê³µìœ ) â˜…
        const hpBarBgGeo = new THREE.PlaneGeometry(1, 0.15);
        const hpBarBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, depthTest: false }); 
        
        const hpBarFgGeo = new THREE.PlaneGeometry(1, 0.15);
        hpBarFgGeo.translate(0.5, 0, 0); 
        const hpBarFgMatRed = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false }); 
        const hpBarFgMatGreen = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false }); 
        const hpBarFgMatBoss = new THREE.MeshBasicMaterial({ color: 0xffaa00, depthTest: false }); 

        // í”Œë ˆì´ì–´ìš© 3D ì²´ë ¥ë°” ìƒì„±
        const playerHpBarGroup = new THREE.Group();
        playerHpBarGroup.position.y = 2.0;
        const pBg = new THREE.Mesh(hpBarBgGeo, hpBarBgMat);
        const pFg = new THREE.Mesh(hpBarFgGeo, hpBarFgMatGreen);
        pFg.position.x = -0.5; 
        pFg.position.z = 0.01; 
        playerHpBarGroup.add(pBg, pFg);
        playerGroup.add(playerHpBarGroup);
        playerHpBarGroup.visible = false; // ê²Œì„ ì‹œì‘ ì „ì—” ìˆ¨ê¹€

        let playerMixer;
        loader.load('./player.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(1, 1, 1);
            model.traverse(o => { if(o.isMesh) o.castShadow = true; });
            playerGroup.remove(playerFallback);
            playerGroup.add(model);
            playerMixer = new THREE.AnimationMixer(model);
            if(gltf.animations.length > 0) playerMixer.clipAction(gltf.animations[0]).play();
        }, undefined, () => console.log('Player model not found. Using box.'));

        loader.load('./male_enemy.glb', (gltf) => { loadedModels.maleEnemy = gltf; }, undefined, () => {});
        loader.load('./female_enemy.glb', (gltf) => { loadedModels.femaleEnemy = gltf; }, undefined, () => {});

        // íƒ€ì§€ë¦¬ ë¯¸ìŠ¤íŠ¸ ì‹œê°íš¨ê³¼
        const mistGeo = new THREE.RingGeometry(0.5, 4, 32);
        const mistMat = new THREE.MeshBasicMaterial({ color: 0x800080, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
        const mistMesh = new THREE.Mesh(mistGeo, mistMat);
        mistMesh.rotation.x = -Math.PI / 2;
        mistMesh.position.y = 0.1;
        playerGroup.add(mistMesh);

        // ==========================================
        // 3. ê²Œì„ ìƒíƒœ ë° ë³€ìˆ˜
        // ==========================================
        const gameState = {
            gameStarted: false, // ê²Œì„ ì‹œì‘ ì—¬ë¶€ í”Œë˜ê·¸
            isPlaying: true, isPaused: false, time: 0,
            level: 1, exp: 0, maxExp: 10, kills: 0,
            hp: 100, maxHp: 100,
            bombs: 1, 
            bombTimer: 0, 
            quoteChance: 0,
            cameraIndex: 0, // í˜„ì¬ í™œì„±í™”ëœ ì¹´ë©”ë¼ ì¸ë±ìŠ¤
            cameraTimer: 0 // ì¹´ë©”ë¼ ì „í™˜ íƒ€ì´ë¨¸
        };
        const BOMB_COOLDOWN_TIME = 300; 

        const playerStats = {
            moveSpeed: 0.15, 
            damageMult: 1.0, 
            pickupRange: 3.0, 
            luck: 1.0,
            attackSpeed: 1.0 
        };

        const inventory = {
            qrBeam: { level: 1, active: true, name: "QRì½”ë“œ ë¹”", type: "weapon", cooldown: 0.8, lastShot: 0, damage: 10 },
            nftContract: { 
                level: 0, active: true, name: "NFT ê³„ì•½ì„œ", type: "passive", 
                desc: "ê³µê²© ì‹œ ì¼ì • í™•ë¥ ë¡œ ê³„ì•½ì„œ íˆ¬ì²™. ì¼ë°˜ì  ì¦‰ì‚¬, ë³´ìŠ¤ ìµœëŒ€ ì²´ë ¥ ë¹„ë¡€ í”¼í•´.", 
                throwChance: 0.01, 
                bossDmgRate: 0.10 
            },
            mist: { level: 0, active: false, name: "íƒ€ì§€ë¦¬ ë¯¸ìŠ¤íŠ¸", type: "weapon", cooldown: 0.5, lastTick: 0, damage: 3, range: 4 },
            chunjat: { level: 0, active: false, name: "ì¶˜ì£", type: "passive", effect: "speed", val: 0.05 },
            movingMan: { level: 0, active: false, name: "ë¬´ë¹™ë§¨", type: "passive", effect: "haste", val: 0.1 }, 
            clover: { level: 0, active: false, name: "í–‰ìš´ì˜ í´ë¡œë²„", type: "passive", effect: "might", val: 0.2 }
        };

        const enemies = [];
        const projectiles = [];
        const enemyProjectiles = []; 
        const gems = [];
        const minchos = []; 
        const keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowLeft:false, ArrowDown:false, ArrowRight:false, " ": false };

        const deathQuotes = {
            female: ["ì—¬ìëŠ” ì•ˆë˜ë‚˜ìš”", "ê²¸ìƒí•´ìš”"],
            male: ["ê²Œì´ì¡°ì´ê³ ", "ì£„ì†¡í•©ë‹ˆë‹¤ ì œê°€ ....", "ë‹ˆ.ë‹ˆê²Œ ê·¸ëŸ° ì‚¬ë¼ë¯¸", "ì–´~~~~~â™¬"],
            boss: ["ë‚´ê°€.. ë‚´ê°€ í•´ê³ ë¼ë‹ˆ!!", "í‡´ì§ê¸ˆì€..?", "íšŒì‹.. ê°€ì•¼ì§€.."]
        };

        const MAX_ENEMIES = 100; // ìµœì í™”ë¥¼ ìœ„í•œ ìµœëŒ€ ì  ìˆ˜ ì œí•œ

        // ==========================================
        // 4. ê²Œì„ ë¡œì§
        // ==========================================
        window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = true; });
        window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = false; });

        // ê²Œì„ ì‹œì‘ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('start-btn').addEventListener('click', () => {
            gameState.gameStarted = true;
            document.getElementById('start-screen').style.display = 'none';
            // UI ë³´ì´ê¸°
            document.getElementById('top-bar').style.opacity = '1';
            document.getElementById('exp-bar-container').style.opacity = '1';
            document.getElementById('level-indicator').style.opacity = '1';
            document.getElementById('ult-guide').style.opacity = '1';
            document.getElementById('hp-bars-layer').style.display = 'block';
            playerHpBarGroup.visible = true;
        });

        function update3DHpBar(mesh, hp, maxHp) {
            const barGroup = mesh.children.find(c => c.userData.isHpBar);
            if (barGroup) {
                const fg = barGroup.children[1];
                const pct = Math.max(0, hp / maxHp);
                fg.scale.x = pct;
                barGroup.lookAt(camera.position); 
            }
        }

        function create3DHpBar(type) {
            const group = new THREE.Group();
            group.userData.isHpBar = true; 
            
            const bg = new THREE.Mesh(hpBarBgGeo, hpBarBgMat);
            
            let mat = hpBarFgMatRed;
            let scaleY = 1;
            let width = 1;

            if (type === 'boss') {
                mat = hpBarFgMatBoss;
                scaleY = 2; 
                width = 3;
            }

            const fg = new THREE.Mesh(hpBarFgGeo, mat);
            fg.position.x = -0.5 * width; 
            fg.position.z = 0.01;
            
            bg.scale.set(width, scaleY, 1);
            fg.scale.set(width, scaleY, 1); 

            group.add(bg, fg);
            return group;
        }

        function spawnEnemy(isBoss = false) {
            if (gameState.isPaused) return;
            if (enemies.length >= MAX_ENEMIES && !isBoss) return; 

            const angle = Math.random() * Math.PI * 2;
            const distance = 15 + Math.random() * 10;
            const x = playerGroup.position.x + Math.cos(angle) * distance;
            const z = playerGroup.position.z + Math.sin(angle) * distance;
            
            let type = 'male';
            if (!isBoss) {
                const isRanged = Math.random() > 0.7;
                type = isRanged ? 'female' : 'male';
            } else {
                type = 'boss';
            }
            
            let enemyMesh;
            let mixer = null;

            if (type === 'boss') {
                const geo = new THREE.BoxGeometry(2, 4, 2);
                const mat = new THREE.MeshStandardMaterial({ color: 0xff4400 });
                enemyMesh = new THREE.Mesh(geo, mat);
                enemyMesh.position.y = 2;
            } else if (type === 'male') {
                if (loadedModels.maleEnemy) {
                    enemyMesh = SkeletonUtils.clone(loadedModels.maleEnemy.scene);
                    enemyMesh.scale.set(1, 1, 1);
                    const clips = loadedModels.maleEnemy.animations;
                    if(clips && clips.length > 0) { mixer = new THREE.AnimationMixer(enemyMesh); mixer.clipAction(clips[0]).play(); }
                } else {
                    const geo = new THREE.BoxGeometry(1, 1.5, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x3366ff });
                    enemyMesh = new THREE.Mesh(geo, mat);
                    enemyMesh.position.y = 0.75;
                }
            } else {
                if (loadedModels.femaleEnemy) {
                    enemyMesh = SkeletonUtils.clone(loadedModels.femaleEnemy.scene);
                    enemyMesh.scale.set(1, 1, 1);
                    const clips = loadedModels.femaleEnemy.animations;
                    if(clips && clips.length > 0) { mixer = new THREE.AnimationMixer(enemyMesh); mixer.clipAction(clips[0]).play(); }
                } else {
                    const geo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 12);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xff66cc });
                    enemyMesh = new THREE.Mesh(geo, mat);
                    enemyMesh.position.y = 0.75;
                }
            }
            
            enemyMesh.traverse(o => { if(o.isMesh) o.castShadow = true; });
            
            enemyMesh.position.set(x, isBoss ? 2 : 0, z);
            if (!loadedModels[type + 'Enemy'] && type !== 'boss') enemyMesh.position.y = 0.75;

            let hp = 15 + (gameState.time * 0.5);
            if (type === 'female') hp *= 0.7;
            if (type === 'boss') hp = hp * 50 + 500; 

            // 3D ì²´ë ¥ë°” ìƒì„± ë° ë¶€ì°©
            const hpBar = create3DHpBar(type);
            hpBar.position.y = isBoss ? 2.5 : 2.0;
            enemyMesh.add(hpBar);

            enemyMesh.userData = { 
                type: type, 
                hp: hp, 
                maxHp: hp, 
                speed: type === 'boss' ? 0.03 : (type === 'female' ? 0.04 : 0.05), 
                attackCooldown: 0, 
                mixer: mixer, 
                isBoss: isBoss 
            };
            scene.add(enemyMesh);
            enemies.push(enemyMesh);
        }

        function createDamageText(position, damage, isMincho = false, isDeathQuote = false) {
            const div = document.createElement('div');
            if (isDeathQuote) {
                div.className = 'damage-text death-quote';
                div.innerText = damage; 
            } else if (isMincho) {
                div.className = 'damage-text mincho-text';
                div.innerText = "ë¯¼ì´ˆ íšë“! (+1 í•„ì‚´ê¸°)";
            } else {
                div.className = 'damage-text';
                div.innerText = Math.floor(damage);
            }
            
            const vec = position.clone();
            if(isDeathQuote) vec.y += 2; 
            
            vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            div.style.left = `${x}px`; div.style.top = `${y}px`;
            
            document.getElementById('damage-layer').appendChild(div);
            setTimeout(() => div.remove(), isDeathQuote ? 2000 : 1000); 
        }

        function spawnGem(position, value) {
            const geo = new THREE.OctahedronGeometry(0.3);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa });
            const gem = new THREE.Mesh(geo, mat);
            gem.position.copy(position); gem.position.y = 0.5; gem.userData = { value: value };
            scene.add(gem); gems.push(gem);
        }

        function spawnMincho(position) {
            const group = new THREE.Group();
            const iceGeo = new THREE.SphereGeometry(0.4, 16, 16);
            const iceMat = new THREE.MeshStandardMaterial({ color: 0x00ffaa, roughness: 0.5 });
            const ice = new THREE.Mesh(iceGeo, iceMat);
            group.add(ice);
            const chipGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const chipMat = new THREE.MeshStandardMaterial({ color: 0x3e2723 });
            for(let i=0; i<5; i++) {
                const chip = new THREE.Mesh(chipGeo, chipMat);
                chip.position.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.35);
                group.add(chip);
            }
            group.position.copy(position); group.position.y = 0.5;
            const light = new THREE.PointLight(0x00ffaa, 1, 3);
            group.add(light);
            scene.add(group); minchos.push(group);
        }

        function getNearestEnemy() {
            let nearest = null; let minDist = Infinity;
            enemies.forEach(e => {
                const d = playerGroup.position.distanceTo(e.position);
                if (d < minDist) { minDist = d; nearest = e; }
            });
            return { enemy: nearest, dist: minDist };
        }

        function useBomb() {
            if (gameState.bombs <= 0) return;
            gameState.bombs--;
            updateBombUI();
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // HPë°” ì œê±° (3Dë¼ scene.remove(enemy) í•˜ë©´ ìë™ ì‚­ì œë˜ì§€ë§Œ ëª…ì‹œì ìœ¼ë¡œ ì°¸ì¡° ëŠê¸°)
                // enemy.userData.hpBar... ëŠ” childì´ë¯€ë¡œ í•¨ê»˜ ì‚­ì œë¨.
                
                spawnGem(enemy.position, 1);
                gameState.kills++;
                scene.remove(enemy);
                enemies.splice(i, 1);
            }
            document.getElementById('kill-count').innerText = gameState.kills;
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) { scene.remove(enemyProjectiles[i]); }
            enemyProjectiles.length = 0;
            const blastGeo = new THREE.SphereGeometry(1, 32, 32);
            const blastMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const blast = new THREE.Mesh(blastGeo, blastMat);
            blast.position.copy(playerGroup.position);
            scene.add(blast);
            let scale = 1;
            const expandInterval = setInterval(() => {
                scale += 2; blast.scale.set(scale, scale, scale); blast.material.opacity -= 0.05;
                if (blast.material.opacity <= 0) { clearInterval(expandInterval); scene.remove(blast); }
            }, 16);
        }

        function updateBombUI() { document.getElementById('bomb-val').innerText = gameState.bombs; }

        function fireWeapons(delta) {
            const atkSpeed = playerStats.attackSpeed;

            if (inventory.qrBeam.active) {
                inventory.qrBeam.lastShot += delta * atkSpeed; 
                if (inventory.qrBeam.lastShot >= inventory.qrBeam.cooldown) {
                    const info = getNearestEnemy();
                    if (info.enemy && info.dist < 15) { 
                        shootQR(info.enemy); 
                        
                        const chance = inventory.nftContract.throwChance;
                        if (Math.random() < chance) {
                            throwContract();
                        }

                        inventory.qrBeam.lastShot = 0; 
                    }
                }
            }

            if (inventory.mist.active) {
                mistMesh.material.opacity = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                mistMesh.scale.set(inventory.mist.range, inventory.mist.range, 1);
                inventory.mist.lastTick += delta * atkSpeed; 
                if (inventory.mist.lastTick >= inventory.mist.cooldown) {
                    enemies.forEach(e => {
                        if (playerGroup.position.distanceTo(e.position) <= inventory.mist.range) takeDamage(e, inventory.mist.damage * playerStats.damageMult);
                    });
                    inventory.mist.lastTick = 0;
                }
            } else { mistMesh.material.opacity = 0; }
        }

        function shootQR(target) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const beam = new THREE.Mesh(geo, mat);
            beam.position.copy(playerGroup.position); beam.position.y = 1;
            beam.lookAt(target.position.x, 1, target.position.z);
            const dir = new THREE.Vector3(target.position.x - playerGroup.position.x, 0, target.position.z - playerGroup.position.z).normalize();
            beam.userData = { velocity: dir.multiplyScalar(0.4), damage: inventory.qrBeam.damage * playerStats.damageMult, duration: 2, hitList: [] };
            scene.add(beam); projectiles.push(beam);
        }

        function throwContract() {
            const geo = new THREE.BoxGeometry(0.8, 0.1, 0.5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const paper = new THREE.Mesh(geo, mat);
            paper.position.copy(playerGroup.position); paper.position.y = 1;
            const angle = Math.random() * Math.PI * 2;
            const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).normalize();
            
            paper.userData = { 
                type: 'contract', 
                velocity: dir.multiplyScalar(0.3), 
                bossDmgRate: inventory.nftContract.bossDmgRate,
                duration: 3, 
                pierce: 5, 
                hitList: [] 
            };
            scene.add(paper); projectiles.push(paper);
        }

        function enemyShootHeart(enemy) {
            const geo = new THREE.SphereGeometry(0.4, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0x550000 });
            const heart = new THREE.Mesh(geo, mat);
            heart.position.copy(enemy.position); heart.position.y = 1;
            const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position).normalize();
            heart.userData = { velocity: dir.multiplyScalar(0.15), damage: 10, duration: 4 };
            scene.add(heart); enemyProjectiles.push(heart);
        }

        function takeDamage(enemy, amount) {
            enemy.userData.hp -= amount;
            createDamageText(enemy.position, amount);
            enemy.traverse(child => { if(child.isMesh) {
                child.material.emissive.setHex(0xff0000);
                setTimeout(() => child.material.emissive.setHex(0x000000), 100);
            }});

            if (enemy.userData.hp <= 0) {
                if (Math.random() * 100 < gameState.quoteChance) {
                    const quotes = deathQuotes[enemy.userData.type];
                    if (quotes) {
                        const quote = quotes[Math.floor(Math.random() * quotes.length)];
                        createDamageText(enemy.position, quote, false, true); 
                    }
                }

                spawnGem(enemy.position, enemy.userData.isBoss ? 50 : 1); 
                
                if (Math.random() < 0.01) spawnMincho(enemy.position);

                gameState.kills++;
                document.getElementById('kill-count').innerText = gameState.kills;
                scene.remove(enemy);
                const idx = enemies.indexOf(enemy);
                if (idx > -1) enemies.splice(idx, 1);
            }
        }

        function damagePlayer(amount) {
            gameState.hp = Math.max(0, gameState.hp - amount);
            document.getElementById('hp-val').innerText = Math.floor(gameState.hp);
            if(playerGroup.children[0]) {
                const mesh = playerGroup.children[0];
                mesh.traverse(o => {
                    if(o.isMesh) {
                        const oldColor = o.material.color.getHex();
                        o.material.color.setHex(0xff0000);
                        setTimeout(() => o.material.color.setHex(oldColor), 100);
                    }
                });
            }
            if (gameState.hp <= 0) gameOver();
        }

        function checkLevelUp() {
            if (gameState.exp >= gameState.maxExp) {
                gameState.exp -= gameState.maxExp;
                gameState.level++;
                gameState.maxExp = Math.floor(gameState.maxExp * 1.5);
                document.getElementById('level-val').innerText = gameState.level;
                showLevelUpModal();
            }
            document.getElementById('exp-bar').style.width = `${(gameState.exp / gameState.maxExp) * 100}%`;
        }

        function showLevelUpModal() {
            gameState.isPaused = true;
            const modal = document.getElementById('levelup-modal');
            const container = document.getElementById('upgrade-cards');
            container.innerHTML = '';
            modal.style.display = 'flex';

            const options = [
                { key: 'qrBeam', title: 'QRì½”ë“œ ë¹”', desc: 'ê¸°ë³¸ ê³µê²© ì†ë„/ë°ë¯¸ì§€ ì¦ê°€', icon: 'ğŸ“±' },
                { key: 'nftContract', title: 'NFT ê³„ì•½ì„œ', desc: 'ë˜ì§ˆ í™•ë¥ /ë³´ìŠ¤ ë°ë¯¸ì§€ ì¦ê°€', icon: 'ğŸ“„' },
                { key: 'mist', title: 'íƒ€ì§€ë¦¬ ë¯¸ìŠ¤íŠ¸', desc: 'ì£¼ë³€ ì§€ì† ë°ë¯¸ì§€ ì˜¤ë¼', icon: 'â˜ ï¸' },
                { key: 'chunjat', title: 'ì¶˜ì£', desc: 'ì´ë™ ì†ë„ 5% ì¦ê°€', icon: 'ğŸŒ°' },
                { key: 'movingMan', title: 'ë¬´ë¹™ë§¨', desc: 'ê³µê²© ì†ë„ 10% ì¦ê°€', icon: 'ğŸƒ' },
                { key: 'clover', title: 'í–‰ìš´ì˜ í´ë¡œë²„', desc: 'ê³µê²©ë ¥ 20% ì¦ê°€', icon: 'ğŸ€' }
            ];
            options.sort(() => Math.random() - 0.5);
            
            options.slice(0, 3).forEach(opt => {
                const item = inventory[opt.key];
                let btnText = item.level === 0 ? "ì‹ ê·œ ìŠµë“" : `Lv.${item.level} -> Lv.${item.level+1}`;
                if (item.type === 'passive') btnText = "ê°•í™”";
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `<div class="card-icon">${opt.icon}</div><div class="card-name">${opt.title}</div><div class="card-desc">${opt.desc}</div><div class="card-level">${btnText}</div>`;
                card.onclick = () => { applyUpgrade(opt.key); modal.style.display = 'none'; gameState.isPaused = false; };
                container.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            const item = inventory[key];
            item.active = true; item.level++;
            if (key === 'qrBeam') { item.damage += 5; item.cooldown *= 0.9; }
            else if (key === 'nftContract') { 
                item.throwChance = Math.min(0.05, 0.01 * (item.level + 1)); 
                item.bossDmgRate = Math.min(0.25, 0.10 + (item.level * 0.03)); 
            }
            else if (key === 'mist') { item.damage += 2; item.range += 0.5; }
            else if (key === 'chunjat') { playerStats.moveSpeed += item.val; }
            else if (key === 'movingMan') { playerStats.attackSpeed += item.val; } 
            else if (key === 'clover') { playerStats.damageMult += item.val; }
        }

        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('final-time').innerText = document.getElementById('timer').innerText;
            document.getElementById('final-kills').innerText = gameState.kills;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        // ==========================================
        // 6. ë©”ì¸ ë£¨í”„
        // ==========================================
        const clock = new THREE.Clock();
        
        setInterval(() => {
            // â˜… ê²Œì„ ì‹œì‘ ì „ì—” íƒ€ì´ë¨¸/ìŠ¤í° ë©ˆì¶¤ â˜…
            if (!gameState.gameStarted) return; 
            if (!gameState.isPlaying || gameState.isPaused) return;
            // ì  ìƒì„± ë¬¼ëŸ‰ ëŒ€í­ ì¦ê°€
            const spawnCount = 2 + Math.floor(gameState.time / 20); 
            for(let i=0; i<spawnCount; i++) spawnEnemy();
            
            // 60ì´ˆë§ˆë‹¤ ë³´ìŠ¤(ë¶€ì¥ë‹˜) ë“±ì¥
            if (gameState.time > 0 && gameState.time % 60 === 0) {
                spawnEnemy(true);
            }

            gameState.time++;

            if (gameState.time % 10 === 0) {
                gameState.quoteChance = Math.min(20, gameState.quoteChance + 1);
            }

            const m = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const s = (gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // â˜… 1. ê²Œì„ ì‹œì‘ ì „: ì‡¼ì¼€ì´ìŠ¤ (ë©€í‹° ì¹´ë©”ë¼ ë·°) â˜…
            if (!gameState.gameStarted) {
                // í”Œë ˆì´ì–´ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
                if (playerMixer) playerMixer.update(delta);
                // í”Œë ˆì´ì–´ ì‚´ì§ íšŒì „
                playerGroup.rotation.y += delta * 0.5;

                // ì¹´ë©”ë¼ ìë™ ì „í™˜ (3ì´ˆë§ˆë‹¤)
                gameState.cameraTimer += delta;
                if (gameState.cameraTimer >= 3.0) {
                    gameState.cameraTimer = 0;
                    document.getElementById(`cam-label-${gameState.cameraIndex}`).classList.remove('cam-active');
                    gameState.cameraIndex = (gameState.cameraIndex + 1) % 3;
                    document.getElementById(`cam-label-${gameState.cameraIndex}`).classList.add('cam-active');
                }

                // ë‹¨ì¼ ë·°í¬íŠ¸ ë Œë”ë§
                const cams = [startCam1, startCam2, startCam3];
                renderer.render(scene, cams[gameState.cameraIndex]);
                return; // ê²Œì„ ë¡œì§ ê±´ë„ˆëœ€
            }

            // â˜… 2. ê²Œì„ ì‹œì‘ í›„: ì •ìƒ ê²Œì„ ë£¨í”„ â˜…
            if (!gameState.isPlaying || gameState.isPaused) return;

            if (keys[' ']) {
                useBomb();
                keys[' '] = false;
            }

            gameState.bombTimer += delta;
            if (gameState.bombTimer >= BOMB_COOLDOWN_TIME) {
                gameState.bombs++;
                gameState.bombTimer = 0;
                updateBombUI();
            }
            const bombPct = Math.min(100, Math.floor((gameState.bombTimer / BOMB_COOLDOWN_TIME) * 100));
            document.getElementById('bomb-cooldown').innerText = `(${bombPct}%)`;

            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys.w || keys.ArrowUp) moveDir.z -= 1;
            if (keys.s || keys.ArrowDown) moveDir.z += 1;
            if (keys.a || keys.ArrowLeft) moveDir.x -= 1;
            if (keys.d || keys.ArrowRight) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(playerStats.moveSpeed);
                playerGroup.position.add(moveDir);
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                if(playerMixer) playerGroup.children.forEach(c => { if(c.isGroup) c.rotation.y = targetRot; });
            }

            camera.position.x = playerGroup.position.x + 20;
            camera.position.z = playerGroup.position.z + 20;
            dirLight.position.x = playerGroup.position.x + 10;
            dirLight.position.z = playerGroup.position.z + 10;
            ground.position.x = playerGroup.position.x;
            ground.position.z = playerGroup.position.z;

            fireWeapons(delta);
            if (playerMixer) playerMixer.update(delta);

            update3DHpBar(playerHpBarGroup, gameState.hp, gameState.maxHp); 

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.velocity);
                if (p.userData.type === 'contract') p.rotation.y += 0.2;
                p.userData.duration -= delta;
                if (p.userData.duration <= 0) { scene.remove(p); projectiles.splice(i, 1); continue; }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    // â˜… 2D ê±°ë¦¬ ì²´í¬ë¡œ ë³€ê²½ (Yì¶• ë¬´ì‹œ) â˜…
                    const dx = p.position.x - enemy.position.x;
                    const dz = p.position.z - enemy.position.z;
                    const distSq = dx*dx + dz*dz;
                    
                    if (distSq < 2.25) {
                        if (p.userData.hitList && p.userData.hitList.includes(enemy.id)) continue;
                        
                        let damage = p.userData.damage;
                        if (p.userData.type === 'contract') {
                            if (enemy.userData.isBoss) {
                                damage = enemy.userData.maxHp * p.userData.bossDmgRate;
                            } else {
                                damage = enemy.userData.hp;
                            }
                        }

                        takeDamage(enemy, damage);
                        if (p.userData.hitList) p.userData.hitList.push(enemy.id);
                        
                        if (p.userData.type !== 'contract') { scene.remove(p); projectiles.splice(i, 1); break; }
                        else if (p.userData.hitList.length >= p.userData.pierce) { scene.remove(p); projectiles.splice(i, 1); break; }
                    }
                }
            }

            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const ep = enemyProjectiles[i];
                ep.position.add(ep.userData.velocity);
                ep.userData.duration -= delta;
                
                // â˜… ì  íˆ¬ì‚¬ì²´ë„ í”Œë ˆì´ì–´ì™€ 2D ê±°ë¦¬ ì²´í¬ â˜…
                const dx = ep.position.x - playerGroup.position.x;
                const dz = ep.position.z - playerGroup.position.z;
                const distSq = dx*dx + dz*dz;
                
                if (distSq < 1.0) { // í”Œë ˆì´ì–´ íˆíŠ¸ë°•ìŠ¤ ë°˜ê²½ 1.0
                    damagePlayer(ep.userData.damage);
                    scene.remove(ep);
                    enemyProjectiles.splice(i, 1);
                    continue;
                }
                if (ep.userData.duration <= 0) { scene.remove(ep); enemyProjectiles.splice(i, 1); }
            }

            enemies.forEach(enemy => {
                update3DHpBar(enemy, enemy.userData.hp, enemy.userData.maxHp);

                if (enemy.userData.mixer) enemy.userData.mixer.update(delta);
                const distToPlayer = enemy.position.distanceTo(playerGroup.position);
                const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position).normalize();

                if (enemy.userData.type === 'male' || enemy.userData.type === 'boss') {
                    enemy.position.add(dir.multiplyScalar(enemy.userData.speed));
                    if (distToPlayer < (enemy.userData.isBoss ? 2.5 : 0.8)) damagePlayer(enemy.userData.isBoss ? 5 : 0.5);
                } else {
                    if (distToPlayer > 8) enemy.position.add(dir.multiplyScalar(enemy.userData.speed));
                    enemy.userData.attackCooldown -= delta;
                    if (enemy.userData.attackCooldown <= 0 && distToPlayer < 12) {
                        enemyShootHeart(enemy);
                        enemy.userData.attackCooldown = 2.0;
                    }
                }
                enemy.lookAt(playerGroup.position);
            });

            for (let i = gems.length - 1; i >= 0; i--) {
                const gem = gems[i];
                const dist = playerGroup.position.distanceTo(gem.position);
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(playerGroup.position, gem.position).normalize();
                    gem.position.add(dir.multiplyScalar(0.3));
                    if (dist < 0.5) { gameState.exp += gem.userData.value; scene.remove(gem); gems.splice(i, 1); checkLevelUp(); }
                } else { gem.rotation.y += 0.05; }
            }

            for (let i = minchos.length - 1; i >= 0; i--) {
                const m = minchos[i];
                const dist = playerGroup.position.distanceTo(m.position);
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(playerGroup.position, m.position).normalize();
                    m.position.add(dir.multiplyScalar(0.3));
                    if (dist < 0.5) { 
                        gameState.bombs++;
                        updateBombUI();
                        createDamageText(playerGroup.position, 0, true); 
                        scene.remove(m); minchos.splice(i, 1); 
                    }
                } else { m.rotation.y += 0.05; }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 40;
            
            // ë©”ì¸ ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
            camera.left = -viewSize * aspect; camera.right = viewSize * aspect;
            camera.top = viewSize; camera.bottom = -viewSize;
            camera.updateProjectionMatrix();

            // ì‹œì‘ í™”ë©´ ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
            startCam1.aspect = window.innerWidth / window.innerHeight; startCam1.updateProjectionMatrix();
            startCam2.aspect = window.innerWidth / window.innerHeight; startCam2.updateProjectionMatrix();
            startCam3.aspect = window.innerWidth / window.innerHeight; startCam3.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>