<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ÌïúÌÉïÏù¥Ïùò ÏÉùÏ°¥ Ïã†Í≥† (Vampire Survivors Style)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #101020; font-family: 'Black Han Sans', sans-serif; user-select: none; }
        
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Gowun+Batang&display=swap');

        /* UI Î†àÏù¥ÏïÑÏõÉ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* ÏÉÅÎã® Ï†ïÎ≥¥Î∞î */
        #top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; align-items: center;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 15px;
            color: #fff; border: 2px solid #555; font-size: 20px; text-shadow: 1px 1px 2px black;
        }
        #score { color: #ffd700; }
        #timer { color: #fff; min-width: 60px; text-align: center; }
        #hp-box { color: #ff5555; border-color: #ff5555; }

        /* Í≤ΩÌóòÏπò Î∞î */
        #exp-bar-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10;
        }
        #exp-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); transition: width 0.2s;
        }
        #level-indicator {
            position: absolute; top: 15px; right: 20px; color: #00f2fe; font-size: 30px; text-shadow: 2px 2px 0 #000;
        }

        /* Î†àÎ≤®ÏóÖ ÏÑ†ÌÉùÏ∞Ω */
        #levelup-modal {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
            pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .modal-title { font-size: 50px; color: #ffd700; margin-bottom: 30px; text-shadow: 0 0 10px orange; animation: float 2s infinite; }
        .card-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card {
            width: 200px; height: 280px; background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #666; border-radius: 10px; padding: 15px;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .upgrade-card:hover { transform: translateY(-10px); border-color: #fff; background: #333; }
        .card-icon { font-size: 50px; margin-bottom: 10px; }
        .card-name { font-size: 24px; color: #fff; margin-bottom: 10px; color: #00ff00; }
        .card-desc { font-size: 16px; color: #ccc; font-family: 'Gowun Batang', serif; line-height: 1.4; }
        .card-level { margin-top: auto; font-size: 14px; color: #888; }

        /* Í≤åÏûÑÏò§Î≤Ñ */
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.8); z-index: 200; pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        .go-title { font-size: 80px; color: #ff0055; margin-bottom: 20px; }
        .go-score { font-size: 30px; margin-bottom: 40px; }
        button {
            padding: 15px 40px; font-size: 24px; background: #fff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-family: 'Black Han Sans';
        }
        button:hover { background: #ddd; }

        @keyframes float { 0% { transform: translateY(0); } 50% { transform: translateY(-10px); } 100% { transform: translateY(0); } }

        /* Îç∞ÎØ∏ÏßÄ ÌÖçÏä§Ìä∏ */
        .damage-text {
            position: absolute; color: white; font-weight: bold; font-size: 20px;
            pointer-events: none; text-shadow: 1px 1px 0 #000;
            animation: popUp 0.8s forwards;
        }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-30px) scale(0.5); } }
    </style>
</head>
<body>
    <!-- 3D Ï∫îÎ≤ÑÏä§ -->
    <div id="canvas-container"></div>

    <!-- UI Î†àÏù¥Ïñ¥ -->
    <div id="exp-bar-container"><div id="exp-bar"></div></div>
    
    <div id="ui-layer">
        <div id="level-indicator">LV. <span id="level-val">1</span></div>
        
        <div id="top-bar">
            <div class="stat-box" id="hp-box">HP <span id="hp-val">100</span></div>
            <div class="stat-box">TIME <span id="timer">00:00</span></div>
            <div class="stat-box">KILL <span id="kill-count">0</span></div>
        </div>

        <div id="damage-layer"></div>
    </div>

    <!-- Î†àÎ≤®ÏóÖ Î™®Îã¨ -->
    <div id="levelup-modal">
        <div class="modal-title">Î†àÎ≤® ÏóÖ!</div>
        <div class="card-container" id="upgrade-cards"></div>
    </div>

    <!-- Í≤åÏûÑ Ïò§Î≤Ñ ÌôîÎ©¥ -->
    <div id="game-over-screen">
        <div class="go-title">ÏÇ¨ Îßù</div>
        <div class="go-score">ÏµúÏ¢Ö Í∏∞Î°ù: <span id="final-time">00:00</span> / Ï≤òÏπò: <span id="final-kills">0</span></div>
        <button onclick="location.reload()">Îã§Ïãú ÎèÑÏ†ÑÌïòÍ∏∞</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // ==========================================
        // 1. Í≤åÏûÑ ÏÑ§Ï†ï Î∞è Ï¥àÍ∏∞Ìôî
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e); 
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 60);

        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -40, window.innerWidth / 40,
            window.innerHeight / 40, window.innerHeight / -40,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);
        camera.zoom = 1.2;
        camera.updateProjectionMatrix();

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(200, 100, 0x444444, 0x333333));

        // ==========================================
        // 2. Î™®Îç∏ Î°úÎî© (ÌîåÎ†àÏù¥Ïñ¥ Î∞è Ï†Å)
        // ==========================================
        const loader = new GLTFLoader();
        const loadedModels = { player: null, maleEnemy: null, femaleEnemy: null };

        // ÌîåÎ†àÏù¥Ïñ¥
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        const pGeo = new THREE.BoxGeometry(1, 1, 1);
        const pMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const playerFallback = new THREE.Mesh(pGeo, pMat);
        playerFallback.position.y = 0.5;
        playerFallback.castShadow = true;
        playerGroup.add(playerFallback);

        let playerMixer;
        loader.load('./player.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(1, 1, 1);
            model.traverse(o => { if(o.isMesh) o.castShadow = true; });
            playerGroup.remove(playerFallback);
            playerGroup.add(model);
            playerMixer = new THREE.AnimationMixer(model);
            if(gltf.animations.length > 0) playerMixer.clipAction(gltf.animations[0]).play();
        }, undefined, () => console.log('Player model not found. Using box.'));

        // ‚òÖ Ï†Å Î™®Îç∏ ÎØ∏Î¶¨ Î°úÎìú (ÌååÏùºÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Ìè¥Î∞±) ‚òÖ
        loader.load('./male_enemy.glb', (gltf) => { loadedModels.maleEnemy = gltf; }, undefined, () => {});
        loader.load('./female_enemy.glb', (gltf) => { loadedModels.femaleEnemy = gltf; }, undefined, () => {});

        // ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏ ÏãúÍ∞ÅÌö®Í≥º
        const mistGeo = new THREE.RingGeometry(0.5, 4, 32);
        const mistMat = new THREE.MeshBasicMaterial({ color: 0x800080, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
        const mistMesh = new THREE.Mesh(mistGeo, mistMat);
        mistMesh.rotation.x = -Math.PI / 2;
        mistMesh.position.y = 0.1;
        playerGroup.add(mistMesh);

        // ==========================================
        // 3. Í≤åÏûÑ ÏÉÅÌÉú Î∞è Î≥ÄÏàò
        // ==========================================
        const gameState = {
            isPlaying: true, isPaused: false, time: 0,
            level: 1, exp: 0, maxExp: 10, kills: 0,
            hp: 100, maxHp: 100
        };

        const playerStats = {
            moveSpeed: 0.15, damageMult: 1.0, pickupRange: 3.0, luck: 1.0
        };

        const inventory = {
            qrBeam: { level: 1, active: true, name: "QRÏΩîÎìú Îπî", type: "weapon", cooldown: 0.8, lastShot: 0, damage: 10 },
            contract: { level: 0, active: false, name: "Í≥ÑÏïΩÏÑú ÎçòÏßÄÍ∏∞", type: "weapon", cooldown: 2.5, lastShot: 0, damage: 30, pierce: 2 },
            mist: { level: 0, active: false, name: "ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏", type: "weapon", cooldown: 0.5, lastTick: 0, damage: 3, range: 4 },
            chunjat: { level: 0, active: false, name: "Ï∂òÏû£", type: "passive", effect: "speed", val: 0.05 },
            clover: { level: 0, active: false, name: "ÌñâÏö¥Ïùò ÌÅ¥Î°úÎ≤Ñ", type: "passive", effect: "might", val: 0.2 }
        };

        const enemies = [];
        const projectiles = [];
        const enemyProjectiles = []; // Ï†Å Ìà¨ÏÇ¨Ï≤¥
        const gems = [];
        const keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowLeft:false, ArrowDown:false, ArrowRight:false };

        // ==========================================
        // 4. Í≤åÏûÑ Î°úÏßÅ
        // ==========================================
        window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = true; });
        window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = false; });

        // ‚òÖ Ï†Å ÏÉùÏÑ± Î°úÏßÅ (ÎÇ®ÏÑ±Ìòï/Ïó¨ÏÑ±Ìòï Î∂ÑÍ∏∞) ‚òÖ
        function spawnEnemy() {
            if (gameState.isPaused) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = 15 + Math.random() * 10;
            const x = playerGroup.position.x + Math.cos(angle) * distance;
            const z = playerGroup.position.z + Math.sin(angle) * distance;

            // 70% ÌôïÎ•†Î°ú ÎÇ®ÏÑ±Ìòï(Í∑ºÍ±∞Î¶¨), 30% ÌôïÎ•†Î°ú Ïó¨ÏÑ±Ìòï(ÏõêÍ±∞Î¶¨)
            const isRanged = Math.random() > 0.7;
            const type = isRanged ? 'female' : 'male';
            
            let enemyMesh;
            let mixer = null;

            if (type === 'male') {
                // ÎÇ®ÏÑ±Ìòï (Í∑ºÍ±∞Î¶¨)
                if (loadedModels.maleEnemy) {
                    // GLB Î°úÎìú ÏÑ±Í≥µ Ïãú
                    enemyMesh = SkeletonUtils.clone(loadedModels.maleEnemy.scene);
                    enemyMesh.scale.set(1, 1, 1);
                    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÎØπÏÑú ÏÉùÏÑ± ÌïÑÏöî Ïãú Ï∂îÍ∞Ä
                    const clips = loadedModels.maleEnemy.animations;
                    if(clips && clips.length > 0) {
                        mixer = new THREE.AnimationMixer(enemyMesh);
                        mixer.clipAction(clips[0]).play(); // Í±∑Í∏∞ Î™®ÏÖò Í∞ÄÏ†ï
                    }
                } else {
                    // Ìè¥Î∞±: ÌååÎûÄÏÉâ Î∞ïÏä§
                    const geo = new THREE.BoxGeometry(1, 1.5, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x3366ff });
                    enemyMesh = new THREE.Mesh(geo, mat);
                    enemyMesh.position.y = 0.75;
                }
            } else {
                // Ïó¨ÏÑ±Ìòï (ÏõêÍ±∞Î¶¨)
                if (loadedModels.femaleEnemy) {
                    // GLB Î°úÎìú ÏÑ±Í≥µ Ïãú
                    enemyMesh = SkeletonUtils.clone(loadedModels.femaleEnemy.scene);
                    enemyMesh.scale.set(1, 1, 1);
                    const clips = loadedModels.femaleEnemy.animations;
                    if(clips && clips.length > 0) {
                        mixer = new THREE.AnimationMixer(enemyMesh);
                        mixer.clipAction(clips[0]).play();
                    }
                } else {
                    // Ìè¥Î∞±: Î∂ÑÌôçÏÉâ Ïã§Î¶∞Îçî
                    const geo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 12);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xff66cc });
                    enemyMesh = new THREE.Mesh(geo, mat);
                    enemyMesh.position.y = 0.75;
                }
            }

            // Í∑∏Î¶ºÏûê ÏÑ§Ï†ï
            enemyMesh.traverse(o => { if(o.isMesh) o.castShadow = true; });

            enemyMesh.position.set(x, 0, z); // Î™®Îç∏ ÏõêÏ†êÏóê Îî∞Îùº yÏ°∞Ï†ï ÌïÑÏöîÌï† Ïàò ÏûàÏùå
            if (!loadedModels[type + 'Enemy']) enemyMesh.position.y = 0.75; // Ìè¥Î∞± ÎèÑÌòïÏùº ÎïåÎßå

            let hp = 15 + (gameState.time * 0.5);
            if (isRanged) hp *= 0.7; // ÏõêÍ±∞Î¶¨Îäî Ï≤¥Î†•Ïù¥ Ï¢Ä Ï†ÅÏùå

            enemyMesh.userData = { 
                type: type, // 'male' or 'female'
                hp: hp, 
                maxHp: hp, 
                speed: isRanged ? 0.04 : 0.05,
                attackCooldown: 0,
                mixer: mixer
            };
            
            scene.add(enemyMesh);
            enemies.push(enemyMesh);
        }

        function createDamageText(position, damage) {
            const div = document.createElement('div');
            div.className = 'damage-text';
            div.innerText = Math.floor(damage);
            const vec = position.clone().project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            div.style.left = `${x}px`; div.style.top = `${y}px`;
            document.getElementById('damage-layer').appendChild(div);
            setTimeout(() => div.remove(), 800);
        }

        function spawnGem(position, value) {
            const geo = new THREE.OctahedronGeometry(0.3);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa });
            const gem = new THREE.Mesh(geo, mat);
            gem.position.copy(position); gem.position.y = 0.5; gem.userData = { value: value };
            scene.add(gem); gems.push(gem);
        }

        function getNearestEnemy() {
            let nearest = null; let minDist = Infinity;
            enemies.forEach(e => {
                const d = playerGroup.position.distanceTo(e.position);
                if (d < minDist) { minDist = d; nearest = e; }
            });
            return { enemy: nearest, dist: minDist };
        }

        // --- ÌîåÎ†àÏù¥Ïñ¥ Î¨¥Í∏∞ Î∞úÏÇ¨ ---
        function fireWeapons(delta) {
            if (inventory.qrBeam.active) {
                inventory.qrBeam.lastShot += delta;
                if (inventory.qrBeam.lastShot >= inventory.qrBeam.cooldown) {
                    const info = getNearestEnemy();
                    if (info.enemy && info.dist < 15) { shootQR(info.enemy); inventory.qrBeam.lastShot = 0; }
                }
            }
            if (inventory.contract.active) {
                inventory.contract.lastShot += delta;
                if (inventory.contract.lastShot >= inventory.contract.cooldown) { throwContract(); inventory.contract.lastShot = 0; }
            }
            if (inventory.mist.active) {
                mistMesh.material.opacity = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                mistMesh.scale.set(inventory.mist.range, inventory.mist.range, 1);
                inventory.mist.lastTick += delta;
                if (inventory.mist.lastTick >= inventory.mist.cooldown) {
                    enemies.forEach(e => {
                        if (playerGroup.position.distanceTo(e.position) <= inventory.mist.range) takeDamage(e, inventory.mist.damage * playerStats.damageMult);
                    });
                    inventory.mist.lastTick = 0;
                }
            } else { mistMesh.material.opacity = 0; }
        }

        function shootQR(target) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const beam = new THREE.Mesh(geo, mat);
            beam.position.copy(playerGroup.position); beam.position.y = 1;
            beam.lookAt(target.position.x, 1, target.position.z);
            const dir = new THREE.Vector3(target.position.x - playerGroup.position.x, 0, target.position.z - playerGroup.position.z).normalize();
            beam.userData = { velocity: dir.multiplyScalar(0.4), damage: inventory.qrBeam.damage * playerStats.damageMult, duration: 2, hitList: [] };
            scene.add(beam); projectiles.push(beam);
        }

        function throwContract() {
            const geo = new THREE.BoxGeometry(0.8, 0.1, 0.5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const paper = new THREE.Mesh(geo, mat);
            paper.position.copy(playerGroup.position); paper.position.y = 1;
            const angle = Math.random() * Math.PI * 2;
            const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).normalize();
            paper.userData = { type: 'contract', velocity: dir.multiplyScalar(0.3), damage: inventory.contract.damage * playerStats.damageMult, duration: 3, pierce: inventory.contract.pierce, hitList: [] };
            scene.add(paper); projectiles.push(paper);
        }

        // --- Ï†Å Ìà¨ÏÇ¨Ï≤¥ (ÌïòÌä∏) Î∞úÏÇ¨ ---
        function enemyShootHeart(enemy) {
            // Îπ®Í∞Ñ ÌïòÌä∏(Íµ¨Ï≤¥)
            const geo = new THREE.SphereGeometry(0.4, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0x550000 });
            const heart = new THREE.Mesh(geo, mat);
            
            heart.position.copy(enemy.position);
            heart.position.y = 1;

            // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•
            const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position).normalize();
            
            heart.userData = {
                velocity: dir.multiplyScalar(0.15), // ÌÉÑÏÜç
                damage: 10,
                duration: 4
            };
            
            scene.add(heart);
            enemyProjectiles.push(heart);
        }

        function takeDamage(enemy, amount) {
            enemy.userData.hp -= amount;
            createDamageText(enemy.position, amount);
            enemy.traverse(child => { if(child.isMesh) {
                child.material.emissive.setHex(0xff0000);
                setTimeout(() => child.material.emissive.setHex(0x000000), 100);
            }});

            if (enemy.userData.hp <= 0) {
                spawnGem(enemy.position, 1);
                gameState.kills++;
                document.getElementById('kill-count').innerText = gameState.kills;
                scene.remove(enemy);
                const idx = enemies.indexOf(enemy);
                if (idx > -1) enemies.splice(idx, 1);
            }
        }

        function damagePlayer(amount) {
            gameState.hp = Math.max(0, gameState.hp - amount);
            document.getElementById('hp-val').innerText = Math.floor(gameState.hp);
            
            // ÌîåÎ†àÏù¥Ïñ¥ ÌîºÍ≤© Ìö®Í≥º (Îπ®Í∞ÑÏÉâ ÍπúÎπ°)
            if(playerGroup.children[0]) {
                const mesh = playerGroup.children[0]; // Î™®Îç∏ ÎòêÎäî Î∞ïÏä§
                mesh.traverse(o => {
                    if(o.isMesh) {
                        const oldColor = o.material.color.getHex();
                        o.material.color.setHex(0xff0000);
                        setTimeout(() => o.material.color.setHex(oldColor), 100);
                    }
                });
            }

            if (gameState.hp <= 0) gameOver();
        }

        // --- Î†àÎ≤®ÏóÖ ÏãúÏä§ÌÖú ---
        function checkLevelUp() {
            if (gameState.exp >= gameState.maxExp) {
                gameState.exp -= gameState.maxExp;
                gameState.level++;
                gameState.maxExp = Math.floor(gameState.maxExp * 1.5);
                document.getElementById('level-val').innerText = gameState.level;
                showLevelUpModal();
            }
            document.getElementById('exp-bar').style.width = `${(gameState.exp / gameState.maxExp) * 100}%`;
        }

        function showLevelUpModal() {
            gameState.isPaused = true;
            const modal = document.getElementById('levelup-modal');
            const container = document.getElementById('upgrade-cards');
            container.innerHTML = '';
            modal.style.display = 'flex';

            const options = [
                { key: 'qrBeam', title: 'QRÏΩîÎìú Îπî', desc: 'Í∏∞Î≥∏ Í≥µÍ≤© ÏÜçÎèÑ/Îç∞ÎØ∏ÏßÄ Ï¶ùÍ∞Ä', icon: 'üì±' },
                { key: 'contract', title: 'Í≥ÑÏïΩÏÑú ÎçòÏßÄÍ∏∞', desc: 'Í¥ÄÌÜµÌòï Ìà¨ÏÇ¨Ï≤¥ (Lv UP: Îç∞ÎØ∏ÏßÄ/Í¥ÄÌÜµ)', icon: 'üìÑ' },
                { key: 'mist', title: 'ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏', desc: 'Ï£ºÎ≥Ä ÏßÄÏÜç Îç∞ÎØ∏ÏßÄ Ïò§Îùº', icon: '‚ò†Ô∏è' },
                { key: 'chunjat', title: 'Ï∂òÏû£', desc: 'Ïù¥Îèô ÏÜçÎèÑ 10% Ï¶ùÍ∞Ä', icon: 'üå∞' },
                { key: 'clover', title: 'ÌñâÏö¥Ïùò ÌÅ¥Î°úÎ≤Ñ', desc: 'Í≥µÍ≤©Î†• 20% Ï¶ùÍ∞Ä', icon: 'üçÄ' }
            ];
            options.sort(() => Math.random() - 0.5);
            
            options.slice(0, 3).forEach(opt => {
                const item = inventory[opt.key];
                let btnText = item.level === 0 ? "Ïã†Í∑ú ÏäµÎìù" : `Lv.${item.level} -> Lv.${item.level+1}`;
                if (item.type === 'passive') btnText = "Í∞ïÌôî";
                
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `<div class="card-icon">${opt.icon}</div><div class="card-name">${opt.title}</div><div class="card-desc">${opt.desc}</div><div class="card-level">${btnText}</div>`;
                card.onclick = () => { applyUpgrade(opt.key); modal.style.display = 'none'; gameState.isPaused = false; };
                container.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            const item = inventory[key];
            item.active = true; item.level++;
            if (key === 'qrBeam') { item.damage += 5; item.cooldown *= 0.9; }
            else if (key === 'contract') { item.damage += 10; item.pierce += 1; item.cooldown *= 0.9; }
            else if (key === 'mist') { item.damage += 2; item.range += 0.5; }
            else if (key === 'chunjat') { playerStats.moveSpeed += item.val; }
            else if (key === 'clover') { playerStats.damageMult += item.val; }
        }

        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('final-time').innerText = document.getElementById('timer').innerText;
            document.getElementById('final-kills').innerText = gameState.kills;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        // ==========================================
        // 6. Î©îÏù∏ Î£®ÌîÑ
        // ==========================================
        const clock = new THREE.Clock();
        
        setInterval(() => {
            if (!gameState.isPlaying || gameState.isPaused) return;
            const spawnCount = 1 + Math.floor(gameState.time / 30);
            for(let i=0; i<spawnCount; i++) spawnEnemy();
            gameState.time++;
            const m = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const s = (gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            if (!gameState.isPlaying || gameState.isPaused) return;

            const delta = clock.getDelta();

            // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys.w || keys.ArrowUp) moveDir.z -= 1;
            if (keys.s || keys.ArrowDown) moveDir.z += 1;
            if (keys.a || keys.ArrowLeft) moveDir.x -= 1;
            if (keys.d || keys.ArrowRight) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(playerStats.moveSpeed);
                playerGroup.position.add(moveDir);
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                if(playerMixer) playerGroup.children.forEach(c => { if(c.isGroup) c.rotation.y = targetRot; });
            }

            // Ïπ¥Î©îÎùº ÌåîÎ°úÏö∞
            camera.position.x = playerGroup.position.x + 20;
            camera.position.z = playerGroup.position.z + 20;
            dirLight.position.x = playerGroup.position.x + 10;
            dirLight.position.z = playerGroup.position.z + 10;
            ground.position.x = playerGroup.position.x;
            ground.position.z = playerGroup.position.z;

            // Î°úÏßÅ ÏóÖÎç∞Ïù¥Ìä∏
            fireWeapons(delta);
            if (playerMixer) playerMixer.update(delta);

            // Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏ (ÌîåÎ†àÏù¥Ïñ¥)
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.velocity);
                if (p.userData.type === 'contract') p.rotation.y += 0.2;
                p.userData.duration -= delta;
                if (p.userData.duration <= 0) { scene.remove(p); projectiles.splice(i, 1); continue; }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const distSq = (p.position.x - enemy.position.x)**2 + (p.position.z - enemy.position.z)**2;
                    if (distSq < 1.5 * 1.5) {
                        if (p.userData.hitList && p.userData.hitList.includes(enemy.id)) continue;
                        takeDamage(enemy, p.userData.damage);
                        if (p.userData.hitList) p.userData.hitList.push(enemy.id);
                        if (p.userData.type !== 'contract') { scene.remove(p); projectiles.splice(i, 1); break; }
                        else if (p.userData.hitList.length >= p.userData.pierce) { scene.remove(p); projectiles.splice(i, 1); break; }
                    }
                }
            }

            // Ï†Å Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏ (ÌïòÌä∏)
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const ep = enemyProjectiles[i];
                ep.position.add(ep.userData.velocity);
                ep.userData.duration -= delta;
                
                // ÌîåÎ†àÏù¥Ïñ¥ Ï∂©Îèå Ï≤¥ÌÅ¨
                const pDist = ep.position.distanceTo(playerGroup.position);
                if (pDist < 1.0) {
                    damagePlayer(ep.userData.damage);
                    scene.remove(ep);
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                if (ep.userData.duration <= 0) { scene.remove(ep); enemyProjectiles.splice(i, 1); }
            }

            // Ï†Å AI (Í∑ºÍ±∞Î¶¨ vs ÏõêÍ±∞Î¶¨)
            enemies.forEach(enemy => {
                if (enemy.userData.mixer) enemy.userData.mixer.update(delta);
                
                const distToPlayer = enemy.position.distanceTo(playerGroup.position);
                const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position).normalize();

                if (enemy.userData.type === 'male') {
                    // Í∑ºÍ±∞Î¶¨: Îã•Îèå
                    enemy.position.add(dir.multiplyScalar(enemy.userData.speed));
                    if (distToPlayer < 0.8) damagePlayer(0.5); // Î™∏Î∞ï Îç∞ÎØ∏ÏßÄ
                } else {
                    // ÏõêÍ±∞Î¶¨: Í±∞Î¶¨ Ïú†ÏßÄ Î∞è Î∞úÏÇ¨
                    if (distToPlayer > 8) {
                        enemy.position.add(dir.multiplyScalar(enemy.userData.speed));
                    }
                    
                    // Í≥µÍ≤© Ïø®Îã§Ïö¥ Ï≤¥ÌÅ¨
                    enemy.userData.attackCooldown -= delta;
                    if (enemy.userData.attackCooldown <= 0 && distToPlayer < 12) {
                        enemyShootHeart(enemy);
                        enemy.userData.attackCooldown = 2.0; // 2Ï¥à Ïø®Îã§Ïö¥
                    }
                }
                enemy.lookAt(playerGroup.position);
            });

            // Î≥¥ÏÑù ÏäµÎìù
            for (let i = gems.length - 1; i >= 0; i--) {
                const gem = gems[i];
                const dist = playerGroup.position.distanceTo(gem.position);
                if (dist < playerStats.pickupRange) {
                    const dir = new THREE.Vector3().subVectors(playerGroup.position, gem.position).normalize();
                    gem.position.add(dir.multiplyScalar(0.3));
                    if (dist < 0.5) { gameState.exp += gem.userData.value; scene.remove(gem); gems.splice(i, 1); checkLevelUp(); }
                } else { gem.rotation.y += 0.05; }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 40;
            camera.left = -viewSize * aspect; camera.right = viewSize * aspect;
            camera.top = viewSize; camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
