<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>í•œíƒ•ì´ì˜ ìƒì¡´ ì‹ ê³  (Vampire Survivors Style)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #101020; font-family: 'Black Han Sans', sans-serif; user-select: none; }
        
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Gowun+Batang&display=swap');

        /* UI ë ˆì´ì•„ì›ƒ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* ìƒë‹¨ ì •ë³´ë°” */
        #top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; align-items: center;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 15px;
            color: #fff; border: 2px solid #555; font-size: 20px; text-shadow: 1px 1px 2px black;
        }
        #score { color: #ffd700; }
        #timer { color: #fff; min-width: 60px; text-align: center; }

        /* ê²½í—˜ì¹˜ ë°” */
        #exp-bar-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10;
        }
        #exp-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); transition: width 0.2s;
        }
        #level-indicator {
            position: absolute; top: 15px; right: 20px; color: #00f2fe; font-size: 30px; text-shadow: 2px 2px 0 #000;
        }

        /* ë ˆë²¨ì—… ì„ íƒì°½ */
        #levelup-modal {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
            pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .modal-title { font-size: 50px; color: #ffd700; margin-bottom: 30px; text-shadow: 0 0 10px orange; animation: float 2s infinite; }
        .card-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card {
            width: 200px; height: 280px; background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #666; border-radius: 10px; padding: 15px;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .upgrade-card:hover { transform: translateY(-10px); border-color: #fff; background: #333; }
        .card-icon { font-size: 50px; margin-bottom: 10px; }
        .card-name { font-size: 24px; color: #fff; margin-bottom: 10px; color: #00ff00; }
        .card-desc { font-size: 16px; color: #ccc; font-family: 'Gowun Batang', serif; line-height: 1.4; }
        .card-level { margin-top: auto; font-size: 14px; color: #888; }

        /* ì¡°ì´ìŠ¤í‹± (ëª¨ë°”ì¼ìš©, í•„ìš”ì‹œ í™œì„±í™”) */
        #joystick-zone { display: none; } 

        /* ê²Œì„ì˜¤ë²„ */
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.8); z-index: 200; pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        .go-title { font-size: 80px; color: #ff0055; margin-bottom: 20px; }
        .go-score { font-size: 30px; margin-bottom: 40px; }
        button {
            padding: 15px 40px; font-size: 24px; background: #fff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-family: 'Black Han Sans';
        }
        button:hover { background: #ddd; }

        @keyframes float { 0% { transform: translateY(0); } 50% { transform: translateY(-10px); } 100% { transform: translateY(0); } }

        /* ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ */
        .damage-text {
            position: absolute; color: white; font-weight: bold; font-size: 20px;
            pointer-events: none; text-shadow: 1px 1px 0 #000;
            animation: popUp 0.8s forwards;
        }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-30px) scale(0.5); } }
    </style>
</head>
<body>
    <!-- 3D ìº”ë²„ìŠ¤ -->
    <div id="canvas-container"></div>

    <!-- UI ë ˆì´ì–´ -->
    <div id="exp-bar-container"><div id="exp-bar"></div></div>
    
    <div id="ui-layer">
        <div id="level-indicator">LV. <span id="level-val">1</span></div>
        
        <div id="top-bar">
            <div class="stat-box">TIME <span id="timer">00:00</span></div>
            <div class="stat-box">KILL <span id="kill-count">0</span></div>
        </div>

        <div id="damage-layer"></div>
    </div>

    <!-- ë ˆë²¨ì—… ëª¨ë‹¬ -->
    <div id="levelup-modal">
        <div class="modal-title">ë ˆë²¨ ì—…!</div>
        <div class="card-container" id="upgrade-cards">
            <!-- ìë°”ìŠ¤í¬ë¦½íŠ¸ë¡œ ì¹´ë“œ ìƒì„± -->
        </div>
    </div>

    <!-- ê²Œì„ ì˜¤ë²„ í™”ë©´ -->
    <div id="game-over-screen">
        <div class="go-title">ì‚¬ ë§</div>
        <div class="go-score">ìµœì¢… ê¸°ë¡: <span id="final-time">00:00</span> / ì²˜ì¹˜: <span id="final-kills">0</span></div>
        <button onclick="location.reload()">ë‹¤ì‹œ ë„ì „í•˜ê¸°</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ==========================================
        // 1. ê²Œì„ ì„¤ì • ë° ì´ˆê¸°í™”
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e); // ì–´ë‘ìš´ ë°¤í•˜ëŠ˜ìƒ‰
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 60);

        // íƒ‘ë‹¤ìš´ ì¹´ë©”ë¼ ì„¤ì •
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -40, window.innerWidth / 40,
            window.innerHeight / 40, window.innerHeight / -40,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);
        camera.zoom = 1.2;
        camera.updateProjectionMatrix();

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ì¡°ëª…
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // ë°”ë‹¥ (ë¬´í•œ ëŠë‚Œì˜ ê·¸ë¦¬ë“œ)
        const planeGeometry = new THREE.PlaneGeometry(200, 200);
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x222222,
            roughness: 0.8,
        });
        const ground = new THREE.Mesh(planeGeometry, planeMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ê·¸ë¦¬ë“œ í—¬í¼
        const gridHelper = new THREE.GridHelper(200, 100, 0x444444, 0x333333);
        scene.add(gridHelper);

        // ==========================================
        // 2. ê²Œì„ ìƒíƒœ ê´€ë¦¬
        // ==========================================
        const gameState = {
            isPlaying: true,
            isPaused: false,
            time: 0,
            level: 1,
            exp: 0,
            maxExp: 10,
            kills: 0,
            hp: 100,
            maxHp: 100
        };

        const playerStats = {
            moveSpeed: 0.15,
            damageMult: 1.0,
            pickupRange: 3.0,
            luck: 1.0
        };

        // ë¬´ê¸° ë° íŒ¨ì‹œë¸Œ ëª©ë¡
        const inventory = {
            qrBeam: { level: 1, active: true, name: "QRì½”ë“œ ë¹”", type: "weapon", cooldown: 0.8, lastShot: 0, damage: 10 },
            contract: { level: 0, active: false, name: "ê³„ì•½ì„œ ë˜ì§€ê¸°", type: "weapon", cooldown: 2.5, lastShot: 0, damage: 30, pierce: 2 },
            mist: { level: 0, active: false, name: "íƒ€ì§€ë¦¬ ë¯¸ìŠ¤íŠ¸", type: "weapon", cooldown: 0.5, lastTick: 0, damage: 3, range: 4 },
            chunjat: { level: 0, active: false, name: "ì¶˜ì£", type: "passive", effect: "speed", val: 0.05 },
            clover: { level: 0, active: false, name: "í–‰ìš´ì˜ í´ë¡œë²„", type: "passive", effect: "might", val: 0.2 }
        };

        // ==========================================
        // 3. í”Œë ˆì´ì–´ ë° ì—”í‹°í‹°
        // ==========================================
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // í”Œë ˆì´ì–´ ëª¨ë¸ (fallback ë°•ìŠ¤) - ë¡œë”© ì „ê¹Œì§€ í‘œì‹œ
        const pGeo = new THREE.BoxGeometry(1, 1, 1);
        const pMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const playerMesh = new THREE.Mesh(pGeo, pMat);
        playerMesh.position.y = 0.5;
        playerMesh.castShadow = true;
        playerGroup.add(playerMesh);

        // íƒ€ì§€ë¦¬ ë¯¸ìŠ¤íŠ¸ ì‹œê°íš¨ê³¼ (ë¹„í™œì„±í™” ìƒíƒœë¡œ ì‹œì‘)
        const mistGeo = new THREE.RingGeometry(0.5, 4, 32);
        const mistMat = new THREE.MeshBasicMaterial({ color: 0x800080, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
        const mistMesh = new THREE.Mesh(mistGeo, mistMat);
        mistMesh.rotation.x = -Math.PI / 2;
        mistMesh.position.y = 0.1;
        playerGroup.add(mistMesh);

        // â˜… 3D ëª¨ë¸ ë¡œë”© ì½”ë“œ ë³µêµ¬ â˜…
        // GitHub ë“± ë¡œì»¬ì—ì„œ ì‹¤í–‰ ì‹œ ./player.glb íŒŒì¼ì´ ê°™ì€ í´ë”ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
        const loader = new GLTFLoader();
        let mixer;
        loader.load('./player.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(1, 1, 1);
            model.position.y = 0; 
            // ëª¨ë¸ ê·¸ë¦¼ì ì„¤ì •
            model.traverse(o => { if(o.isMesh) o.castShadow = true; });
            
            // ë¡œë”© ì„±ê³µ ì‹œ ë°•ìŠ¤ ì œê±°í•˜ê³  ëª¨ë¸ ì¶”ê°€
            playerGroup.remove(playerMesh);
            playerGroup.add(model);
            
            // ì• ë‹ˆë©”ì´ì…˜ ë¯¹ì„œ ì„¤ì •
            mixer = new THREE.AnimationMixer(model);
            if(gltf.animations.length > 0) mixer.clipAction(gltf.animations[0]).play();
        }, undefined, (err) => {
            console.log('Player model not found. Using default box.', err);
        });

        // ë°°ì—´ë“¤
        const enemies = [];
        const projectiles = [];
        const gems = []; // ê²½í—˜ì¹˜ ë³´ì„
        const damageNumbers = [];

        // ==========================================
        // 4. ì…ë ¥ ì²˜ë¦¬
        // ==========================================
        const keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowLeft:false, ArrowDown:false, ArrowRight:false };
        
        window.addEventListener('keydown', e => {
            if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = true;
        });
        window.addEventListener('keyup', e => {
            if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = false;
        });

        // ==========================================
        // 5. ê²Œì„ ë¡œì§ í•¨ìˆ˜ë“¤
        // ==========================================

        function spawnEnemy() {
            if (gameState.isPaused) return;

            // í”Œë ˆì´ì–´ ì£¼ë³€ ëœë¤ ìœ„ì¹˜ ìƒì„± (í™”ë©´ ë°–)
            const angle = Math.random() * Math.PI * 2;
            const distance = 15 + Math.random() * 10;
            const x = playerGroup.position.x + Math.cos(angle) * distance;
            const z = playerGroup.position.z + Math.sin(angle) * distance;

            const geometry = new THREE.BoxGeometry(1, 1.5, 1);
            // ë ˆë²¨ì— ë”°ë¼ ì  ìƒ‰ìƒ ë³€ê²½
            let color = 0xff0000;
            let hp = 15 + (gameState.time * 0.5); // ì‹œê°„ ì§€ë‚ ìˆ˜ë¡ ì²´ë ¥ ì¦ê°€
            
            if (gameState.time > 60) { color = 0xaa0000; hp *= 1.5; }
            if (gameState.time > 120) { color = 0x550000; hp *= 2; }

            const material = new THREE.MeshStandardMaterial({ color: color });
            const enemy = new THREE.Mesh(geometry, material);
            
            enemy.position.set(x, 0.75, z);
            enemy.castShadow = true;
            enemy.userData = { 
                hp: hp, 
                maxHp: hp, 
                speed: 0.03 + Math.random() * 0.02,
                damage: 10
            };
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function createDamageText(position, damage) {
            const div = document.createElement('div');
            div.className = 'damage-text';
            div.innerText = Math.floor(damage);
            
            // 3D ì¢Œí‘œ -> 2D í™”ë©´ ì¢Œí‘œ ë³€í™˜
            const vec = position.clone();
            vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;

            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            
            document.getElementById('damage-layer').appendChild(div);
            setTimeout(() => div.remove(), 800);
        }

        function spawnGem(position, value) {
            const geo = new THREE.OctahedronGeometry(0.3);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa });
            const gem = new THREE.Mesh(geo, mat);
            gem.position.copy(position);
            gem.position.y = 0.5;
            gem.userData = { value: value };
            scene.add(gem);
            gems.push(gem);
        }

        function getNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;
            enemies.forEach(e => {
                const d = playerGroup.position.distanceTo(e.position);
                if (d < minDist) { minDist = d; nearest = e; }
            });
            return { enemy: nearest, dist: minDist };
        }

        // --- ë¬´ê¸° ë¡œì§ ---
        function fireWeapons(delta) {
            // 1. QRì½”ë“œ ë¹” (ê°€ì¥ ê°€ê¹Œìš´ ì )
            if (inventory.qrBeam.active) {
                inventory.qrBeam.lastShot += delta;
                if (inventory.qrBeam.lastShot >= inventory.qrBeam.cooldown) {
                    const targetInfo = getNearestEnemy();
                    if (targetInfo.enemy && targetInfo.dist < 15) {
                        shootQR(targetInfo.enemy);
                        inventory.qrBeam.lastShot = 0;
                    }
                }
            }

            // 2. ê³„ì•½ì„œ ë˜ì§€ê¸° (ëœë¤ ë°©í–¥ or ì´ë™ ë°©í–¥)
            if (inventory.contract.active) {
                inventory.contract.lastShot += delta;
                if (inventory.contract.lastShot >= inventory.contract.cooldown) {
                    throwContract();
                    inventory.contract.lastShot = 0;
                }
            }

            // 3. íƒ€ì§€ë¦¬ ë¯¸ìŠ¤íŠ¸ (ì˜¤ë¼ ë°ë¯¸ì§€)
            if (inventory.mist.active) {
                // ì‹œê° íš¨ê³¼ ì¼œê¸°
                mistMesh.material.opacity = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                const scale = inventory.mist.range;
                mistMesh.scale.set(scale, scale, 1);

                inventory.mist.lastTick += delta;
                if (inventory.mist.lastTick >= inventory.mist.cooldown) {
                    enemies.forEach(e => {
                        if (playerGroup.position.distanceTo(e.position) <= inventory.mist.range) {
                            takeDamage(e, inventory.mist.damage * playerStats.damageMult);
                        }
                    });
                    inventory.mist.lastTick = 0;
                }
            } else {
                mistMesh.material.opacity = 0;
            }
        }

        function shootQR(target) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // ë…¹ìƒ‰ ë¹”
            const beam = new THREE.Mesh(geo, mat);
            
            beam.position.copy(playerGroup.position);
            beam.position.y = 1;
            
            // íƒ€ê²Ÿ ë°©í–¥ ë°”ë¼ë³´ê¸° (ë†’ì´ ê³ ì •)
            beam.lookAt(target.position.x, 1, target.position.z);
            
            // ë°©í–¥ ë²¡í„° ê³„ì‚° (Yì¶• ì œê±°í•˜ì—¬ ìˆ˜í‰ ë°œì‚¬ ë³´ì¥)
            const dir = new THREE.Vector3(target.position.x - playerGroup.position.x, 0, target.position.z - playerGroup.position.z).normalize();
            
            beam.userData = { 
                velocity: dir.multiplyScalar(0.4), 
                damage: inventory.qrBeam.damage * playerStats.damageMult,
                duration: 2, // 2ì´ˆ í›„ ì‚­ì œ
                hitList: [] 
            };
            
            scene.add(beam);
            projectiles.push(beam);
        }

        function throwContract() {
            // í•˜ì–€ ì„œë¥˜ ë´‰íˆ¬ ëª¨ì–‘
            const geo = new THREE.BoxGeometry(0.8, 0.1, 0.5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const paper = new THREE.Mesh(geo, mat);

            paper.position.copy(playerGroup.position);
            paper.position.y = 1;

            // ëœë¤ ë°©í–¥ìœ¼ë¡œ ë˜ì§
            const angle = Math.random() * Math.PI * 2;
            const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).normalize();

            paper.userData = {
                type: 'contract',
                velocity: dir.multiplyScalar(0.3),
                damage: inventory.contract.damage * playerStats.damageMult,
                duration: 3,
                pierce: inventory.contract.pierce,
                hitList: [] // ì´ë¯¸ ë§ì€ ì  ID ì €ì¥ (ì¤‘ë³µ í”¼ê²© ë°©ì§€ìš©)
            };

            scene.add(paper);
            projectiles.push(paper);
        }

        function takeDamage(enemy, amount) {
            enemy.userData.hp -= amount;
            createDamageText(enemy.position, amount);
            
            // í”¼ê²© íš¨ê³¼ (ë¹¨ê°›ê²Œ ë°˜ì§ì„)
            enemy.material.emissive.setHex(0xff0000);
            setTimeout(() => { if(enemy) enemy.material.emissive.setHex(0x000000); }, 100);

            if (enemy.userData.hp <= 0) {
                // ì‚¬ë§ ì²˜ë¦¬
                spawnGem(enemy.position, 1);
                gameState.kills++;
                document.getElementById('kill-count').innerText = gameState.kills;
                scene.remove(enemy);
                const idx = enemies.indexOf(enemy);
                if (idx > -1) enemies.splice(idx, 1);
            }
        }

        // --- ë ˆë²¨ì—… ì‹œìŠ¤í…œ ---
        function checkLevelUp() {
            if (gameState.exp >= gameState.maxExp) {
                gameState.exp -= gameState.maxExp;
                gameState.level++;
                gameState.maxExp = Math.floor(gameState.maxExp * 1.5);
                
                document.getElementById('level-val').innerText = gameState.level;
                showLevelUpModal();
            }
            // ê²½í—˜ì¹˜ ë°” ì—…ë°ì´íŠ¸
            const pct = (gameState.exp / gameState.maxExp) * 100;
            document.getElementById('exp-bar').style.width = `${pct}%`;
        }

        function showLevelUpModal() {
            gameState.isPaused = true;
            const modal = document.getElementById('levelup-modal');
            const container = document.getElementById('upgrade-cards');
            container.innerHTML = '';
            modal.style.display = 'flex';

            // ëœë¤ìœ¼ë¡œ 3ê°œì˜ ì„ íƒì§€ ìƒì„±
            const options = [
                { key: 'qrBeam', title: 'QRì½”ë“œ ë¹”', desc: 'ê¸°ë³¸ ê³µê²© ì†ë„ì™€ ë°ë¯¸ì§€ê°€ ì¦ê°€í•©ë‹ˆë‹¤.', icon: 'ğŸ“±' },
                { key: 'contract', title: 'ê³„ì•½ì„œ ë˜ì§€ê¸°', desc: 'ê´€í†µí•˜ëŠ” ê³„ì•½ì„œë¥¼ ë˜ì§‘ë‹ˆë‹¤. (Lv UP: ê°¯ìˆ˜/ë°ë¯¸ì§€ ì¦ê°€)', icon: 'ğŸ“„' },
                { key: 'mist', title: 'íƒ€ì§€ë¦¬ ë¯¸ìŠ¤íŠ¸', desc: 'ì£¼ë³€ ì ì—ê²Œ ì§€ì† ë°ë¯¸ì§€ë¥¼ ì¤ë‹ˆë‹¤.', icon: 'â˜ ï¸' },
                { key: 'chunjat', title: 'ì¶˜ì£', desc: 'ì´ë™ ì†ë„ê°€ 10% ì¦ê°€í•©ë‹ˆë‹¤.', icon: 'ğŸŒ°' },
                { key: 'clover', title: 'í–‰ìš´ì˜ í´ë¡œë²„', desc: 'ê³µê²©ë ¥ì´ 20% ì¦ê°€í•©ë‹ˆë‹¤.', icon: 'ğŸ€' }
            ];

            // ì…”í”Œ
            options.sort(() => Math.random() - 0.5);
            const choices = options.slice(0, 3);

            choices.forEach(opt => {
                const item = inventory[opt.key];
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                
                let btnText = item.level === 0 ? "ì‹ ê·œ ìŠµë“" : `Lv.${item.level} -> Lv.${item.level+1}`;
                if (item.type === 'passive') btnText = "ê°•í™”";

                card.innerHTML = `
                    <div class="card-icon">${opt.icon}</div>
                    <div class="card-name">${opt.title}</div>
                    <div class="card-desc">${opt.desc}</div>
                    <div class="card-level">${btnText}</div>
                `;
                
                card.onclick = () => {
                    applyUpgrade(opt.key);
                    modal.style.display = 'none';
                    gameState.isPaused = false;
                };
                container.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            const item = inventory[key];
            item.active = true;
            item.level++;

            if (key === 'qrBeam') {
                item.damage += 5;
                item.cooldown = Math.max(0.2, item.cooldown * 0.9);
            } else if (key === 'contract') {
                item.damage += 10;
                item.pierce += 1;
                item.cooldown = Math.max(1.0, item.cooldown * 0.9);
            } else if (key === 'mist') {
                item.damage += 2;
                item.range += 0.5;
            } else if (key === 'chunjat') {
                playerStats.moveSpeed += item.val;
            } else if (key === 'clover') {
                playerStats.damageMult += item.val;
            }
        }

        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('final-time').innerText = document.getElementById('timer').innerText;
            document.getElementById('final-kills').innerText = gameState.kills;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        // ==========================================
        // 6. ë©”ì¸ ë£¨í”„
        // ==========================================
        const clock = new THREE.Clock();
        
        // 1ì´ˆë§ˆë‹¤ ì  ìƒì„± íƒ€ì´ë¨¸
        setInterval(() => {
            if (!gameState.isPlaying || gameState.isPaused) return;
            // ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ì  ìƒì„±ëŸ‰ ì¦ê°€
            const spawnCount = 1 + Math.floor(gameState.time / 30);
            for(let i=0; i<spawnCount; i++) spawnEnemy();
            gameState.time++;
            
            // íƒ€ì´ë¨¸ UI ì—…ë°ì´íŠ¸
            const m = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const s = (gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            if (!gameState.isPlaying || gameState.isPaused) return;

            const delta = clock.getDelta();

            // í”Œë ˆì´ì–´ ì´ë™
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys.w || keys.ArrowUp) moveDir.z -= 1;
            if (keys.s || keys.ArrowDown) moveDir.z += 1;
            if (keys.a || keys.ArrowLeft) moveDir.x -= 1;
            if (keys.d || keys.ArrowRight) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(playerStats.moveSpeed);
                playerGroup.position.add(moveDir);
                
                // ì´ë™ ë°©í–¥ ë°”ë¼ë³´ê¸° (ë¶€ë“œëŸ½ê²Œ)
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                // ë‹¨ìˆœí•˜ê²Œ ë°”ë¡œ íšŒì „
                if(mixer) playerGroup.children.forEach(c => { if(c.isGroup) c.rotation.y = targetRot; });
            }

            // ì¹´ë©”ë¼ê°€ í”Œë ˆì´ì–´ë¥¼ ë”°ë¼ë‹¤ë‹˜ (ì•½ê°„ì˜ ë¶€ë“œëŸ¬ì›€)
            camera.position.x = playerGroup.position.x + 20;
            camera.position.z = playerGroup.position.z + 20;
            dirLight.position.x = playerGroup.position.x + 10;
            dirLight.position.z = playerGroup.position.z + 10;
            
            // ë°”ë‹¥ ìœ„ì¹˜ ì¡°ì • (ë¬´í•œ ë§µ ì°©ì‹œ) - í…ìŠ¤ì²˜ë¼ë©´ UV ì´ë™ì´ ì¢‹ì§€ë§Œ ì—¬ê¸°ì„  ë‹¨ìˆœíˆ ë”°ë¼ê°
            ground.position.x = playerGroup.position.x;
            ground.position.z = playerGroup.position.z;

            // ë¬´ê¸° ë°œì‚¬ ë° ë¡œì§
            fireWeapons(delta);

            // íˆ¬ì‚¬ì²´ ì—…ë°ì´íŠ¸
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.velocity);
                
                if (p.userData.type === 'contract') {
                    p.rotation.y += 0.2; // ê³„ì•½ì„œëŠ” íšŒì „
                }

                p.userData.duration -= delta;
                if (p.userData.duration <= 0) {
                    scene.remove(p);
                    projectiles.splice(i, 1);
                    continue;
                }

                // ì¶©ëŒ ì²˜ë¦¬
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    // 2D ê±°ë¦¬ ì²´í¬ (Yì¶• ë¬´ì‹œ, 1.5 ë²”ìœ„ë¡œ í™•ëŒ€í•˜ì—¬ í”¼ê²© íŒì • ê°œì„ )
                    const distSq = (p.position.x - enemy.position.x)**2 + (p.position.z - enemy.position.z)**2;
                    
                    if (distSq < 1.5 * 1.5) {
                        // ì´ë¯¸ ë§ì€ ì ì€ íŒ¨ìŠ¤ (ê´€í†µ ë¬´ê¸°ìš©)
                        if (p.userData.hitList && p.userData.hitList.includes(enemy.id)) continue;

                        takeDamage(enemy, p.userData.damage);
                        
                        if (p.userData.hitList) p.userData.hitList.push(enemy.id);

                        // ê´€í†µë ¥ ì°¨ê° (QRë¹”ì€ ê´€í†µ ì—†ìŒ, ê³„ì•½ì„œëŠ” ìˆìŒ)
                        if (p.userData.type !== 'contract') {
                            scene.remove(p);
                            projectiles.splice(i, 1);
                            break;
                        } else {
                            if (p.userData.hitList.length >= p.userData.pierce) {
                                scene.remove(p);
                                projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }

            // ì  AI (í”Œë ˆì´ì–´ ì¶”ì )
            enemies.forEach(enemy => {
                const dir = new THREE.Vector3().subVectors(playerGroup.position, enemy.position).normalize();
                enemy.position.add(dir.multiplyScalar(enemy.userData.speed));
                enemy.lookAt(playerGroup.position);

                // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ (ê²Œì„ ì˜¤ë²„ ì¡°ê±´)
                if (enemy.position.distanceTo(playerGroup.position) < 0.8) {
                    gameOver();
                }
            });

            // ë³´ì„(ê²½í—˜ì¹˜) ìŠµë“
            for (let i = gems.length - 1; i >= 0; i--) {
                const gem = gems[i];
                const dist = playerGroup.position.distanceTo(gem.position);
                
                // ìì„ íš¨ê³¼ ë²”ìœ„
                if (dist < playerStats.pickupRange) {
                    // í”Œë ˆì´ì–´ ìª½ìœ¼ë¡œ ë¹¨ë ¤ì˜´
                    const dir = new THREE.Vector3().subVectors(playerGroup.position, gem.position).normalize();
                    gem.position.add(dir.multiplyScalar(0.3)); // ë¹ ë¥´ê²Œ ë¹¨ë ¤ì˜´

                    if (dist < 0.5) {
                        gameState.exp += gem.userData.value;
                        scene.remove(gem);
                        gems.splice(i, 1);
                        checkLevelUp();
                    }
                } else {
                    gem.rotation.y += 0.05;
                }
            }

            if (mixer) mixer.update(delta);
            renderer.render(scene, camera);
        }

        // ë°˜ì‘í˜• ë¦¬ì‚¬ì´ì¦ˆ
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            // Orthographic Camera ë¦¬ì‚¬ì´ì¦ˆ
            const viewSize = 40;
            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
