<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ÌïúÌÉïÏù¥Ïùò ÏÉùÏ°¥ Ïã†Í≥† (Vampire Survivors Style)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #101020; font-family: 'Black Han Sans', sans-serif; user-select: none; }
        
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Gowun+Batang&display=swap');

        /* UI Î†àÏù¥ÏïÑÏõÉ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* ÏÉÅÎã® Ï†ïÎ≥¥Î∞î */
        #top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; align-items: center;
            opacity: 0; transition: opacity 0.5s;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 15px;
            color: #fff; border: 2px solid #555; font-size: 20px; text-shadow: 1px 1px 2px black;
            display: flex; align-items: center; gap: 10px;
        }
        #score { color: #ffd700; }
        #timer { color: #fff; min-width: 60px; text-align: center; }
        #hp-box { color: #ff5555; border-color: #ff5555; }
        #bomb-box { color: #00ffaa; border-color: #00ffaa; }

        /* Í≤ΩÌóòÏπò Î∞î */
        #exp-bar-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10;
            opacity: 0; transition: opacity 0.5s;
        }
        #exp-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); transition: width 0.2s;
        }
        #level-indicator {
            position: absolute; top: 15px; right: 20px; color: #00f2fe; font-size: 30px; text-shadow: 2px 2px 0 #000;
            opacity: 0; transition: opacity 0.5s;
        }

        /* ÏãúÏûë ÌôîÎ©¥ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4); 
            z-index: 300; pointer-events: auto;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            backdrop-filter: blur(2px);
        }
        .start-title {
            font-size: 80px; color: #ffd700; text-shadow: 0 0 20px #ff5500;
            margin-bottom: 20px; animation: float 3s infinite ease-in-out;
        }
        .start-btn {
            padding: 20px 60px; font-size: 30px; background: linear-gradient(45deg, #ff0055, #ff5500);
            color: white; border: 4px solid white; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Black Han Sans', sans-serif;
        }
        .start-btn:hover { transform: scale(1.1); box-shadow: 0 0 40px rgba(255, 0, 85, 0.8); }
        .camera-label-container {
            position: absolute; bottom: 10%; width: 100%; display: flex; justify-content: center; gap: 40px;
            pointer-events: none; color: rgba(255,255,255,0.3); font-size: 20px;
        }
        .cam-label { transition: all 0.5s; }
        .cam-active { color: #00ffff; font-weight: bold; transform: scale(1.2); text-shadow: 0 0 10px #00ffff; opacity: 1; }

        /* Î†àÎ≤®ÏóÖ ÏÑ†ÌÉùÏ∞Ω */
        #levelup-modal {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 100;
            pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .modal-title { font-size: 50px; color: #ffd700; margin-bottom: 30px; text-shadow: 0 0 10px orange; animation: float 2s infinite; }
        .card-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card {
            width: 200px; height: 280px; background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #666; border-radius: 10px; padding: 15px;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            cursor: pointer; transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .upgrade-card:hover { transform: translateY(-10px); border-color: #fff; background: #333; }
        .card-icon { font-size: 50px; margin-bottom: 10px; }
        .card-name { font-size: 24px; color: #fff; margin-bottom: 10px; color: #00ff00; }
        .card-desc { font-size: 16px; color: #ccc; font-family: 'Gowun Batang', serif; line-height: 1.4; }
        .card-level { margin-top: auto; font-size: 14px; color: #888; }

        /* Í≤åÏûÑÏò§Î≤Ñ */
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.8); z-index: 200; pointer-events: auto;
            flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        .go-title { font-size: 80px; color: #ff0055; margin-bottom: 20px; }
        .go-score { font-size: 30px; margin-bottom: 40px; }
        button {
            padding: 15px 40px; font-size: 24px; background: #fff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-family: 'Black Han Sans';
        }
        button:hover { background: #ddd; }

        /* ÌïÑÏÇ¥Í∏∞ ÏïàÎÇ¥ */
        #ult-guide {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 18px; text-align: center;
            opacity: 0; transition: opacity 0.5s;
        }

        @keyframes float { 0% { transform: translateY(0); } 50% { transform: translateY(-10px); } 100% { transform: translateY(0); } }

        /* Îç∞ÎØ∏ÏßÄ ÌÖçÏä§Ìä∏ */
        .damage-text {
            position: absolute; color: white; font-weight: bold; font-size: 20px;
            pointer-events: none; text-shadow: 1px 1px 0 #000;
            animation: popUp 0.8s forwards; white-space: nowrap;
        }
        .mincho-text {
            color: #00ffaa !important; font-size: 24px !important; text-shadow: 0 0 5px #00ffaa;
        }
        .death-quote {
            color: #ffff00; font-size: 18px; font-family: 'Gowun Batang', serif;
            text-shadow: 1px 1px 2px #000; z-index: 5;
        }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-40px) scale(0.8); } }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="exp-bar-container"><div id="exp-bar"></div></div>
    
    <div id="ui-layer">
        <div id="level-indicator">LV. <span id="level-val">1</span></div>
        <div id="top-bar">
            <div class="stat-box" id="hp-box">HP <span id="hp-val">100</span></div>
            <div class="stat-box" id="bomb-box">üí£ <span id="bomb-val">1</span> <span id="bomb-cooldown" style="font-size:14px; color:#aaa; margin-left:5px;">(0%)</span></div>
            <div class="stat-box">TIME <span id="timer">00:00</span></div>
            <div class="stat-box">KILL <span id="kill-count">0</span></div>
        </div>
        <div id="ult-guide">[SPACE] ÌïÑÏÇ¥Í∏∞: ÌôîÎ©¥ Ï†ÑÏ≤¥ Í≥µÍ≤©</div>
        <div id="damage-layer"></div>
    </div>

    <!-- ÏãúÏûë ÌôîÎ©¥ -->
    <div id="start-screen">
        <div class="start-title">ÌïúÌÉïÏù¥Ïùò ÏÉùÏ°¥ Ïã†Í≥†</div>
        <button class="start-btn" id="start-btn">ÏÉùÏ°¥ ÏãúÏûë</button>
        <div class="camera-label-container">
            <div id="cam-label-0" class="cam-label cam-active">CAM 1: ÏñºÏß± Í∞ÅÎèÑ</div>
            <div id="cam-label-1" class="cam-label">CAM 2: Ï†ÑÏã† Ïä§Ï∫î</div>
            <div id="cam-label-2" class="cam-label">CAM 3: ÏúÑÏÑ± Í∞êÏãú</div>
        </div>
    </div>

    <div id="levelup-modal">
        <div class="modal-title">Î†àÎ≤® ÏóÖ!</div>
        <div class="card-container" id="upgrade-cards"></div>
    </div>

    <div id="game-over-screen">
        <div class="go-title">ÏÇ¨ Îßù</div>
        <div class="go-score">ÏµúÏ¢Ö Í∏∞Î°ù: <span id="final-time">00:00</span> / Ï≤òÏπò: <span id="final-kills">0</span></div>
        <button onclick="location.reload()">Îã§Ïãú ÎèÑÏ†ÑÌïòÍ∏∞</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // ==========================================
        // [ÏµúÏ†ÅÌôî 1] Ï†ÑÏó≠ Î≥ÄÏàò Î∞è ÏßÄÏò§Î©îÌä∏Î¶¨/Ïû¨Ïßà ÎØ∏Î¶¨ ÏÉùÏÑ± (Ïû¨ÏÇ¨Ïö©)
        // ==========================================
        const _tempVec1 = new THREE.Vector3(); // ÏûÑÏãú Î≤°ÌÑ∞ 1
        const _tempVec2 = new THREE.Vector3(); // ÏûÑÏãú Î≤°ÌÑ∞ 2
        let activeDamageTextCount = 0; // ÌôúÏÑ± Îç∞ÎØ∏ÏßÄ ÌÖçÏä§Ìä∏ Ïàò

        // Ìà¨ÏÇ¨Ï≤¥ ÏßÄÏò§Î©îÌä∏Î¶¨/Ïû¨Ïßà Í≥µÏú†
        const qrGeo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
        const qrMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        
        const contractGeo = new THREE.BoxGeometry(0.8, 0.1, 0.5);
        const contractMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        
        const heartGeo = new THREE.SphereGeometry(0.4, 8, 8);
        const heartMat = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0x550000 });

        // Ï≤¥Î†•Î∞î ÏßÄÏò§Î©îÌä∏Î¶¨/Ïû¨Ïßà Í≥µÏú†
        const hpBarBgGeo = new THREE.PlaneGeometry(1, 0.15);
        const hpBarBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, depthTest: false });
        const hpBarFgGeo = new THREE.PlaneGeometry(1, 0.15);
        hpBarFgGeo.translate(0.5, 0, 0); // ÏôºÏ™Ω Ï†ïÎ†¨
        const hpBarFgMatRed = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false });
        const hpBarFgMatGreen = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
        const hpBarFgMatBoss = new THREE.MeshBasicMaterial({ color: 0xffaa00, depthTest: false });

        // ==========================================
        // 1. Í≤åÏûÑ ÏÑ§Ï†ï Î∞è Ï¥àÍ∏∞Ìôî
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e); 
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 60);

        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -40, window.innerWidth / 40,
            window.innerHeight / 40, window.innerHeight / -40,
            1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);
        camera.zoom = 1.2;
        camera.updateProjectionMatrix();

        // ÏãúÏûë ÌôîÎ©¥Ïö© Ïπ¥Î©îÎùºÎì§
        const startCam1 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        startCam1.position.set(2, 1.5, 2); startCam1.lookAt(0, 1, 0);
        const startCam2 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        startCam2.position.set(0, 2, 6); startCam2.lookAt(0, 1, 0);
        const startCam3 = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        startCam3.position.set(0, 10, 0); startCam3.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Í∑∏Î¶ºÏûê ÏºúÍ∏∞
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; // Îßµ ÏÇ¨Ïù¥Ï¶à Ï§ÑÏûÑ (ÏµúÏ†ÅÌôî)
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(new THREE.GridHelper(200, 100, 0x444444, 0x333333));

        // ==========================================
        // 2. Î™®Îç∏ Î°úÎî©
        // ==========================================
        const loader = new GLTFLoader();
        const loadedModels = { player: null, maleEnemy: null, femaleEnemy: null, boss: null };

        const playerGroup = new THREE.Group();
        scene.add(playerGroup);
        
        const pGeo = new THREE.BoxGeometry(1, 1, 1);
        const pMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const playerFallback = new THREE.Mesh(pGeo, pMat);
        playerFallback.position.y = 0.5;
        playerFallback.castShadow = true; // ÌîåÎ†àÏù¥Ïñ¥Îäî Í∑∏Î¶ºÏûê Ïº¨
        playerGroup.add(playerFallback);

        // ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†•Î∞î (3D)
        const playerHpBarGroup = create3DHpBar('player');
        playerHpBarGroup.position.y = 2.0;
        playerHpBarGroup.visible = false;
        playerGroup.add(playerHpBarGroup);

        let playerMixer;
        loader.load('./player.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(1, 1, 1);
            model.traverse(o => { if(o.isMesh) o.castShadow = true; });
            playerGroup.remove(playerFallback);
            playerGroup.add(model);
            playerMixer = new THREE.AnimationMixer(model);
            if(gltf.animations.length > 0) playerMixer.clipAction(gltf.animations[0]).play();
        }, undefined, () => console.log('Player model not found. Using box.'));

        loader.load('./male_enemy.glb', (gltf) => { loadedModels.maleEnemy = gltf; }, undefined, () => {});
        loader.load('./female_enemy.glb', (gltf) => { loadedModels.femaleEnemy = gltf; }, undefined, () => {});

        // ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏
        const mistGeo = new THREE.RingGeometry(0.5, 4, 32);
        const mistMat = new THREE.MeshBasicMaterial({ color: 0x800080, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
        const mistMesh = new THREE.Mesh(mistGeo, mistMat);
        mistMesh.rotation.x = -Math.PI / 2;
        mistMesh.position.y = 0.1;
        playerGroup.add(mistMesh);

        // ==========================================
        // 3. Í≤åÏûÑ ÏÉÅÌÉú
        // ==========================================
        const gameState = {
            gameStarted: false, isPlaying: true, isPaused: false, time: 0,
            level: 1, exp: 0, maxExp: 10, kills: 0,
            hp: 100, maxHp: 100, bombs: 1, bombTimer: 0, quoteChance: 0,
            cameraIndex: 0, cameraTimer: 0
        };
        const BOMB_COOLDOWN_TIME = 300; 
        const playerStats = { moveSpeed: 0.15, damageMult: 1.0, pickupRange: 3.0, luck: 1.0, attackSpeed: 1.0 };
        const inventory = {
            qrBeam: { level: 1, active: true, name: "QRÏΩîÎìú Îπî", type: "weapon", cooldown: 0.8, lastShot: 0, damage: 10 },
            nftContract: { level: 0, active: true, name: "NFT Í≥ÑÏïΩÏÑú", type: "passive", desc: "Ï¶âÏÇ¨/Î≥¥Ïä§ÌîºÌï¥", throwChance: 0.01, bossDmgRate: 0.10 },
            mist: { level: 0, active: false, name: "ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏", type: "weapon", cooldown: 0.5, lastTick: 0, damage: 3, range: 4 },
            chunjat: { level: 0, active: false, name: "Ï∂òÏû£", type: "passive", effect: "speed", val: 0.05 },
            movingMan: { level: 0, active: false, name: "Î¨¥ÎπôÎß®", type: "passive", effect: "haste", val: 0.1 }, 
            clover: { level: 0, active: false, name: "ÌñâÏö¥Ïùò ÌÅ¥Î°úÎ≤Ñ", type: "passive", effect: "might", val: 0.2 }
        };

        const enemies = [];
        const projectiles = [];
        const enemyProjectiles = []; 
        const gems = [];
        const minchos = []; 
        const keys = { w:false, a:false, s:false, d:false, ArrowUp:false, ArrowLeft:false, ArrowDown:false, ArrowRight:false, " ": false };
        const deathQuotes = { female: ["Ïó¨ÏûêÎäî ÏïàÎêòÎÇòÏöî", "Í≤∏ÏÉÅÌï¥Ïöî"], male: ["Í≤åÏù¥Ï°∞Ïù¥Í≥†", "Ï£ÑÏÜ°Ìï©ÎãàÎã§", "Îãà.ÎãàÍ≤å Í∑∏Îü∞", "Ïñ¥~~~~~‚ô¨"], boss: ["Ìï¥Í≥†ÎùºÎãà!!", "Ìá¥ÏßÅÍ∏àÏùÄ..?", "ÌöåÏãù.."] };
        const MAX_ENEMIES = 100;

        // ==========================================
        // 4. Í≤åÏûÑ Î°úÏßÅ
        // ==========================================
        window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = true; });
        window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = false; });

        document.getElementById('start-btn').addEventListener('click', () => {
            gameState.gameStarted = true;
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('top-bar').style.opacity = '1';
            document.getElementById('exp-bar-container').style.opacity = '1';
            document.getElementById('level-indicator').style.opacity = '1';
            document.getElementById('ult-guide').style.opacity = '1';
            playerHpBarGroup.visible = true;
        });

        // [ÏµúÏ†ÅÌôî 2] 3D Ï≤¥Î†•Î∞î ÏÉùÏÑ± (DOM ÏïÑÎãò)
        function create3DHpBar(type) {
            const group = new THREE.Group();
            group.userData.isHpBar = true; 
            const bg = new THREE.Mesh(hpBarBgGeo, hpBarBgMat);
            
            let mat = (type === 'player') ? hpBarFgMatGreen : (type === 'boss' ? hpBarFgMatBoss : hpBarFgMatRed);
            let scaleY = (type === 'boss') ? 2 : 1;
            let width = (type === 'boss') ? 3 : 1;

            const fg = new THREE.Mesh(hpBarFgGeo, mat);
            fg.position.x = -0.5 * width; 
            fg.position.z = 0.01;
            
            bg.scale.set(width, scaleY, 1);
            fg.scale.set(width, scaleY, 1); 

            group.add(bg, fg);
            return group;
        }

        function update3DHpBar(mesh, hp, maxHp) {
            const barGroup = mesh.children.find(c => c.userData.isHpBar);
            if (barGroup) {
                const fg = barGroup.children[1];
                const pct = Math.max(0, hp / maxHp);
                fg.scale.x = Math.max(0.001, pct * barGroup.children[0].scale.x); // Î∞∞Í≤Ω ÌÅ¨Í∏∞ Í∏∞Ï§Ä ÎπÑÏú®
                barGroup.lookAt(camera.position.x, 10000, camera.position.z); // ÎπåÎ≥¥Îìú Ï≤òÎ¶¨ (ÎåÄÏ∂© ÏúÑÏ™Ω Î≥¥Í∏∞)
                barGroup.rotation.x = -Math.PI / 2; // ÌÉëÎã§Ïö¥Ïù¥Îùº ÎàïÌûàÍ∏∞
                barGroup.rotation.z = 0;
                barGroup.rotation.y = 0;
            }
        }

        function spawnEnemy(isBoss = false) {
            if (gameState.isPaused) return;
            if (enemies.length >= MAX_ENEMIES && !isBoss) return; 

            const angle = Math.random() * Math.PI * 2;
            const distance = 15 + Math.random() * 10;
            const x = playerGroup.position.x + Math.cos(angle) * distance;
            const z = playerGroup.position.z + Math.sin(angle) * distance;
            
            let type = isBoss ? 'boss' : (Math.random() > 0.7 ? 'female' : 'male');
            let enemyMesh, mixer;

            if (type === 'boss') {
                const geo = new THREE.BoxGeometry(2, 4, 2);
                const mat = new THREE.MeshStandardMaterial({ color: 0xff4400 });
                enemyMesh = new THREE.Mesh(geo, mat);
                enemyMesh.position.y = 2;
            } else {
                let model = (type === 'male') ? loadedModels.maleEnemy : loadedModels.femaleEnemy;
                if (model) {
                    enemyMesh = SkeletonUtils.clone(model.scene);
                    enemyMesh.scale.set(1, 1, 1);
                    if(model.animations.length > 0) { mixer = new THREE.AnimationMixer(enemyMesh); mixer.clipAction(model.animations[0]).play(); }
                } else {
                    // Ìè¥Î∞± Î∞ïÏä§
                    const geo = new THREE.BoxGeometry(1, 1.5, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: type === 'male' ? 0x3366ff : 0xff66cc });
                    enemyMesh = new THREE.Mesh(geo, mat);
                    enemyMesh.position.y = 0.75;
                }
            }
            
            // [ÏµúÏ†ÅÌôî 3] Í∑∏Î¶ºÏûê: Î≥¥Ïä§Îßå ÏºúÍ≥† Ïû°Î™πÏùÄ ÎÅî
            enemyMesh.traverse(o => { if(o.isMesh) o.castShadow = isBoss; });
            
            enemyMesh.position.set(x, isBoss ? 2 : 0, z);
            if (!mixer && type !== 'boss') enemyMesh.position.y = 0.75;

            let hp = 15 + (gameState.time * 0.5);
            if (type === 'female') hp *= 0.7;
            if (type === 'boss') hp = hp * 50 + 500; 

            const hpBar = create3DHpBar(type);
            hpBar.position.y = isBoss ? 2.5 : 2.0;
            // ÎàïÌûàÍ∏∞ (ÌÉëÎ∑∞ÏóêÏÑú Ïûò Î≥¥Ïù¥Í≤å)
            hpBar.rotation.x = -Math.PI / 2;
            enemyMesh.add(hpBar);

            enemyMesh.userData = { type: type, hp: hp, maxHp: hp, speed: type === 'boss' ? 0.03 : (type === 'female' ? 0.04 : 0.05), attackCooldown: 0, mixer: mixer, isBoss: isBoss };
            scene.add(enemyMesh);
            enemies.push(enemyMesh);
        }

        // [ÏµúÏ†ÅÌôî 4] Îç∞ÎØ∏ÏßÄ ÌÖçÏä§Ìä∏ Ï†úÌïú
        function createDamageText(position, damage, isMincho = false, isDeathQuote = false) {
            if (!isMincho && !isDeathQuote && activeDamageTextCount > 30) return; // ÎÑàÎ¨¥ ÎßéÏúºÎ©¥ Ïä§ÌÇµ

            const div = document.createElement('div');
            activeDamageTextCount++;
            
            if (isDeathQuote) {
                div.className = 'damage-text death-quote';
                div.innerText = damage; 
            } else if (isMincho) {
                div.className = 'damage-text mincho-text';
                div.innerText = "ÎØºÏ¥à!";
            } else {
                div.className = 'damage-text';
                div.innerText = Math.floor(damage);
            }
            
            _tempVec1.copy(position);
            if(isDeathQuote) _tempVec1.y += 2; 
            
            _tempVec1.project(camera);
            const x = (_tempVec1.x * .5 + .5) * window.innerWidth;
            const y = (-(_tempVec1.y * .5) + .5) * window.innerHeight;
            div.style.left = `${x}px`; div.style.top = `${y}px`;
            
            document.getElementById('damage-layer').appendChild(div);
            setTimeout(() => {
                div.remove();
                activeDamageTextCount--;
            }, isDeathQuote ? 2000 : 800); 
        }

        function spawnGem(position, value) {
            const geo = new THREE.OctahedronGeometry(0.3);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa });
            const gem = new THREE.Mesh(geo, mat);
            gem.position.copy(position); gem.position.y = 0.5; gem.userData = { value: value };
            scene.add(gem); gems.push(gem);
        }

        function spawnMincho(position) {
            const group = new THREE.Group();
            const iceGeo = new THREE.SphereGeometry(0.4, 8, 8); // ÏÑ∏Í∑∏Î®ºÌä∏ Ï§ÑÏûÑ
            const iceMat = new THREE.MeshStandardMaterial({ color: 0x00ffaa });
            const ice = new THREE.Mesh(iceGeo, iceMat);
            group.add(ice);
            group.position.copy(position); group.position.y = 0.5;
            scene.add(group); minchos.push(group);
        }

        function getNearestEnemy() {
            let nearest = null; let minDist = Infinity;
            enemies.forEach(e => {
                const d = playerGroup.position.distanceTo(e.position);
                if (d < minDist) { minDist = d; nearest = e; }
            });
            return { enemy: nearest, dist: minDist };
        }

        function useBomb() {
            if (gameState.bombs <= 0) return;
            gameState.bombs--;
            document.getElementById('bomb-val').innerText = gameState.bombs;
            
            // Ïó≠Ïàú ÏàúÌöåÌïòÎ©∞ ÏÇ≠Ï†ú
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                spawnGem(enemy.position, 1);
                gameState.kills++;
                scene.remove(enemy);
                enemies.splice(i, 1);
            }
            document.getElementById('kill-count').innerText = gameState.kills;
            
            // ÏãúÍ∞Å Ìö®Í≥º Í∞ÑÏÜåÌôî
            const blast = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 }));
            blast.position.copy(playerGroup.position);
            scene.add(blast);
            let scale = 1;
            const iv = setInterval(() => {
                scale += 3; blast.scale.set(scale, scale, scale); blast.material.opacity -= 0.1;
                if (blast.material.opacity <= 0) { clearInterval(iv); scene.remove(blast); }
            }, 30);
        }

        function fireWeapons(delta) {
            const atkSpeed = playerStats.attackSpeed;
            if (inventory.qrBeam.active) {
                inventory.qrBeam.lastShot += delta * atkSpeed; 
                if (inventory.qrBeam.lastShot >= inventory.qrBeam.cooldown) {
                    const info = getNearestEnemy();
                    if (info.enemy && info.dist < 15) { 
                        shootQR(info.enemy); 
                        if (Math.random() < inventory.nftContract.throwChance) throwContract();
                        inventory.qrBeam.lastShot = 0; 
                    }
                }
            }
            if (inventory.mist.active) {
                mistMesh.material.opacity = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                mistMesh.scale.set(inventory.mist.range, inventory.mist.range, 1);
                inventory.mist.lastTick += delta * atkSpeed; 
                if (inventory.mist.lastTick >= inventory.mist.cooldown) {
                    enemies.forEach(e => {
                        if (playerGroup.position.distanceTo(e.position) <= inventory.mist.range) takeDamage(e, inventory.mist.damage * playerStats.damageMult);
                    });
                    inventory.mist.lastTick = 0;
                }
            } else { mistMesh.material.opacity = 0; }
        }

        // [ÏµúÏ†ÅÌôî 1 Ï†ÅÏö©] ÏßÄÏò§Î©îÌä∏Î¶¨ Ïû¨ÏÇ¨Ïö©
        function shootQR(target) {
            const beam = new THREE.Mesh(qrGeo, qrMat);
            beam.position.copy(playerGroup.position); beam.position.y = 1;
            beam.lookAt(target.position.x, 1, target.position.z);
            
            // [ÏµúÏ†ÅÌôî 2 Ï†ÅÏö©] Î≤°ÌÑ∞ Ïû¨ÏÇ¨Ïö©
            _tempVec1.subVectors(target.position, playerGroup.position).normalize();
            
            beam.userData = { velocity: _tempVec1.clone().multiplyScalar(0.4), damage: inventory.qrBeam.damage * playerStats.damageMult, duration: 2, hitList: [] };
            scene.add(beam); projectiles.push(beam);
        }

        function throwContract() {
            const paper = new THREE.Mesh(contractGeo, contractMat);
            paper.position.copy(playerGroup.position); paper.position.y = 1;
            const angle = Math.random() * Math.PI * 2;
            _tempVec1.set(Math.cos(angle), 0, Math.sin(angle)).normalize();
            
            paper.userData = { 
                type: 'contract', velocity: _tempVec1.clone().multiplyScalar(0.3), 
                bossDmgRate: inventory.nftContract.bossDmgRate, duration: 3, pierce: 5, hitList: [] 
            };
            scene.add(paper); projectiles.push(paper);
        }

        function takeDamage(enemy, amount) {
            enemy.userData.hp -= amount;
            createDamageText(enemy.position, amount);
            if (enemy.userData.hp <= 0) {
                if (Math.random() * 100 < gameState.quoteChance && deathQuotes[enemy.userData.type]) {
                    const q = deathQuotes[enemy.userData.type];
                    createDamageText(enemy.position, q[Math.floor(Math.random()*q.length)], false, true);
                }
                spawnGem(enemy.position, enemy.userData.isBoss ? 50 : 1); 
                if (Math.random() < 0.01) spawnMincho(enemy.position);
                gameState.kills++;
                document.getElementById('kill-count').innerText = gameState.kills;
                scene.remove(enemy);
                const idx = enemies.indexOf(enemy);
                if (idx > -1) enemies.splice(idx, 1);
            }
        }

        function damagePlayer(amount) {
            gameState.hp = Math.max(0, gameState.hp - amount);
            document.getElementById('hp-val').innerText = Math.floor(gameState.hp);
            // ÌîºÍ≤© Ìö®Í≥º Îã®ÏàúÌôî (ÏÉâÏÉÅÎßå Î≥ÄÍ≤Ω)
            playerGroup.children.forEach(c => { if(c.material && c.material.emissive) c.material.emissive.setHex(0xff0000); });
            setTimeout(() => playerGroup.children.forEach(c => { if(c.material && c.material.emissive) c.material.emissive.setHex(0x000000); }), 100);
            if (gameState.hp <= 0) gameOver();
        }

        function checkLevelUp() {
            if (gameState.exp >= gameState.maxExp) {
                gameState.exp -= gameState.maxExp;
                gameState.level++;
                gameState.maxExp = Math.floor(gameState.maxExp * 1.5);
                document.getElementById('level-val').innerText = gameState.level;
                showLevelUpModal();
            }
            document.getElementById('exp-bar').style.width = `${(gameState.exp / gameState.maxExp) * 100}%`;
        }

        function showLevelUpModal() {
            gameState.isPaused = true;
            const modal = document.getElementById('levelup-modal');
            const container = document.getElementById('upgrade-cards');
            container.innerHTML = '';
            modal.style.display = 'flex';
            const options = [
                { key: 'qrBeam', title: 'QRÏΩîÎìú Îπî', desc: 'Í≥µÍ≤©Î†•/ÏÜçÎèÑ Ï¶ùÍ∞Ä', icon: 'üì±' },
                { key: 'nftContract', title: 'NFT Í≥ÑÏïΩÏÑú', desc: 'Ï¶âÏÇ¨ ÌôïÎ•† Ï¶ùÍ∞Ä', icon: 'üìÑ' },
                { key: 'mist', title: 'ÌÉÄÏßÄÎ¶¨ ÎØ∏Ïä§Ìä∏', desc: 'ÎèÖÍµ¨Î¶Ñ Í∞ïÌôî', icon: '‚ò†Ô∏è' },
                { key: 'chunjat', title: 'Ï∂òÏû£', desc: 'Ïù¥Îèô ÏÜçÎèÑ Ï¶ùÍ∞Ä', icon: 'üå∞' },
                { key: 'movingMan', title: 'Î¨¥ÎπôÎß®', desc: 'Í≥µÍ≤© ÏÜçÎèÑ Ï¶ùÍ∞Ä', icon: 'üèÉ' },
                { key: 'clover', title: 'ÌñâÏö¥Ïùò ÌÅ¥Î°úÎ≤Ñ', desc: 'Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä', icon: 'üçÄ' }
            ];
            options.sort(() => Math.random() - 0.5);
            options.slice(0, 3).forEach(opt => {
                const item = inventory[opt.key];
                let btnText = item.level === 0 ? "Ïã†Í∑ú ÏäµÎìù" : `Lv.${item.level} -> Lv.${item.level+1}`;
                if (item.type === 'passive') btnText = "Í∞ïÌôî";
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `<div class="card-icon">${opt.icon}</div><div class="card-name">${opt.title}</div><div class="card-desc">${opt.desc}</div><div class="card-level">${btnText}</div>`;
                card.onclick = () => { applyUpgrade(opt.key); modal.style.display = 'none'; gameState.isPaused = false; };
                container.appendChild(card);
            });
        }

        function applyUpgrade(key) {
            const item = inventory[key];
            item.active = true; item.level++;
            if (key === 'qrBeam') { item.damage += 5; item.cooldown *= 0.9; }
            else if (key === 'nftContract') { item.throwChance = Math.min(0.05, 0.01 * (item.level + 1)); item.bossDmgRate = Math.min(0.25, 0.10 + (item.level * 0.03)); }
            else if (key === 'mist') { item.damage += 2; item.range += 0.5; }
            else if (key === 'chunjat') { playerStats.moveSpeed += item.val; }
            else if (key === 'movingMan') { playerStats.attackSpeed += item.val; } 
            else if (key === 'clover') { playerStats.damageMult += item.val; }
        }

        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('final-time').innerText = document.getElementById('timer').innerText;
            document.getElementById('final-kills').innerText = gameState.kills;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        const clock = new THREE.Clock();
        setInterval(() => {
            if (!gameState.gameStarted || !gameState.isPlaying || gameState.isPaused) return;
            const spawnCount = 2 + Math.floor(gameState.time / 20); 
            for(let i=0; i<spawnCount; i++) spawnEnemy();
            if (gameState.time > 0 && gameState.time % 60 === 0) spawnEnemy(true);
            gameState.time++;
            if (gameState.time % 10 === 0) gameState.quoteChance = Math.min(20, gameState.quoteChance + 1);
            const m = Math.floor(gameState.time / 60).toString().padStart(2, '0');
            const s = (gameState.time % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (!gameState.gameStarted) {
                if (playerMixer) playerMixer.update(delta);
                playerGroup.rotation.y += delta * 0.5;
                gameState.cameraTimer += delta;
                if (gameState.cameraTimer >= 3.0) {
                    gameState.cameraTimer = 0;
                    document.getElementById(`cam-label-${gameState.cameraIndex}`).classList.remove('cam-active');
                    gameState.cameraIndex = (gameState.cameraIndex + 1) % 3;
                    document.getElementById(`cam-label-${gameState.cameraIndex}`).classList.add('cam-active');
                }
                const cams = [startCam1, startCam2, startCam3];
                renderer.render(scene, cams[gameState.cameraIndex]);
                return;
            }

            if (!gameState.isPlaying || gameState.isPaused) return;

            if (keys[' ']) { useBomb(); keys[' '] = false; }
            gameState.bombTimer += delta;
            if (gameState.bombTimer >= BOMB_COOLDOWN_TIME) { gameState.bombs++; gameState.bombTimer = 0; document.getElementById('bomb-val').innerText = gameState.bombs; }
            const bombPct = Math.min(100, Math.floor((gameState.bombTimer / BOMB_COOLDOWN_TIME) * 100));
            document.getElementById('bomb-cooldown').innerText = `(${bombPct}%)`;

            _tempVec1.set(0,0,0);
            if (keys.w || keys.ArrowUp) _tempVec1.z -= 1;
            if (keys.s || keys.ArrowDown) _tempVec1.z += 1;
            if (keys.a || keys.ArrowLeft) _tempVec1.x -= 1;
            if (keys.d || keys.ArrowRight) _tempVec1.x += 1;

            if (_tempVec1.length() > 0) {
                _tempVec1.normalize().multiplyScalar(playerStats.moveSpeed);
                playerGroup.position.add(_tempVec1);
                const targetRot = Math.atan2(_tempVec1.x, _tempVec1.z);
                if(playerMixer) playerGroup.children.forEach(c => { if(c.isGroup) c.rotation.y = targetRot; });
            }

            camera.position.x = playerGroup.position.x + 20;
            camera.position.z = playerGroup.position.z + 20;
            dirLight.position.x = playerGroup.position.x + 10;
            dirLight.position.z = playerGroup.position.z + 10;
            ground.position.x = playerGroup.position.x;
            ground.position.z = playerGroup.position.z;

            fireWeapons(delta);
            if (playerMixer) playerMixer.update(delta);

            update3DHpBar(playerHpBarGroup, gameState.hp, gameState.maxHp); 

            // Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.velocity);
                if (p.userData.type === 'contract') p.rotation.y += 0.2;
                p.userData.duration -= delta;
                if (p.userData.duration <= 0) { scene.remove(p); projectiles.splice(i, 1); continue; }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    // [ÏµúÏ†ÅÌôî] 2D Í±∞Î¶¨ Ï≤¥ÌÅ¨ (Ï†úÍ≥±)
                    const dx = p.position.x - enemy.position.x;
                    const dz = p.position.z - enemy.position.z;
                    const distSq = dx*dx + dz*dz;
                    
                    if (distSq < 2.25) { // 1.5 * 1.5
                        if (p.userData.hitList && p.userData.hitList.includes(enemy.id)) continue;
                        let damage = p.userData.damage;
                        if (p.userData.type === 'contract') damage = enemy.userData.isBoss ? enemy.userData.maxHp * p.userData.bossDmgRate : enemy.userData.hp;
                        takeDamage(enemy, damage);
                        if (p.userData.hitList) p.userData.hitList.push(enemy.id);
                        if (p.userData.type !== 'contract') { scene.remove(p); projectiles.splice(i, 1); break; }
                        else if (p.userData.hitList.length >= p.userData.pierce) { scene.remove(p); projectiles.splice(i, 1); break; }
                    }
                }
            }

            // Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
            enemies.forEach(enemy => {
                update3DHpBar(enemy, enemy.userData.hp, enemy.userData.maxHp);
                if (enemy.userData.mixer) enemy.userData.mixer.update(delta);
                
                const distToPlayer = enemy.position.distanceTo(playerGroup.position);
                _tempVec2.subVectors(playerGroup.position, enemy.position).normalize();

                if (enemy.userData.type === 'male' || enemy.userData.type === 'boss') {
                    enemy.position.add(_tempVec2.multiplyScalar(enemy.userData.speed));
                    if (distToPlayer < (enemy.userData.isBoss ? 2.5 : 0.8)) damagePlayer(enemy.userData.isBoss ? 5 : 0.5);
                } else {
                    if (distToPlayer > 8) enemy.position.add(_tempVec2.multiplyScalar(enemy.userData.speed));
                }
                enemy.lookAt(playerGroup.position);
            });

            // ÏïÑÏù¥ÌÖú ÏäµÎìù
            for (let i = gems.length - 1; i >= 0; i--) {
                const gem = gems[i];
                if (playerGroup.position.distanceTo(gem.position) < playerStats.pickupRange) {
                    _tempVec2.subVectors(playerGroup.position, gem.position).normalize();
                    gem.position.add(_tempVec2.multiplyScalar(0.3));
                    if (playerGroup.position.distanceTo(gem.position) < 0.5) { 
                        gameState.exp += gem.userData.value; scene.remove(gem); gems.splice(i, 1); checkLevelUp(); 
                    }
                } else gem.rotation.y += 0.05;
            }
            for (let i = minchos.length - 1; i >= 0; i--) {
                const m = minchos[i];
                if (playerGroup.position.distanceTo(m.position) < playerStats.pickupRange) {
                    _tempVec2.subVectors(playerGroup.position, m.position).normalize();
                    m.position.add(_tempVec2.multiplyScalar(0.3));
                    if (playerGroup.position.distanceTo(m.position) < 0.5) { 
                        gameState.bombs++; document.getElementById('bomb-val').innerText = gameState.bombs;
                        createDamageText(playerGroup.position, 0, true); 
                        scene.remove(m); minchos.splice(i, 1); 
                    }
                } else m.rotation.y += 0.05;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 40;
            camera.left = -viewSize * aspect; camera.right = viewSize * aspect;
            camera.top = viewSize; camera.bottom = -viewSize;
            camera.updateProjectionMatrix();
            startCam1.aspect = window.innerWidth / window.innerHeight; startCam1.updateProjectionMatrix();
            startCam2.aspect = window.innerWidth / window.innerHeight; startCam2.updateProjectionMatrix();
            startCam3.aspect = window.innerWidth / window.innerHeight; startCam3.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>