<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>전설의 전학생: 임혁 (Polygon Remaster)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            background-color: #050505;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.9);
            border: 4px solid #333;
        }

        canvas {
            display: block;
            background: #000;
            image-rendering: pixelated; 
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 15px;
            box-sizing: border-box;
            font-family: 'Black Han Sans', sans-serif;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
        }

        .bar-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .bar-label {
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 3px;
            color: #fff;
        }

        /* 체력바 */
        .hp-bar {
            width: 250px;
            height: 20px;
            background-color: #330000;
            border: 2px solid white;
            position: relative;
            box-shadow: 2px 2px 0 #000;
        }

        .hp-fill {
            width: 100%;
            height: 100%;
            background-color: #f1c40f;
            transition: width 0.1s;
        }

        /* 기 게이지 (SP) */
        .sp-bar {
            width: 200px;
            height: 8px;
            background-color: #002233;
            border: 1px solid #aaa;
            position: relative;
            box-shadow: 1px 1px 0 #000;
        }

        .sp-fill {
            width: 0%;
            height: 100%;
            background-color: #00ccff;
            transition: width 0.1s;
        }

        /* SP 가득 찼을 때 이펙트 */
        .sp-bar.max-charge {
            border-color: #00ffff;
            box-shadow: 0 0 8px #00ffff;
            animation: pulse-glow 0.5s infinite alternate;
        }
        
        @keyframes pulse-glow {
            from { box-shadow: 0 0 5px #00ffff; }
            to { box-shadow: 0 0 15px #00ffff, 0 0 5px white; }
        }

        #stage-indicator {
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
        }

        #boss-hp-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            display: none;
        }

        #boss-hp-container .hp-bar {
            width: 100%;
            height: 25px;
            border: 3px solid #fff;
        }
        
        #boss-hp-container .hp-fill {
            background-color: #8e44ad;
        }

        #boss-name {
            text-align: center;
            font-size: 24px;
            color: #e74c3c;
            margin-bottom: 8px;
            text-shadow: 3px 3px 0 #000;
        }

        #controls {
            margin-top: 10px;
            font-family: 'Black Han Sans', sans-serif;
            text-align: center;
            color: #aaa;
            font-size: 13px;
            line-height: 1.6;
        }

        .key {
            display: inline-block;
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #666;
            color: #fff;
            font-family: monospace;
            font-weight: bold;
        }
        
        .skill-list {
            color: #f39c12;
            margin-top: 5px;
        }

        #message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            line-height: 1.5;
            white-space: pre-line;
            z-index: 10;
            display: none;
            text-shadow: 4px 4px 0 #000;
        }
        
        .msg-title { font-size: 40px; color: #fff; margin-bottom: 20px; }
        .msg-sub { font-size: 20px; color: #f1c40f; }
        
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 30;
            backdrop-filter: blur(2px);
        }

        .pause-text {
            font-size: 40px;
            color: #fff;
            letter-spacing: 5px;
            text-shadow: 0 0 10px #fff;
            margin-bottom: 20px;
        }

        .pause-sub {
            font-size: 16px;
            color: #aaa;
        }
        
        #fade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 1;
            transition: opacity 1s;
            pointer-events: none;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="450"></canvas>
        <div id="ui-layer">
            <div class="hud-top">
                <div class="bar-container">
                    <div class="bar-label">IM HYUK</div>
                    <!-- HP Bar -->
                    <div class="hp-bar"><div class="hp-fill" id="player-hp"></div></div>
                    <!-- SP Bar -->
                    <div class="sp-bar" id="sp-bar-frame"><div class="sp-fill" id="player-sp"></div></div>
                </div>
                <div id="stage-indicator">STAGE 1-1</div>
            </div>
            
            <div id="boss-hp-container">
                <div id="boss-name">BOSS</div>
                <div class="hp-bar"><div class="hp-fill" id="boss-hp"></div></div>
            </div>

            <div id="message">
                <div class="msg-title" id="msg-title"></div>
                <div class="msg-sub" id="msg-sub"></div>
            </div>
            
            <div id="pause-overlay">
                <div class="pause-text">PAUSED</div>
                <div class="pause-sub">Click to Resume</div>
            </div>

            <div id="fade-overlay"></div>
        </div>
    </div>

    <div id="controls">
        <span class="key">↑↓←→</span> 이동 (더블탭: 대시) &nbsp;|&nbsp; 
        <span class="key">Z</span> 펀치 &nbsp;|&nbsp; 
        <span class="key">X</span> 킥 &nbsp;|&nbsp; 
        <span class="key">C</span> 점프<br>
        <div class="skill-list">
            [기술] <span class="key">↓</span>+<span class="key">Z</span> 어퍼컷 &nbsp;|&nbsp; 
            <span class="key">↓</span>+<span class="key">X</span> 회전차기 &nbsp;|&nbsp; 
            <span class="key">대시</span>+<span class="key">Z</span> 어깨치기 &nbsp;|&nbsp; 
            <span class="key">대시</span>+<span class="key">X</span> 슬라이딩<br>
            [필살기] <span class="key">기 MAX</span> + <span class="key">Z</span>+<span class="key">X</span> 기폭발
        </div>
    </div>

<script>
/**
 * 5-Chapter Beat 'em up Engine - Pure HTML/JS Version
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiPlayerHp = document.getElementById('player-hp');
const uiPlayerSp = document.getElementById('player-sp');
const uiSpFrame = document.getElementById('sp-bar-frame');
const uiBossHpContainer = document.getElementById('boss-hp-container');
const uiBossHp = document.getElementById('boss-hp');
const uiBossName = document.getElementById('boss-name');
const uiStageInd = document.getElementById('stage-indicator');
const uiMessage = document.getElementById('message');
const uiMsgTitle = document.getElementById('msg-title');
const uiMsgSub = document.getElementById('msg-sub');
const uiFade = document.getElementById('fade-overlay');
const uiPause = document.getElementById('pause-overlay');

// 게임 상수
const GRAVITY = 0.6;
const GROUND_Y_MIN = 220;
const GROUND_Y_MAX = 430;

// 입력 처리
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    z: false, x: false, c: false
};
let lastKey = null;
let lastKeyTime = 0;

window.addEventListener('keydown', (e) => {
    if (e.repeat) return; // 키 반복 입력 방지 (필요 시)

    // 게임오버 시 재시작
    if (game.state === 'gameover') {
        game.restart();
        return;
    }

    // 일시정지 상태면 키 입력 무시
    if (game.paused) return;

    const key = e.key.toLowerCase();
    if (keys.hasOwnProperty(key) || key.startsWith('arrow')) keys[e.key] = true;

    // 필살기 감지 (Z + X)
    if (keys.z && keys.x) {
        player.inputAttack('special');
        return;
    }

    if (key === 'z') player.inputAttack('punch');
    if (key === 'x') player.inputAttack('kick');
    if (key === 'c') player.inputJump();

    // 대시 (더블탭)
    if (key.startsWith('arrow')) {
        const now = Date.now();
        if (lastKey === key && now - lastKeyTime < 250) player.isDashing = true;
        lastKey = key;
        lastKeyTime = now;
    }
});

window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if (keys.hasOwnProperty(key) || key.startsWith('arrow')) keys[e.key] = false;
    
    if (player.isDashing) {
        if ((key === 'arrowleft' && player.direction === -1) || 
            (key === 'arrowright' && player.direction === 1)) {
            player.isDashing = false;
        }
    }
});

// 화면 이탈 시 일시정지 처리
window.addEventListener('blur', () => {
    if (game.state === 'playing') {
        game.paused = true;
        uiPause.style.display = 'flex';
    }
});

// 일시정지 화면 클릭 시 재개
uiPause.addEventListener('click', () => {
    game.paused = false;
    uiPause.style.display = 'none';
});

// 유틸리티: 다각형 그리기 함수
function drawPoly(ctx, points, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for(let i=1; i<points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    ctx.fill();
}

function checkCollision(r1, r2) {
    const depthTolerance = 15; 
    return (
        Math.abs(r1.x - r2.x) < (r1.width + r2.width) / 2 && 
        Math.abs((r1.y + r1.z) - (r2.y + r2.z)) < (r1.height + r2.height) / 2 && 
        Math.abs(r1.y - r2.y) < depthTolerance 
    );
}

// 챕터 설정
const LEVEL_CONFIG = {
    1: { title: "학교 뒷골목", subtitle: "등굣길의 불청객들", length: 2000, enemyTypes: ['bully', 'bully', 'bully2'], boss: 'boss_ch1', bgTheme: 'alley', groundColor: '#34495e', skyColor: ['#2c3e50', '#e67e22'] },
    2: { title: "학교 옥상", subtitle: "일진들의 아지트", length: 2200, enemyTypes: ['iljin_grey', 'iljin_grey', 'iljin_mask'], boss: 'boss_ch2', bgTheme: 'rooftop', groundColor: '#27ae60', skyColor: ['#2980b9', '#87ceeb'] },
    3: { title: "폐공장", subtitle: "타학교 놈들의 구역", length: 2400, enemyTypes: ['rival_blue', 'rival_blue', 'rival_big'], boss: 'boss_ch3', bgTheme: 'factory', groundColor: '#555', skyColor: ['#111', '#333'] },
    4: { title: "유흥가 뒷편", subtitle: "위험한 거리", length: 2500, enemyTypes: ['thug_denim', 'thug_bandana'], boss: 'boss_ch4', bgTheme: 'street', groundColor: '#2c3e50', skyColor: ['#000', '#1a0033'] },
    5: { title: "조폭 아지트", subtitle: "최후의 결전", length: 1500, enemyTypes: ['suit', 'suit_guard'], boss: 'boss_ch5', bgTheme: 'hideout', groundColor: '#4a1010', skyColor: ['#000', '#000'] }
};

// 엔티티
class Entity {
    constructor(x, y, width, height, type) {
        this.x = x; this.y = y; this.z = 0; 
        this.width = width; this.height = height; this.type = type; 
        
        this.vx = 0; this.vy = 0; this.vz = 0;
        this.speed = 3;
        this.direction = 1; 
        
        this.state = 'idle';
        this.maxHp = 100; this.hp = 100;
        
        this.hitStun = 0; this.invincible = 0; this.flash = 0;
        this.frameTimer = 0;
        this.opacity = 1.0;
        this.animFrame = 0;
    }

    update() {
        this.animFrame++; 

        if (this.state === 'dead') return;

        if (this.state === 'dying') {
            if (this.z <= 0) {
                this.z = 0; this.vz = 0; this.vx *= 0.8;
                this.frameTimer++;
                if (this.frameTimer > 60) {
                    this.opacity -= 0.05;
                    if (this.opacity <= 0) this.state = 'dead';
                }
            } else {
                this.z += this.vz; this.vz -= GRAVITY; this.x += this.vx;
            }
            return;
        }

        if (this.hitStun > 0) { this.hitStun--; return; }
        if (this.invincible > 0) this.invincible--;
        if (this.flash > 0) this.flash--;

        if (this.z > 0 || this.vz !== 0) {
            this.z += this.vz; this.vz -= GRAVITY;
            if (this.z <= 0) {
                this.z = 0; this.vz = 0;
                if (['jump','jumpkick','jump_smash'].includes(this.state)) this.state = 'idle';
            }
        }

        const attacks = ['punch', 'kick', 'uppercut', 'jumpkick', 'spinkick', 'dashpunch', 'dashkick', 'special'];
        if (attacks.includes(this.state)) {
            // 스킬 사용 시 움직임 제어
            if (this.state === 'dashpunch' || this.state === 'dashkick') {
                this.x += this.vx; 
                this.vx *= 0.9;
            } else if (this.state === 'jumpkick') {
                 // 공중 공격은 관성 유지
                 this.x += this.vx;
            } else { 
                // [중요] 제자리 기술은 위치 고정
                this.vx = 0; 
            }

            this.frameTimer++;
            
            let duration = 15;
            if (this.state === 'uppercut') duration = 25;
            if (this.state === 'spinkick') duration = 20;
            if (this.state === 'special') duration = 40; 
            if (this.state === 'dashpunch') duration = 20;
            if (this.state === 'dashkick') duration = 25;

            if (this.frameTimer > duration) this.state = this.z > 0 ? 'jump' : 'idle';
        } else if (this.state === 'hit') {
            this.frameTimer++;
            if (this.frameTimer > 20) this.state = 'idle';
        }
    }

    takeDamage(damage, attackerX, type = 'normal') {
        if (this.invincible > 0 || this.state === 'dying' || this.state === 'dead') return;
        if (this.state === 'special') return; 

        this.hp -= damage;
        this.hitStun = 12; this.flash = 10; 
        
        if (this.hp <= 0) {
            this.state = 'dying';
            this.frameTimer = 0;
            this.vz = 6; this.vx = (this.x < attackerX ? -4 : 4);
            game.shakeScreen(10);
        } else {
            this.state = 'hit';
            this.vx = 0;
            if (type === 'launch') { this.vz = 10; this.hitStun = 30; }
            if (type === 'knockdown') { this.vz = 5; this.hitStun = 20; }
            const knockback = (type === 'heavy' || type === 'knockdown') ? 30 : 10;
            this.x += (this.x < attackerX ? -knockback : knockback);
            game.shakeScreen(type === 'heavy' ? 6 : 3);
        }
    }

    drawShadow(ctx) {
        if(this.state === 'dead') return;
        ctx.globalAlpha = this.opacity * 0.4;
        ctx.fillStyle = 'black';
        ctx.beginPath();
        const s = Math.max(0.5, 1 - this.z / 200); 
        ctx.ellipse(this.x, this.y, (this.width / 2) * s, (this.width / 4) * s, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Player extends Entity {
    constructor() {
        super(100, 350, 40, 85, 'player');
        this.maxHp = 300; this.hp = 300;
        
        this.maxSp = 100; this.sp = 0;

        this.comboCount = 0; this.lastAttackTime = 0;
        this.isDashing = false;
    }

    update() {
        if (this.sp < this.maxSp) {
            this.sp += 0.05;
        } else {
            this.sp = this.maxSp;
        }

        super.update();
        if (['dying', 'dead', 'hit', 'punch', 'kick', 'uppercut', 'jumpkick', 'spinkick', 'dashpunch', 'dashkick', 'special'].includes(this.state)) return;

        let moving = false;
        const currentSpeed = this.isDashing ? this.speed * 2.2 : this.speed;

        if (keys.ArrowUp && this.y > GROUND_Y_MIN) { this.y -= currentSpeed; moving = true; }
        if (keys.ArrowDown && this.y < GROUND_Y_MAX) { this.y += currentSpeed; moving = true; }
        if (keys.ArrowLeft && this.x > game.cameraX) { 
            this.x -= currentSpeed; this.direction = -1; moving = true; 
        }
        if (keys.ArrowRight) { 
            if (this.x < game.cameraX + canvas.width - 20) {
                this.x += currentSpeed; this.direction = 1; moving = true; 
            }
        }

        if (moving && this.z === 0) this.state = this.isDashing ? 'run' : 'walk';
        else if (this.z === 0) { this.state = 'idle'; this.isDashing = false; }
        else this.state = 'jump';
    }

    inputJump() {
        if (['idle','walk','run'].includes(this.state)) {
            this.vz = 14; this.state = 'jump';
        }
    }

    inputAttack(type) {
        if (['dying', 'dead', 'hit'].includes(this.state)) return;

        if (this.z > 0) {
            if (type === 'kick') {
                this.state = 'jumpkick';
                this.frameTimer = 0;
                this.vx = this.direction * 5;
                this.checkAttackHit(40, 'kick');
            }
            return;
        }

        if (['punch', 'kick', 'uppercut', 'spinkick', 'dashpunch', 'dashkick', 'special'].includes(this.state)) return;

        this.vx = 0; this.frameTimer = 0;

        // 1. 필살기 (SP 소모)
        if (type === 'special') {
            if (this.sp < this.maxSp) return; // 기 부족
            
            this.sp = 0; // 기 소모
            this.state = 'special';
            game.shakeScreen(30);
            this.checkAttackHit(80, 'knockdown'); // 매우 강력하고 광역
            return;
        }

        // 2. 하단 기술
        if (keys.ArrowDown) {
            if (type === 'punch') {
                this.state = 'uppercut';
                this.checkAttackHit(40, 'launch');
            } else if (type === 'kick') {
                this.state = 'spinkick';
                this.checkAttackHit(35, 'heavy'); 
            }
            return;
        }

        // 3. 대시 기술
        if (this.isDashing) {
            if (type === 'punch') {
                this.state = 'dashpunch';
                this.vx = this.direction * 8; 
                this.checkAttackHit(40, 'heavy');
            } else if (type === 'kick') {
                this.state = 'dashkick';
                this.vx = this.direction * 10; 
                this.checkAttackHit(30, 'knockdown');
            }
            return;
        }

        // 4. 일반 콤보
        const now = Date.now();
        if (now - this.lastAttackTime < 700) this.comboCount = (this.comboCount + 1) % 3;
        else this.comboCount = 0;
        this.lastAttackTime = now;

        if (type === 'punch') {
            this.state = 'punch';
            const isFinisher = this.comboCount === 2;
            this.checkAttackHit(isFinisher ? 30 : 15, isFinisher ? 'heavy' : 'normal');
        } else if (type === 'kick') {
            this.state = 'kick';
            this.checkAttackHit(25, 'heavy');
        }
    }

    checkAttackHit(damage, type) {
        let rangeW = 60, rangeH = 50, offsetX = 30;
        
        if (this.state === 'kick') { rangeW = 80; offsetX = 40; }
        if (this.state === 'jumpkick') { rangeW = 70; offsetX = 35; }
        if (this.state === 'uppercut') { rangeW = 50; rangeH = 80; }
        if (this.state === 'dashpunch') { rangeW = 70; offsetX = 40; }
        if (this.state === 'dashkick') { rangeW = 90; rangeH = 30; offsetX = 40; }
        
        if (this.state === 'spinkick') {
            rangeW = 120; offsetX = 0; 
        }
        if (this.state === 'special') {
            rangeW = 400; rangeH = 300; offsetX = 0; // 화면 전체급
        }

        const attackBox = {
            x: this.x + (this.direction * offsetX),
            y: this.y, z: this.z,
            width: rangeW, height: rangeH
        };

        let hit = false;
        game.enemies.forEach(enemy => {
            if (checkCollision(attackBox, enemy)) {
                if (this.state === 'uppercut') type = 'launch';
                if (this.comboCount === 2 && type === 'normal') { damage += 15; type = 'heavy'; }
                enemy.takeDamage(damage, this.x, type);
                hit = true;
                
                // 타격 시 기 회복 (필살기 제외)
                if (this.state !== 'special') {
                    this.sp = Math.min(this.maxSp, this.sp + 5);
                }
            }
        });

        if (this.state === 'special' && hit) {
             // 이펙트 추가 가능
        }
    }

    draw(ctx) {
        this.drawShadow(ctx);
        const dx = this.x; 
        const dy = this.y - this.z - 110;
        
        ctx.save();
        if (this.flash > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
            ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = 'white';
        }

        ctx.translate(dx, dy + 40);
        ctx.scale(this.direction, 1);

        let armAngle = 0;
        let legAngle = 0;
        let bodyRot = 0;

        const time = this.animFrame * 0.2;
        
        if (this.state === 'walk') {
            legAngle = Math.sin(time) * 0.5;
            armAngle = -Math.sin(time) * 0.5;
        } else if (this.state === 'run') {
            legAngle = Math.sin(time * 2) * 0.8;
            armAngle = -Math.sin(time * 2) * 1.0;
            bodyRot = 0.2; 
        } else if (this.state === 'punch') {
            armAngle = -1.5; bodyRot = -0.1;
        } else if (this.state === 'kick') {
            bodyRot = -0.3;
        } else if (this.state === 'uppercut') {
            armAngle = -2.5; 
        } else if (this.state === 'spinkick') {
            bodyRot = this.animFrame * 1.0; 
        } else if (this.state === 'dashpunch') {
            bodyRot = 0.4; armAngle = -1.5;
        } else if (this.state === 'special') {
            ctx.translate(Math.random()*2, Math.random()*2);
        }

        ctx.rotate(bodyRot);

        // 1. 뒷다리
        ctx.save();
        ctx.translate(-5, 30);
        if(this.state === 'kick') ctx.rotate(0.2); 
        else if(this.state === 'jump') ctx.rotate(0.5);
        else ctx.rotate(-legAngle);
        drawPoly(ctx, [{x:-4,y:0}, {x:4,y:0}, {x:3,y:18}, {x:-3,y:18}], '#111');
        ctx.translate(0, 18); 
        if(this.state === 'run') ctx.rotate(0.5);
        drawPoly(ctx, [{x:-3,y:0}, {x:3,y:0}, {x:2,y:20}, {x:-2,y:20}, {x:-5, y:22}], '#111'); 
        ctx.restore();

        // 2. 뒷팔
        ctx.save();
        ctx.translate(8, -15);
        ctx.rotate(-armAngle * 0.8);
        drawPoly(ctx, [{x:-3,y:0}, {x:3,y:0}, {x:2,y:15}, {x:-2,y:15}], '#ddd'); 
        ctx.translate(0, 15);
        drawPoly(ctx, [{x:-2,y:0}, {x:2,y:0}, {x:2,y:12}, {x:-2,y:12}], '#ffccaa');
        ctx.restore();

        // 3. 몸통
        drawPoly(ctx, [{x:-10,y:-20}, {x:10,y:-20}, {x:7,y:30}, {x:-7,y:30}], '#fff');
        drawPoly(ctx, [{x:-2,y:-18}, {x:2,y:-18}, {x:1,y:0}, {x:-1,y:0}], '#333');

        // 4. 머리
        ctx.save();
        ctx.translate(0, -22);
        drawPoly(ctx, [{x:-7,y:-10}, {x:7,y:-10}, {x:7,y:5}, {x:0,y:10}, {x:-7,y:5}], '#ffccaa');
        drawPoly(ctx, [{x:-9,y:-12}, {x:9,y:-12}, {x:10,y:-2}, {x:8,y:2}, {x:-8,y:2}, {x:-10,y:-2}], '#000');
        ctx.restore();

        // 5. 앞다리
        ctx.save();
        ctx.translate(5, 30);
        if(this.state === 'kick') { ctx.rotate(-1.5); } 
        else if(this.state === 'dashkick') { ctx.rotate(-1.4); } 
        else if(this.state === 'jump') ctx.rotate(-0.5);
        else ctx.rotate(legAngle);
        drawPoly(ctx, [{x:-4,y:0}, {x:4,y:0}, {x:3,y:18}, {x:-3,y:18}], '#222');
        ctx.translate(0, 18);
        if(this.state === 'run') ctx.rotate(0.5);
        drawPoly(ctx, [{x:-3,y:0}, {x:3,y:0}, {x:2,y:20}, {x:-2,y:20}, {x:-5,y:22}], '#222');
        ctx.restore();

        // 6. 앞팔
        ctx.save();
        ctx.translate(-8, -15);
        ctx.rotate(armAngle);
        drawPoly(ctx, [{x:-3,y:0}, {x:3,y:0}, {x:2,y:15}, {x:-2,y:15}], '#fff'); 
        ctx.translate(0, 15);
        if(this.state !== 'punch' && this.state !== 'uppercut') ctx.rotate(-0.2); 
        drawPoly(ctx, [{x:-2,y:0}, {x:2,y:0}, {x:3,y:12}, {x:-3,y:12}], '#ffccaa'); 
        ctx.translate(0, 12);
        drawPoly(ctx, [{x:-4,y:0}, {x:4,y:0}, {x:3,y:6}, {x:-3,y:6}], '#ffccaa');
        ctx.restore();

        // 필살기 이펙트 (폭발)
        if (this.state === 'special') {
             ctx.fillStyle = `rgba(0, 255, 255, ${Math.random() * 0.7})`;
             ctx.beginPath();
             ctx.arc(0, 0, 100 + Math.random()*50, 0, Math.PI*2);
             ctx.fill();
             
             ctx.strokeStyle = "white";
             ctx.lineWidth = 5;
             ctx.beginPath();
             ctx.moveTo(0,0);
             ctx.lineTo((Math.random()-0.5)*300, (Math.random()-0.5)*300);
             ctx.stroke();
        }

        ctx.restore();
    }
}

class Enemy extends Entity {
    constructor(x, y, subtype) {
        let w = 40, h = 80;
        if (subtype.startsWith('boss')) { w = 70; h = 110; }
        super(x, y, w, h, 'enemy');
        this.subtype = subtype;
        this.attackCooldown = 0;
        this.initStats();
    }

    initStats() {
        this.name = "적";
        this.maxHp = 100;
        this.speed = 1.5;
        this.attackDmg = 5;
        
        switch(this.subtype) {
            case 'bully': this.name="불량배"; this.maxHp=80; this.speed=1.5; this.attackDmg=8; break;
            case 'bully2': this.name="덩치"; this.maxHp=120; this.speed=1.0; this.width=50; this.attackDmg=15; break;
            case 'boss_ch1': this.name="멧돼지"; this.maxHp=400; this.speed=2; this.attackDmg=25; break;
            
            case 'iljin_grey': this.name="일진"; this.maxHp=100; this.speed=2; this.attackDmg=12; break;
            case 'iljin_mask': this.name="복면일진"; this.maxHp=90; this.speed=2.5; this.attackDmg=18; break;
            case 'boss_ch2': this.name="철수 (일진짱)"; this.maxHp=600; this.speed=2.5; this.attackDmg=35; break;
            
            case 'rival_blue': this.name="타학교생"; this.maxHp=130; this.speed=1.8; this.attackDmg=15; break;
            case 'rival_big': this.name="유도부"; this.maxHp=200; this.speed=1.2; this.width=55; this.attackDmg=25; break;
            case 'boss_ch3': this.name="강호 (유도대장)"; this.maxHp=800; this.speed=1.5; this.attackDmg=45; break;
            
            case 'thug_denim': this.name="양아치"; this.maxHp=150; this.speed=2.2; this.attackDmg=20; break;
            case 'thug_bandana': this.name="칼잡이"; this.maxHp=120; this.speed=3.0; this.attackDmg=30; break;
            case 'boss_ch4': this.name="매드독"; this.maxHp=1000; this.speed=2.8; this.attackDmg=55; break;
            
            case 'suit': this.name="조직원"; this.maxHp=180; this.speed=2.0; this.attackDmg=30; break;
            case 'suit_guard': this.name="경호원"; this.maxHp=250; this.speed=1.5; this.width=50; this.attackDmg=40; break;
            case 'boss_ch5': this.name="독사 (BOSS)"; this.maxHp=1500; this.speed=2.0; this.attackDmg=70; break;
        }
        this.hp = this.maxHp;
    }

    update() {
        super.update();
        if (['dying', 'dead', 'hit'].includes(this.state)) return;

        if (this.subtype.startsWith('boss')) { this.updateBossAI(); return; }

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        this.direction = dx > 0 ? 1 : -1;

        if (this.attackCooldown > 0) this.attackCooldown--;

        if (dist < 60 && Math.abs(dy) < 10) { 
            if (this.attackCooldown === 0) this.attack();
        } else if (dist < 600) {
            if (Math.abs(dx) > 40) this.x += (dx > 0 ? 1 : -1) * this.speed;
            if (Math.abs(dy) > 1) this.y += (dy > 0 ? 1 : -1) * (this.speed * 0.7);
            
            this.y = Math.max(GROUND_Y_MIN, Math.min(GROUND_Y_MAX, this.y));
            this.state = 'walk';
        } else {
            this.state = 'idle';
        }
    }

    updateBossAI() {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const xDist = Math.abs(dx);
        const yDist = Math.abs(dy);

        this.direction = dx > 0 ? 1 : -1;

        if (this.attackCooldown > 0) this.attackCooldown--;
        
        if (['attack', 'jump_smash', 'dashpunch', 'kick', 'hit', 'dying', 'dead'].includes(this.state)) return;

        if (this.attackCooldown <= 0) {
            if (xDist < 70 && yDist < 30) {
                if (Math.random() < 0.6) this.attack('punch');
                else this.attack('kick');
                return;
            }

            if (xDist > 80 && xDist < 250 && yDist < 40) {
                if (Math.random() < 0.08) { 
                    this.attack('dashpunch');
                    return;
                }
            }

            if (dist > 250 && Math.random() < 0.05) {
                this.attack('jump_smash');
                return;
            }
        }

        let moveX = 0;
        let moveY = 0;

        if (xDist > 50) moveX = (dx > 0 ? 1 : -1) * this.speed;
        else if (xDist < 30) moveX = (dx > 0 ? -1 : 1) * (this.speed * 0.5);

        if (yDist > 10) moveY = (dy > 0 ? 1 : -1) * (this.speed * 0.8);

        if (moveX !== 0 && moveY !== 0) {
            moveX *= 0.7;
            moveY *= 0.7;
        }

        this.x += moveX;
        this.y += moveY;
        
        this.y = Math.max(GROUND_Y_MIN, Math.min(GROUND_Y_MAX, this.y));

        this.state = (moveX !== 0 || moveY !== 0) ? 'walk' : 'idle';
    }

    attack(type = 'normal') {
        this.vx = 0;
        this.vy = 0;

        if (type === 'jump_smash') {
            this.state = 'jump_smash';
            this.vz = 20; 
            this.attackCooldown = 150;
            const dx = player.x - this.x;
            this.vx = (dx > 0 ? 1 : -1) * 5; 
        
        } else if (type === 'dashpunch') {
            this.state = 'dashpunch';
            this.vx = this.direction * 12; 
            this.attackCooldown = 120;
            
        } else if (type === 'kick') {
            this.state = 'kick';
            this.attackCooldown = 60;

        } else {
            this.state = 'attack';
            this.attackCooldown = 50; 
        }

        setTimeout(() => {
            if (['hit','dying','dead'].includes(this.state)) return;
            
            let rangeW = 50, rangeH = 50, dmg = this.attackDmg;
            let hitType = 'normal';

            if (type === 'dashpunch') { rangeW = 80; dmg *= 1.5; hitType = 'knockdown'; }
            if (type === 'kick') { rangeW = 60; dmg *= 1.2; hitType = 'heavy'; }
            if (this.subtype.startsWith('boss')) { rangeW += 30; } 

            const box = { 
                x: this.x + (this.direction * (rangeW/2 + 10)), 
                y: this.y, 
                z: this.z, 
                width: rangeW, 
                height: 50 
            };
            
            if (checkCollision(box, player)) {
                player.takeDamage(dmg, this.x, hitType);
            }

            if (type === 'jump_smash') {
                 game.shakeScreen(20);
                 if(Math.abs(player.x - this.x) < 180 && Math.abs(player.y - this.y) < 50 && player.z === 0) {
                     player.takeDamage(dmg * 1.5, this.x, 'launch');
                 }
            }
        }, type === 'jump_smash' ? 800 : 200); 
    }

    draw(ctx) {
        if (this.state === 'dying') {
            ctx.save();
            ctx.globalAlpha = this.opacity;
            ctx.translate(this.x, this.y - this.z);
            ctx.rotate((this.direction === 1 ? -1 : 1) * Math.PI / 2);
            ctx.translate(-this.width/2, -this.height); 
            this.drawBody(ctx, 0, 0);
            ctx.restore();
            return;
        }
        this.drawShadow(ctx);
        const dx = this.x;
        const dy = (this.y - this.height) - this.z;
        
        ctx.save();
        if (this.flash > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
            ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = 'white';
        }
        
        ctx.translate(dx, dy + this.height/2);
        ctx.scale(this.direction, 1);
        ctx.translate(0, -this.height/2);
        
        this.drawBody(ctx, 0, 0); 
        ctx.restore();
    }

    drawBody(ctx, x, y) {
        let topColor, botColor, headColor;
        if (this.subtype.includes('bully')) { topColor='#7f8c8d'; botColor='#333'; headColor='#8e44ad'; } 
        else if (this.subtype.includes('iljin')) { topColor='#95a5a6'; botColor='#2c3e50'; headColor='#f1c40f'; } 
        else if (this.subtype.includes('rival')) { topColor='#2980b9'; botColor='#fff'; headColor='#e74c3c'; } 
        else if (this.subtype.includes('thug')) { topColor='#3498db'; botColor='#34495e'; headColor='#d35400'; } 
        else if (this.subtype.includes('suit') || this.subtype === 'boss_ch5') { topColor='#000'; botColor='#000'; headColor='#000'; } 
        else { topColor='#555'; botColor='#222'; headColor='#555'; }
        
        if (this.subtype === 'boss_ch1') { topColor='#d35400'; headColor='#000'; } 
        if (this.subtype === 'boss_ch2') { topColor='#fff'; botColor='#7f8c8d'; } 
        if (this.subtype === 'boss_ch4') { topColor='#8e44ad'; botColor='#111'; } 
        if (this.subtype === 'boss_ch5') { topColor='#fff'; botColor='#fff'; } 

        const w = this.width;
        const h = this.height;

        // 다리
        drawPoly(ctx, [{x:-w/4,y:h*0.6}, {x:0,y:h*0.6}, {x:-w/6,y:h}, {x:-w/3,y:h}], botColor);
        drawPoly(ctx, [{x:w/6,y:h*0.6}, {x:w/3,y:h*0.6}, {x:w/3,y:h}, {x:w/6,y:h}], botColor);
        
        // 몸통
        drawPoly(ctx, [{x:-w/2,y:h*0.2}, {x:w/2,y:h*0.2}, {x:w/4,y:h*0.6}, {x:-w/4,y:h*0.6}], topColor);
        // 독사 셔츠
        if (this.subtype === 'boss_ch5') {
            ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.moveTo(-5, h*0.2); ctx.lineTo(5, h*0.2); ctx.lineTo(0, h*0.4); ctx.fill();
        }

        // 머리
        drawPoly(ctx, [{x:-w/3,y:0}, {x:w/3,y:0}, {x:w/3,y:h*0.2}, {x:-w/3,y:h*0.2}], '#ffccaa');
        // 머리카락
        drawPoly(ctx, [{x:-w/3-2,y:-5}, {x:w/3+2,y:-5}, {x:w/3,y:h*0.1}, {x:-w/3,y:h*0.1}], headColor);

        // 팔
        let armOffset = 0;
        if (this.state === 'attack' || this.state === 'dashpunch') armOffset = 20;
        
        drawPoly(ctx, [{x:w/4,y:h*0.25}, {x:w/2+armOffset,y:h*0.25}, {x:w/2+armOffset,y:h*0.5}, {x:w/4,y:h*0.5}], topColor);
    }
}

class Game {
    constructor() {
        this.cameraX = 0;
        this.shake = 0;
        this.enemies = [];
        this.level = 1;
        this.state = 'start'; 
        this.paused = false; 
        
        this.loadLevel(1);
        uiFade.style.opacity = 0;
    }

    loadLevel(lvl) {
        this.level = lvl;
        const config = LEVEL_CONFIG[lvl];
        
        this.levelLength = config.length;
        this.enemies = [];
        this.cameraX = 0;
        player.x = 100; player.y = 350; player.sp = 0; 
        
        this.bossSpawned = false;
        uiBossHpContainer.style.display = 'none';
        uiStageInd.innerText = `STAGE ${lvl}`;

        const count = 10 + lvl * 3; 
        for(let i=0; i<count; i++) {
            const type = config.enemyTypes[i % config.enemyTypes.length];
            const x = 600 + (i * 300) + Math.random() * 100;
            const y = GROUND_Y_MIN + Math.random() * (GROUND_Y_MAX - GROUND_Y_MIN);
            this.enemies.push(new Enemy(x, y, type));
        }
        
        this.showMessage(`CHAPTER ${lvl}`, config.title, 3000);
        this.state = 'playing';
    }

    spawnBoss() {
        this.bossSpawned = true;
        const config = LEVEL_CONFIG[this.level];
        const boss = new Enemy(this.cameraX + 900, 350, config.boss);
        this.enemies.push(boss);
        
        uiBossHpContainer.style.display = 'block';
        uiBossName.innerText = boss.name;
        
        this.showMessage("WARNING!!", "보스 출현", 2000);
    }

    showMessage(title, sub, duration) {
        uiMessage.style.display = 'block';
        uiMsgTitle.innerText = title;
        uiMsgSub.innerText = sub;
        setTimeout(() => { uiMessage.style.display = 'none'; }, duration);
    }
    
    restart() {
        player.hp = player.maxHp;
        player.sp = 0; // SP 초기화
        player.state = 'idle';
        player.x = 100;
        player.y = 350;
        player.z = 0;
        player.opacity = 1.0;
        
        this.loadLevel(1);
        uiMessage.style.display = 'none';
        uiMessage.style.color = 'white';
    }

    shakeScreen(amount) { this.shake = amount; }

    update() {
        if (this.state === 'transition') return; 
        if (this.state === 'gameover') return;
        if (this.paused) return; 

        if (this.shake > 0) this.shake *= 0.9;
        if (this.shake < 0.5) this.shake = 0;

        player.update();

        const targetCamX = player.x - 300;
        const maxScroll = this.levelLength - canvas.width;
        if (targetCamX > this.cameraX && targetCamX < maxScroll) this.cameraX = targetCamX;

        if (!this.bossSpawned && player.x > this.levelLength - 400) {
            this.spawnBoss();
        }

        this.enemies.forEach(enemy => {
            enemy.update();
            if (enemy.subtype.startsWith('boss')) {
                uiBossHp.style.width = Math.max(0, (enemy.hp / enemy.maxHp * 100)) + '%';
                if(enemy.state === 'dead' && this.state === 'playing') {
                    this.levelClear();
                }
            }
        });

        this.enemies = this.enemies.filter(e => e.state !== 'dead' || e.opacity > 0);
        
        uiPlayerHp.style.width = Math.max(0, (player.hp / player.maxHp * 100)) + '%';
        uiPlayerSp.style.width = Math.max(0, (player.sp / player.maxSp * 100)) + '%';
        
        if (player.sp >= player.maxSp) {
            uiSpFrame.classList.add('max-charge');
        } else {
            uiSpFrame.classList.remove('max-charge');
        }

        if (player.hp <= 0 && this.state !== 'gameover') {
            this.state = 'gameover';
            this.showMessage("GAME OVER", "아무 키나 눌러 다시 시작", 99999);
            uiMessage.style.color = 'red'; 
        }
    }

    levelClear() {
        this.state = 'transition';
        this.showMessage("STAGE CLEAR", "체력 회복! 다음 스테이지로...", 3000);
        
        setTimeout(() => {
            uiFade.style.opacity = 1; 
            setTimeout(() => {
                player.hp = player.maxHp;

                if (this.level < 5) {
                    this.loadLevel(this.level + 1);
                    uiFade.style.opacity = 0; 
                } else {
                    this.showMessage("ALL CLEAR", "전설이 되었다.", 99999);
                    uiFade.style.opacity = 0;
                }
            }, 1000);
        }, 2000);
    }

    draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        const shakeX = (Math.random() - 0.5) * this.shake;
        const shakeY = (Math.random() - 0.5) * this.shake;
        ctx.translate(-this.cameraX + shakeX, shakeY);

        this.drawBackground();

        const allEntities = [player, ...this.enemies];
        allEntities.sort((a, b) => a.y - b.y);

        allEntities.forEach(entity => entity.draw(ctx));

        ctx.restore();
    }

    drawBackground() {
        const config = LEVEL_CONFIG[this.level];
        
        const gradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y_MIN);
        gradient.addColorStop(0, config.skyColor[0]);
        gradient.addColorStop(1, config.skyColor[1]);
        ctx.fillStyle = gradient;
        ctx.fillRect(this.cameraX, 0, canvas.width, GROUND_Y_MIN);

        ctx.fillStyle = (this.level === 3 || this.level === 5) ? '#111' : '#1a252f';
        for(let i=0; i<this.levelLength + 500; i+= 250) {
            const h = 100 + (i % 150);
            ctx.fillRect(i, GROUND_Y_MIN - h, 140, h);
            if (this.level === 4) ctx.fillStyle = ['#f0f', '#0ff', '#ff0'][i%3];
            else ctx.fillStyle = '#f1c40f';
            
            if (Math.random() > 0.5) ctx.fillRect(i + 30, GROUND_Y_MIN - h + 30, 20, 20);
            ctx.fillStyle = (this.level === 3 || this.level === 5) ? '#111' : '#1a252f';
        }
        
        ctx.fillStyle = config.groundColor;
        ctx.fillRect(this.cameraX, GROUND_Y_MIN, canvas.width, canvas.height - GROUND_Y_MIN);
        
        if (this.level === 2) { 
             ctx.strokeStyle = '#bdc3c7'; ctx.beginPath(); 
             for(let i=0; i<this.levelLength; i+=50) { ctx.moveTo(i, GROUND_Y_MIN); ctx.lineTo(i, GROUND_Y_MIN-50); }
             ctx.moveTo(0, GROUND_Y_MIN-50); ctx.lineTo(this.levelLength, GROUND_Y_MIN-50); ctx.stroke();
        }
    }
}

const player = new Player();
const game = new Game();

function loop() {
    game.update();
    game.draw();
    requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>