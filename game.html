<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>한탕이의 대모험 - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #101020; }
        
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Gowun+Batang&display=swap');

        /* UI 스타일 */
        #ui {
            display: none; position: absolute; top: 20px; left: 20px;
            color: white; font-family: 'Impact', sans-serif; font-size: 20px;
            text-shadow: 2px 2px 2px #000; pointer-events: none; z-index: 10;
        }
        #score-board { font-size: 30px; color: #ffff00; margin-bottom: 10px; }
        #cooldowns {
            margin-top: 10px; font-size: 16px; background: rgba(0, 0, 0, 0.5);
            padding: 10px; border-radius: 10px;
        }
        .ready { color: #00ff00; font-weight: bold; }
        .wait { color: #ff0000; }
        .buff-active { color: #ffff00; font-weight: bold; animation: blink 0.5s infinite; }

        #key-guide {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            font-family: 'Black Han Sans', sans-serif; font-size: 40px; color: #fff;
            text-shadow: 2px 2px 10px #000; background: rgba(0, 0, 0, 0.6);
            padding: 10px 30px; border-radius: 20px; border: 3px solid #fff;
            z-index: 20; display: none;
        }

        #progress-bar-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 25px; background: #333; border: 2px solid #fff; border-radius: 10px;
            z-index: 15; display: none;
        }
        #progress-bar {
            width: 0%; height: 100%; background: linear-gradient(to right, #ff0000, #ffff00, #00ff00); border-radius: 8px;
        }
        #goal-text {
            position: absolute; width: 100%; text-align: center; top: 2px;
            font-family: 'Black Han Sans', sans-serif; color: white; text-shadow: 1px 1px 2px black; font-size: 16px;
        }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4); 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white; cursor: pointer;
        }
        #game-title {
            font-family: 'Black Han Sans', sans-serif; font-size: 100px;
            background: linear-gradient(to bottom, #ffeb3b, #ff9800);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0px 0px 20px rgba(255, 165, 0, 0.8); margin-bottom: 20px; text-align: center;
        }

        .floating-text {
            position: absolute; left: 50%; top: 40%; transform: translate(-50%, -50%);
            font-size: 60px; font-weight: bold; text-shadow: 3px 3px 0 #000;
            opacity: 0; transition: all 0.5s ease-out; pointer-events: none; z-index: 50; white-space: nowrap;
        }
        #item-text { color: #98FF98; font-size: 55px; text-shadow: 4px 4px 0 #3E2723; font-family: 'Black Han Sans', sans-serif; }
        #shout-text { color: #ffea00; font-size: 80px; text-shadow: 4px 4px 0 #ff0000; font-family: 'Black Han Sans', sans-serif; }

        .death-msg {
            position: absolute; color: #aaa; font-family: 'Gowun Batang', serif;
            font-size: 20px; font-weight: bold; text-shadow: 1px 1px 2px #000; pointer-events: none;
            animation: floatUp 2s forwards; z-index: 5;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-50px); } }

        #game-over, #game-clear {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 100;
        }
        #game-over { color: #ff0055; font-size: 80px; font-family: 'Black Han Sans', sans-serif; text-shadow: 4px 4px 0 #fff; }
        
        #game-clear { 
            width: 80%; color: #fff; font-family: 'Gowun Batang', serif; 
            background: rgba(0, 0, 0, 0.9); padding: 40px;
            border: 2px solid #ff0000; box-shadow: 0 0 50px #ff0000;
        }
        .ending-title { font-size: 50px; color: #ff0000; margin-bottom: 20px; font-weight: bold; }
        .ending-desc { font-size: 24px; line-height: 1.5; color: #ccc; }

        #restart-btn {
            margin-top: 30px; font-size: 25px; padding: 15px 30px;
            cursor: pointer; background: #fff; border: none; border-radius: 5px; font-weight: bold;
        }
        #restart-btn:hover { background: #ddd; }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="start-screen">
        <div id="game-title">한탕이의 대모험</div>
        <div style="font-size: 20px; margin-bottom: 40px; color: #fff; text-shadow: 1px 1px 5px black;">
            화면을 클릭하여 시작! (최적화 패치 적용됨)
        </div>
    </div>
    
    <div id="key-guide">PRESS [→]</div>

    <div id="progress-bar-container">
        <div id="progress-bar"></div>
        <div id="goal-text">목표: 50,000점 (현재: 0)</div>
    </div>

    <div id="ui">
        <div id="score-board">SCORE: <span id="score">0</span></div>
        <div id="cooldowns">
            [Z] QR 빔(0.5s): <span id="cd-qr" class="ready">준비됨</span><br>
            [X] 계약서(3.0s): <span id="cd-contract" class="ready">준비됨</span><br>
            [C] 필살기(30s): <span id="cd-buff" class="ready">준비됨</span>
        </div>
    </div>
    
    <div id="shout-text" class="floating-text">까따구~웃!!!</div>
    <div id="item-text" class="floating-text">오옹~나이스!</div>
    <div id="death-msgs"></div>

    <div id="game-over">
        아이고난!!<br>
        <button id="restart-btn" onclick="location.reload()">다시 하기</button>
    </div>

    <div id="game-clear">
        <div class="ending-title">임무 완료</div>
        <div class="ending-desc">
            5만 점을 달성하고 "집"에 도착했습니다.<br><br>
            <span style="color: #ff5555;">[SYSTEM] : 도망친 피실험체 전원 수거 완료.</span><br>
            <span style="color: #ff5555;">[SYSTEM] : 성과급이 지급되었습니다.</span><br><br>
            한탕이의 하루는 오늘도 보람찼습니다...
        </div>
        <button id="restart-btn" onclick="location.reload()">다시 일하러 가기</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. 기본 설정 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101020); 
        scene.fog = new THREE.Fog(0x101020, 5, 50); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: false }); // ★ 최적화: 안티앨리어싱 끔 (성능 향상)
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; 
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 조명
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        // ★ 최적화: 그림자 해상도 줄이기
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);
        scene.add(new THREE.AmbientLight(0x606060));

        // --- 2. 플레이어 ---
        let player;
        let mixer; 
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // ★ 최적화: 지오메트리/머터리얼 미리 생성 (재활용)
        const enemyGeo = new THREE.BoxGeometry(1.5, 2, 1.5);
        const enemyMatRed = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
        const enemyMatDarkRed = new THREE.MeshStandardMaterial({ color: 0xAA0000 });
        const enemyMatBlackRed = new THREE.MeshStandardMaterial({ color: 0x550000 });

        const beamGeo = new THREE.BoxGeometry(1.5, 0.3, 0.3);
        const beamMat = new THREE.MeshBasicMaterial({ color: 0x00FF00 });
        
        const paperGeo = new THREE.BoxGeometry(1, 1, 1);
        const paperMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

        const placeholderGeo = new THREE.BoxGeometry(1, 2, 1);
        const placeholderMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        let fallbackPlayer = new THREE.Mesh(placeholderGeo, placeholderMat);
        fallbackPlayer.position.y = 1;
        fallbackPlayer.castShadow = true;
        playerGroup.add(fallbackPlayer);

        const loader = new GLTFLoader();
        loader.load(
            './player.glb', 
            function (gltf) {
                const model = gltf.scene;
                model.scale.set(1.5, 1.5, 1.5); 
                model.position.y = 0; 
                model.rotation.y = Math.PI / 2; 
                model.traverse(function (object) { if (object.isMesh) object.castShadow = true; });
                playerGroup.remove(fallbackPlayer); 
                playerGroup.add(model);
                mixer = new THREE.AnimationMixer(model);
                if(gltf.animations.length > 0) { mixer.clipAction(gltf.animations[0]).play(); }
            },
            undefined, function (error) { console.error('모델 로드 실패:', error); }
        );

        // --- 3. 바닥 및 집 ---
        const GOAL_SCORE = 50000; 
        let houseSpawned = false; 
        let finishLineX = 0; 

        const ground = new THREE.Mesh(
            new THREE.BoxGeometry(100000, 1, 30), 
            new THREE.MeshStandardMaterial({ color: 0x222222 })
        );
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        function spawnFinishLine(xPos) {
            finishLineX = xPos;
            const houseGroup = new THREE.Group();
            // 간단한 지오메트리는 그냥 생성
            const houseBody = new THREE.Mesh(new THREE.BoxGeometry(6, 6, 6), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            houseBody.position.y = 3;
            const houseRoof = new THREE.Mesh(new THREE.ConeGeometry(5, 4, 4), new THREE.MeshStandardMaterial({ color: 0x800000 }));
            houseRoof.position.y = 8; houseRoof.rotation.y = Math.PI / 4;
            const door = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 0.2), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            door.position.set(0, 1.5, 3);
            houseGroup.add(houseBody); houseGroup.add(houseRoof); houseGroup.add(door);
            houseGroup.position.set(xPos, 0, 0);
            scene.add(houseGroup);
        }

        // --- 4. 게임 변수 ---
        let gameStarted = false;
        let score = 0;
        let isGameOver = false;
        let isGameClear = false; 

        const projectiles = [];
        const enemies = [];
        const items = []; 
        
        let lastQrTime = 0; let lastContractTime = 0; let lastBuffTime = 0;
        const QR_COOLDOWN = 500; const CONTRACT_COOLDOWN = 3000; 
        const BUFF_COOLDOWN = 30000; const BUFF_DURATION = 10000;    
        
        let damageMultiplier = 1; let buffEndTime = 0;
        let enemyHpMultiplier = 1; let spawnRateMultiplier = 1; 

        let forwardKey = 'ArrowRight';
        let isMovingForward = false;
        const keys = { Space: false, ArrowRight: false, ArrowLeft: false, ArrowUp: false, ArrowDown: false };
        let velocityY = 0; let isJumping = false;

        let cameraMode = 0; let lastCameraSwitchTime = 0;
        const CAMERA_SWITCH_INTERVAL_GAME = 3000; const CAMERA_SWITCH_INTERVAL_START = 2000; 

        // --- 5. 입력 처리 ---
        window.addEventListener('keydown', (e) => {
            if (!gameStarted || isGameOver || isGameClear) return;
            if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
            if (e.code === forwardKey) isMovingForward = true;
            if (e.code === 'KeyZ') attemptShootQR();
            if (e.code === 'KeyX') attemptThrowContract();
            if (e.code === 'KeyC') attemptActivateBuff(); 
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
            if (e.code === forwardKey) isMovingForward = false;
        });

        const startScreen = document.getElementById('start-screen');
        
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            startScreen.style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('key-guide').style.display = 'block';
            document.getElementById('progress-bar-container').style.display = 'block';
            
            const now = Date.now();
            lastQrTime = now - QR_COOLDOWN; lastContractTime = now - CONTRACT_COOLDOWN; lastBuffTime = now - BUFF_COOLDOWN;
            
            cameraMode = 0; lastCameraSwitchTime = now; updateForwardKey();
        }

        startScreen.addEventListener('click', startGame);

        // --- 6. 게임 로직 ---
        function attemptActivateBuff() {
            const now = Date.now();
            if (now - lastBuffTime >= BUFF_COOLDOWN) {
                lastBuffTime = now; buffEndTime = now + BUFF_DURATION; damageMultiplier = 2;
                showTextEffect('shout-text'); updateUI();
            }
        }
        function attemptShootQR() {
            const now = Date.now();
            if (now - lastQrTime >= QR_COOLDOWN) { shootQRBeam(); lastQrTime = now; updateUI(); }
        }
        function attemptThrowContract() {
            const now = Date.now();
            if (now - lastContractTime >= CONTRACT_COOLDOWN) { throwContract(); lastContractTime = now; updateUI(); }
        }
        function showTextEffect(elementId) {
            const text = document.getElementById(elementId);
            text.style.opacity = '1'; text.style.top = '40%'; text.style.transform = 'translate(-50%, -50%) scale(1.2)';
            setTimeout(() => { text.style.top = '30%'; text.style.opacity = '0'; }, 1000);
            setTimeout(() => { text.style.transform = 'translate(-50%, -50%) scale(1)'; }, 1500);
        }

        // ★ 최적화: 지오메트리 재활용 적용
        function shootQRBeam() {
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.copy(playerGroup.position);
            beam.position.y += 1; beam.position.x += 1;
            // 투사체는 그림자 끔 (성능)
            beam.userData = { type: 'beam', velocity: 0.8, damage: 5 * damageMultiplier, hitLimit: 2, rangeLimit: 30 }; 
            scene.add(beam); projectiles.push(beam);
        }

        function throwContract() {
            const paper = new THREE.Mesh(paperGeo, paperMat);
            paper.position.copy(playerGroup.position);
            paper.position.y += 1; paper.position.x += 1;
            paper.userData = { type: 'contract', velocity: 0.7, damage: 100 * damageMultiplier, hitLimit: 999, rangeLimit: 60 }; 
            scene.add(paper); projectiles.push(paper);
        }

        function showDeathMessage() {
            // ★ 최적화: DOM 요소 개수 제한
            const container = document.getElementById('death-msgs');
            if (container.childElementCount > 20) {
                container.removeChild(container.firstChild);
            }

            const msgs = ["겨우 탈출했는데...", "자유의 몸이다...", "제발 살려줘...", "햇빛을 보고싶었어...", "다시 지하실로?!"];
            const msg = msgs[Math.floor(Math.random() * msgs.length)];
            const div = document.createElement('div');
            div.className = 'death-msg';
            div.innerText = msg;
            div.style.left = (20 + Math.random() * 60) + '%';
            div.style.top = (30 + Math.random() * 40) + '%';
            container.appendChild(div);
            setTimeout(() => { div.remove(); }, 2000);
        }

        // 민초 아이템 재활용 (지오메트리)
        const mintGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const mintMat = new THREE.MeshStandardMaterial({ color: 0x98FF98, roughness: 0.8 });
        const chipGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        const chipMat = new THREE.MeshStandardMaterial({ color: 0x3E2723 });

        function spawnItem(x, y, z) {
            const itemGroup = new THREE.Group();
            const mintBall = new THREE.Mesh(mintGeo, mintMat);
            itemGroup.add(mintBall);
            
            for(let k=0; k<6; k++) { 
                const chip = new THREE.Mesh(chipGeo, chipMat);
                chip.position.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.45);
                itemGroup.add(chip);
            }
            itemGroup.position.set(x, 1, z);
            scene.add(itemGroup); items.push(itemGroup);
        }

        function spawnEnemy() {
            if (!gameStarted || isGameOver || isGameClear) return;
            if (houseSpawned && playerGroup.position.x > finishLineX - 60) return;

            // 난이도 로직
            if (score >= 30000) { enemyHpMultiplier = 3; spawnRateMultiplier = 4; } 
            else if (score >= 20000) { enemyHpMultiplier = 2; spawnRateMultiplier = 2; } 
            else if (score >= 10000) { enemyHpMultiplier = 2; spawnRateMultiplier = 1; } 
            else { enemyHpMultiplier = 1; spawnRateMultiplier = 1.5; } 

            if (Math.random() < 0.03 * spawnRateMultiplier) { 
                // ★ 최적화: 재질 재활용
                let mat = enemyMatRed;
                if (enemyHpMultiplier === 2) mat = enemyMatDarkRed;
                if (enemyHpMultiplier === 3) mat = enemyMatBlackRed;
                
                const enemy = new THREE.Mesh(enemyGeo, mat); // 지오메트리 재활용
                enemy.position.set(playerGroup.position.x + 25 + Math.random() * 5, 1, 0);
                enemy.userData = { hp: 5 * enemyHpMultiplier }; 
                enemy.castShadow = true;
                scene.add(enemy); enemies.push(enemy);
            }
        }

        function updateForwardKey() {
            const guide = document.getElementById('key-guide');
            if (!gameStarted) return;
            isMovingForward = false;
            switch(cameraMode) {
                case 0: forwardKey = 'ArrowRight'; guide.innerText = "PRESS [→]"; break;
                case 1: forwardKey = 'ArrowLeft'; guide.innerText = "PRESS [←]"; break;
                case 2: forwardKey = 'ArrowUp'; guide.innerText = "PRESS [↑]"; break;
                case 3: forwardKey = 'ArrowDown'; guide.innerText = "PRESS [↓]"; break;
            }
            if (keys[forwardKey]) isMovingForward = true;
        }

        function updateCamera(isGame) {
            const now = Date.now();
            const interval = isGame ? CAMERA_SWITCH_INTERVAL_GAME : CAMERA_SWITCH_INTERVAL_START;
            if (now - lastCameraSwitchTime > interval) {
                if (isGame) {
                    const nextMode = Math.floor(Math.random() * 4);
                    if(cameraMode === nextMode) cameraMode = (nextMode + 1) % 4; else cameraMode = nextMode;
                    updateForwardKey();
                } else { cameraMode = (cameraMode + 1) % 4; }
                lastCameraSwitchTime = now;
            }
            let offsetX, offsetY, offsetZ; let lookX, lookY, lookZ;
            if (!isGame) {
                switch(cameraMode) {
                    case 0: offsetX = 2; offsetY = 1; offsetZ = 2; break;
                    case 1: offsetX = 2; offsetY = 1; offsetZ = -2; break;
                    case 2: offsetX = -2; offsetY = 2; offsetZ = 0; break;
                    case 3: offsetX = 3; offsetY = 0.5; offsetZ = 0; break;
                }
                lookX = 0; lookY = 1; lookZ = 0; 
            } else {
                switch(cameraMode) {
                    case 0: offsetX = 6; offsetY = 3; offsetZ = 10; break;
                    case 1: offsetX = 6; offsetY = 3; offsetZ = -10; break;
                    case 2: offsetX = -5; offsetY = 4; offsetZ = 0; break;
                    case 3: offsetX = 15; offsetY = 2; offsetZ = 0; break;
                }
                lookX = 2; lookY = 1; lookZ = 0;
            }
            camera.position.x = playerGroup.position.x + offsetX; camera.position.y = playerGroup.position.y + offsetY; camera.position.z = playerGroup.position.z + offsetZ;
            camera.lookAt(playerGroup.position.x + lookX, playerGroup.position.y + lookY, playerGroup.position.z + lookZ);
        }

        // --- 8. 게임 루프 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta); 
            updateCamera(gameStarted);
            if (!gameStarted || isGameOver || isGameClear) { renderer.render(scene, camera); return; }

            const now = Date.now();

            const progress = Math.min(100, (score / GOAL_SCORE) * 100);
            document.getElementById('progress-bar').style.width = progress + '%';
            document.getElementById('goal-text').innerText = `목표: 50,000점 (현재: ${score})`;

            if (score >= GOAL_SCORE && !houseSpawned) {
                spawnFinishLine(playerGroup.position.x + 50); 
                houseSpawned = true;
            }
            if (houseSpawned && playerGroup.position.x >= finishLineX) {
                gameClear();
            }

            if (now > buffEndTime && damageMultiplier > 1) { damageMultiplier = 1; updateUI(); }
            if (isMovingForward) playerGroup.position.x += 0.2;
            
            if (keys.Space && !isJumping) { velocityY = 0.35; isJumping = true; }
            playerGroup.position.y += velocityY;
            if (playerGroup.position.y > 0) { velocityY -= 0.015; } else { playerGroup.position.y = 0; isJumping = false; velocityY = 0; }

            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i]; item.rotation.y += 0.05; 
                if (item.position.distanceTo(playerGroup.position) < 1.5) {
                    const phrases = ["오옹~나이스!!!", "민초는 문화다!!"];
                    document.getElementById('item-text').innerText = phrases[Math.floor(Math.random()*phrases.length)];
                    showTextEffect('item-text');
                    
                    lastQrTime = 0; lastContractTime = 0; lastBuffTime = 0; 
                    scene.remove(item); items.splice(i, 1); updateUI();
                } else if (item.position.x < playerGroup.position.x - 10) { scene.remove(item); items.splice(i, 1); }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i]; p.position.x += p.userData.velocity; 
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (p.position.distanceTo(enemy.position) < 1.5) {
                        enemy.userData.hp -= p.userData.damage;
                        if (enemy.userData.hp <= 0) {
                            // ★ 유언 확률 로직 (Ver 2.1)
                            let msgChance = 0;
                            if (score >= 40000) msgChance = 0.25;
                            else if (score >= 30000) msgChance = 0.1;
                            else if (score >= 20000) msgChance = 0.05;
                            else if (score >= 10000) msgChance = 0.01;
                            else msgChance = 0.005; // 0.5%

                            if (Math.random() < msgChance) showDeathMessage();
                            
                            if (Math.random() < 0.2) spawnItem(enemy.position.x, enemy.position.y, enemy.position.z);
                            scene.remove(enemy); enemies.splice(j, 1);
                            
                            let points = 10; 
                            if (score >= 30000) points = 40;      
                            else if (score >= 20000) points = 30; 
                            else if (score >= 10000) points = 20; 
                            
                            score += points;
                            document.getElementById('score').innerText = score;
                        }
                        p.userData.hitLimit -= 1;
                        if (p.userData.hitLimit <= 0) { scene.remove(p); projectiles.splice(i, 1); break; }
                    }
                }
                if (p.userData.hitLimit > 0 && p.position.x > playerGroup.position.x + p.userData.rangeLimit) {
                    scene.remove(p); projectiles.splice(i, 1);
                }
            }

            spawnEnemy();
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i]; enemy.position.x -= 0.08; 
                if (enemy.position.distanceTo(playerGroup.position) < 1.2) { gameOver(); }
                if (enemy.position.x < playerGroup.position.x - 10) { scene.remove(enemy); enemies.splice(i, 1); }
            }
            updateUI();
            renderer.render(scene, camera);
        }

        function updateUI() {
            const now = Date.now();
            const qrElem = document.getElementById('cd-qr');
            const contElem = document.getElementById('cd-contract');
            const buffElem = document.getElementById('cd-buff');
            if (now - lastQrTime >= QR_COOLDOWN) { qrElem.innerText = "준비됨"; qrElem.className = "ready"; } else { qrElem.innerText = ((QR_COOLDOWN - (now - lastQrTime))/1000).toFixed(1) + "s"; qrElem.className = "wait"; }
            if (now - lastContractTime >= CONTRACT_COOLDOWN) { contElem.innerText = "준비됨"; contElem.className = "ready"; } else { contElem.innerText = ((CONTRACT_COOLDOWN - (now - lastContractTime))/1000).toFixed(1) + "s"; contElem.className = "wait"; }
            if (damageMultiplier > 1) { const remain = Math.ceil((buffEndTime - now)/1000); buffElem.innerText = `발동중!! (${remain}s)`; buffElem.className = "buff-active"; } else { if (now - lastBuffTime >= BUFF_COOLDOWN) { buffElem.innerText = "사용 가능 [C]"; buffElem.className = "ready"; } else { buffElem.innerText = ((BUFF_COOLDOWN - (now - lastBuffTime))/1000).toFixed(1) + "s"; buffElem.className = "wait"; } }
        }
        function gameOver() { isGameOver = true; document.getElementById('game-over').style.display = 'block'; document.getElementById('key-guide').style.display = 'none'; }
        function gameClear() { isGameClear = true; document.getElementById('game-clear').style.display = 'block'; document.getElementById('key-guide').style.display = 'none'; document.getElementById('ui').style.display = 'none'; }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        animate();
    </script>
</body>
</html>
