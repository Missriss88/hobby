<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Rush: Syntax Savior</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel (JSX 컴파일용) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Noto+Sans+KR:wght@400;700;900&display=swap');

        body { font-family: 'Noto Sans KR', sans-serif; }
        code, pre, .font-mono { font-family: 'JetBrains Mono', monospace; }

        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #111; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #555; }

        @keyframes fade-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slide-up { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } }
        @keyframes pop-in { 0% { opacity: 0; transform: scale(0.5); } 80% { transform: scale(1.1); } 100% { opacity: 1; transform: scale(1); } }

        .animate-fade-in { animation: fade-in 0.5s ease-out forwards; }
        .animate-slide-up { animation: slide-up 0.4s ease-out forwards; }
        .animate-shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        .animate-pop-in { animation: pop-in 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    </style>
</head>
<body class="bg-black text-white h-screen w-screen overflow-hidden selection:bg-green-500 selection:text-black">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONS ---
        const Icons = {
            Terminal: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 17 10 11 4 5"/><line x1="12" y1="19" x2="20" y2="19"/></svg>,
            Play: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
            RotateCcw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
            CheckCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>,
            XCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>,
            Code2: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m18 16 4-4-4-4"/><path d="m6 8-4 4 4 4"/><path d="m14.5 4-5 16"/></svg>,
            Cpu: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M15 2v2"/><path d="M15 20v2"/><path d="M2 15h2"/><path d="M2 9h2"/><path d="M20 15h2"/><path d="M20 9h2"/><path d="M9 2v2"/><path d="M9 20v2"/></svg>,
            Trophy: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>,
            RefreshCw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>,
            User: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>,
            ChevronRight: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m9 18 6-6-6-6"/></svg>,
            Box: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>,
            Wifi: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>,
            Activity: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>,
            Monitor: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="14" x="2" y="3" rx="2"/><line x1="8" x2="16" y1="21" y2="21"/><line x1="12" x2="12" y1="17" y2="21"/></svg>,
            Lock: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>,
            Skull: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12.5 17-.5-1-.5 1h1z"/><path d="M15 22a1 1 0 0 0 1-1v-1a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 19v1a1 1 0 0 0 1 1h6z"/><circle cx="15" cy="12" r="1"/><circle cx="9" cy="12" r="1"/></svg>
        };

        const { Terminal, Play, RotateCcw, CheckCircle, XCircle, Code2, Cpu, Trophy, RefreshCw, User, ChevronRight, Box, Wifi, Activity, Monitor, Lock, Skull } = Icons;

        // --- SCENARIO DATA (3 Per Language) ---
        const SCENARIOS = {
            'Python': [
                {
                    id: 'py_ai',
                    type: 'ai_chart',
                    title: 'AI 모델 학습',
                    questions: [
                        { context: "Step 1: 데이터 분석 라이브러리 로드", preCode: "", gap: "import", postCode: " pandas as pd\nimport math", options: ["include", "using", "import", "require"], answer: "import", explanation: "라이브러리를 사용할 때는 import 키워드를 씁니다." },
                        { context: "Step 2: 데이터셋 파일 열기", preCode: "with ", gap: "open", postCode: "(\"dataset.csv\", \"r\") as f:\n    raw_data = f.readlines()", options: ["file", "load", "open", "read"], answer: "open", explanation: "파일을 안전하게 열 때는 with open(...) 패턴을 사용합니다." },
                        { context: "Step 3: 데이터 파싱 (문자열 분리)", preCode: "header = raw_data[0].strip().", gap: "split", postCode: "(\",\")", options: ["slice", "divide", "split", "cut"], answer: "split", explanation: "CSV 데이터를 쉼표 기준으로 나누려면 split을 사용합니다." },
                        { context: "Step 4: AI 모델 클래스 정의", preCode: "class AIModel:\n    def ", gap: "__init__", postCode: "(self, learning_rate):\n        self.lr = learning_rate", options: ["__main__", "__init__", "start", "__new__"], answer: "__init__", explanation: "클래스의 초기화 메서드는 __init__입니다." },
                        { context: "Step 5: 학습 메서드 정의", preCode: "    ", gap: "def", postCode: " train(self, data):\n        print(\"Training started...\")", options: ["function", "def", "func", "void"], answer: "def", explanation: "함수(메서드) 정의는 def로 시작합니다." },
                        { context: "Step 6: 학습 루프 (에포크 반복)", preCode: "        epochs = 10\n        for i in ", gap: "range", postCode: "(epochs):\n            self.optimize()", options: ["loop", "range", "xrange", "list"], answer: "range", explanation: "지정된 횟수만큼 반복하려면 range를 사용합니다." },
                        { context: "Step 7: 손실값 기록 (리스트 추가)", preCode: "        history = []\n        history.", gap: "append", postCode: "(current_loss)", options: ["push", "add", "insert", "append"], answer: "append", explanation: "리스트에 값을 추가할 때는 append를 사용합니다." },
                        { context: "Step 8: 학습 중단 조건 확인", preCode: "            ", gap: "if", postCode: " current_loss < 0.01:\n                break", options: ["when", "check", "if", "case"], answer: "if", explanation: "조건을 검사할 때는 if문을 사용합니다." },
                        { context: "Step 9: 예외 처리 (0으로 나누기 방지)", preCode: "        ", gap: "try", postCode: ":\n            accuracy = correct / total\n        except ZeroDivisionError:\n            accuracy = 0", options: ["try", "attempt", "do", "begin"], answer: "try", explanation: "에러가 발생할 수 있는 코드는 try 블록에 넣습니다." },
                        { context: "Step 10: 정확도 반올림", preCode: "        print(f\"Acc: {", gap: "round", postCode: "(accuracy, 4)}\")", options: ["ceil", "floor", "round", "fix"], answer: "round", explanation: "소수점을 정리할 때는 round 함수를 씁니다." },
                        { context: "Step 11: 람다 함수로 전처리", preCode: "normalize = ", gap: "lambda", postCode: " x: x / 255.0", options: ["func", "def", "lambda", "arrow"], answer: "lambda", explanation: "간단한 익명 함수는 lambda로 정의합니다." },
                        { context: "Step 12: 설정값 존재 확인", preCode: "config = {'batch': 32}\nif 'batch' ", gap: "in", postCode: " config:\n    print(\"Batch size set\")", options: ["has", "in", "exists", "contains"], answer: "in", explanation: "딕셔너리 키 존재 여부는 in 연산자로 확인합니다." },
                        { context: "Step 13: 데이터 검증 (모두 통과?)", preCode: "validations = [True, True, True]\nis_valid = ", gap: "all", postCode: "(validations)", options: ["every", "all", "check", "sum"], answer: "all", explanation: "모든 요소가 참인지 확인할 때는 all()을 사용합니다." },
                        { context: "Step 14: 데이터셋 크기 확인", preCode: "n_samples = ", gap: "len", postCode: "(raw_data)", options: ["length", "size", "count", "len"], answer: "len", explanation: "리스트나 문자열의 길이는 len()입니다." },
                        { context: "Step 15: 결과 출력 및 서버 시작", preCode: "print(\"System Ready\")\n", gap: "print", postCode: "(\"Server listening on port 8080...\")", options: ["printf", "echo", "print", "write"], answer: "print", explanation: "화면에 메시지를 출력할 때는 print를 사용합니다." }
                    ]
                },
                {
                    id: 'py_scraper',
                    type: 'scraper_log',
                    title: '웹 크롤러',
                    questions: [
                        { context: "Step 1: HTTP 요청 라이브러리 로드", preCode: "", gap: "import", postCode: " requests\nfrom bs4 import BeautifulSoup", options: ["include", "get", "import", "using"], answer: "import", explanation: "외부 라이브러리를 사용할 때 import를 씁니다." },
                        { context: "Step 2: 타겟 URL 설정", preCode: "url = \"https://news.site\"\nparams = {", gap: "\"page\"", postCode: ": 1}", options: ["'page'", "\"page\"", "(page)", "<page>"], answer: "\"page\"", explanation: "딕셔너리의 키는 따옴표로 감싸야 합니다." },
                        { context: "Step 3: GET 요청 보내기", preCode: "response = requests.", gap: "get", postCode: "(url, params=params)", options: ["post", "get", "fetch", "pull"], answer: "get", explanation: "데이터를 조회할 때는 GET 메서드를 사용합니다." },
                        { context: "Step 4: 상태 코드 확인", preCode: "if response.", gap: "status_code", postCode: " == 200:\n    print(\"Success\")", options: ["code", "status", "status_code", "result"], answer: "status_code", explanation: "응답 상태는 status_code 속성에 저장됩니다." },
                        { context: "Step 5: HTML 파싱 객체 생성", preCode: "soup = ", gap: "BeautifulSoup", postCode: "(response.text, 'html.parser')", options: ["BS4", "BeautifulSoup", "Parser", "HTML"], answer: "BeautifulSoup", explanation: "HTML을 파싱하기 위해 BeautifulSoup 객체를 생성합니다." },
                        { context: "Step 6: 특정 태그 모두 찾기", preCode: "titles = soup.", gap: "find_all", postCode: "('h2', class_='title')", options: ["select", "find", "find_all", "get_tags"], answer: "find_all", explanation: "해당하는 모든 태그를 리스트로 반환합니다." },
                        { context: "Step 7: 리스트 컴프리헨션 사용", preCode: "clean_titles = [t.text.", gap: "strip", postCode: "() for t in titles]", options: ["clean", "trim", "strip", "cut"], answer: "strip", explanation: "문자열 앞뒤 공백 제거는 strip()을 사용합니다." },
                        { context: "Step 8: JSON 모듈 임포트", preCode: "", gap: "import", postCode: " json", options: ["using", "import", "include", "require"], answer: "import", explanation: "JSON 처리를 위해 내장 모듈을 임포트합니다." },
                        { context: "Step 9: 데이터 저장 (파일 쓰기)", preCode: "with open('news.json', ", gap: "'w'", postCode: ") as f:", options: ["'r'", "'w'", "'a'", "'wb'"], answer: "'w'", explanation: "쓰기 모드('w')로 파일을 엽니다." },
                        { context: "Step 10: JSON 덤프", preCode: "    json.", gap: "dump", postCode: "(clean_titles, f, indent=4)", options: ["save", "write", "dump", "export"], answer: "dump", explanation: "파이썬 객체를 JSON 파일로 저장할 때 dump를 사용합니다." },
                        { context: "Step 11: 예외 처리 (네트워크)", preCode: "except requests.", gap: "RequestException", postCode: " as e:\n    print(\"Network Error\")", options: ["Error", "RequestException", "Fail", "ConnectError"], answer: "RequestException", explanation: "requests 모듈의 기본 예외 클래스입니다." },
                        { context: "Step 12: 메인 함수 실행 확인", preCode: "if __name__ == ", gap: "\"__main__\"", postCode: ":\n    run_scraper()", options: ["\"main\"", "\"__main__\"", "\"__init__\"", "True"], answer: "\"__main__\"", explanation: "스크립트가 직접 실행될 때만 코드를 수행합니다." },
                        { context: "Step 13: 딜레이 추가 (매너)", preCode: "import time\ntime.", gap: "sleep", postCode: "(1)", options: ["wait", "delay", "sleep", "pause"], answer: "sleep", explanation: "실행을 잠시 멈출 때는 time.sleep()을 씁니다." },
                        { context: "Step 14: 함수 인자 타입 힌트", preCode: "def parse_html(html: ", gap: "str", postCode: ") -> list:", options: ["string", "str", "text", "char"], answer: "str", explanation: "파이썬 문자열 타입 힌트는 str입니다." },
                        { context: "Step 15: 작업 완료 메시지", preCode: "", gap: "print", postCode: "(f\"Saved {len(clean_titles)} articles.\")", options: ["log", "echo", "print", "write"], answer: "print", explanation: "콘솔 출력을 위해 print 함수를 사용합니다." }
                    ]
                },
                {
                    id: 'py_finance',
                    type: 'finance_chart',
                    title: '주식 데이터 분석',
                    questions: [
                        { context: "Step 1: 수치 연산 라이브러리", preCode: "import ", gap: "numpy", postCode: " as np", options: ["math", "num", "numpy", "calc"], answer: "numpy", explanation: "과학 계산에는 numpy 라이브러리가 표준입니다." },
                        { context: "Step 2: 날짜 처리 모듈", preCode: "from datetime import ", gap: "datetime", postCode: ", timedelta", options: ["date", "time", "datetime", "calendar"], answer: "datetime", explanation: "날짜와 시간을 다룰 때 datetime 클래스를 씁니다." },
                        { context: "Step 3: 랜덤 주가 생성", preCode: "prices = np.random.", gap: "normal", postCode: "(100, 10, 30)", options: ["rand", "normal", "int", "choice"], answer: "normal", explanation: "정규 분포를 따르는 난수를 생성합니다." },
                        { context: "Step 4: 배열 형태 확인", preCode: "print(f\"Shape: {prices.", gap: "shape", postCode: "}\")", options: ["size", "len", "shape", "dim"], answer: "shape", explanation: "Numpy 배열의 차원은 .shape 속성으로 확인합니다." },
                        { context: "Step 5: 이동 평균 계산 함수", preCode: "def moving_average(data, ", gap: "window", postCode: "=5):", options: ["size", "window", "range", "step"], answer: "window", explanation: "이동 평균의 구간 크기를 보통 window라고 합니다." },
                        { context: "Step 6: 리스트 슬라이싱", preCode: "    return [sum(data[i:i+window])/", gap: "window", postCode: " for i in range(len(data)-window)]", options: ["len", "window", "count", "5"], answer: "window", explanation: "평균을 구하기 위해 구간 크기(window)로 나눕니다." },
                        { context: "Step 7: 수익률 계산 (벡터 연산)", preCode: "returns = (prices[1:] - prices[:-1]) / prices[", gap: ":-1", postCode: "]", options: ["0", ":-1", "1:", "all"], answer: ":-1", explanation: "오늘 가격 - 어제 가격 / 어제 가격으로 수익률을 계산합니다." },
                        { context: "Step 8: 조건부 필터링 (상승장)", preCode: "up_days = prices[prices ", gap: ">", postCode: " 100]", options: [">", "<", "==", "in"], answer: ">", explanation: "가격이 100보다 큰 요소만 선택합니다." },
                        { context: "Step 9: 최대값 인덱스 찾기", preCode: "peak_idx = np.", gap: "argmax", postCode: "(prices)", options: ["max", "maximum", "argmax", "top"], answer: "argmax", explanation: "최대값이 위치한 인덱스는 argmax로 찾습니다." },
                        { context: "Step 10: 데이터 결합", preCode: "data = np.", gap: "stack", postCode: "((dates, prices), axis=1)", options: ["append", "concat", "stack", "merge"], answer: "stack", explanation: "두 배열을 새로운 축으로 합칠 때 stack을 씁니다." },
                        { context: "Step 11: CSV 저장 (Numpy)", preCode: "np.", gap: "savetxt", postCode: "(\"stock.csv\", prices, delimiter=\",\")", options: ["save", "savetxt", "dump", "write"], answer: "savetxt", explanation: "텍스트 파일로 배열을 저장할 때 savetxt를 씁니다." },
                        { context: "Step 12: 클래스 상속 (분석기)", preCode: "class StockAnalyzer(", gap: "object", postCode: "):", options: ["class", "void", "object", "base"], answer: "object", explanation: "파이썬 2 호환성 등을 위해 object를 상속받기도 합니다(생략 가능)." },
                        { context: "Step 13: 매직 메서드 (문자열 표현)", preCode: "    def ", gap: "__str__", postCode: "(self):\n        return \"Analyzer V1\"", options: ["__repr__", "__str__", "__init__", "toString"], answer: "__str__", explanation: "객체를 문자열로 표현할 때 __str__을 정의합니다." },
                        { context: "Step 14: 변동성 계산 (표준편차)", preCode: "volatility = np.", gap: "std", postCode: "(returns)", options: ["var", "mean", "std", "avg"], answer: "std", explanation: "표준편차(standard deviation) 함수는 std입니다." },
                        { context: "Step 15: 분석 리포트 출력", preCode: "print(f\"High: {prices.max():.2f}, Vol: {volatility:", gap: ".2%", postCode: "}\")", options: [".2f", ".2%", "int", "str"], answer: ".2%", explanation: "백분율 포맷팅은 .2% 형식을 사용합니다." }
                    ]
                }
            ],
            'C': [
                {
                    id: 'c_rpg',
                    type: 'rpg_grid',
                    title: 'RPG 게임 엔진',
                    questions: [
                        { context: "Step 1: 표준 입출력 헤더 포함", preCode: "#include <", gap: "stdio.h", postCode: ">", options: ["iostream", "stdio.h", "std.h", "io.h"], answer: "stdio.h", explanation: "C언어의 표준 입출력 함수들은 stdio.h에 있습니다." },
                        { context: "Step 2: 상수 정의 (맵 크기)", preCode: "#", gap: "define", postCode: " MAP_WIDTH 100", options: ["const", "define", "set", "var"], answer: "define", explanation: "매크로 상수는 #define으로 정의합니다." },
                        { context: "Step 3: 플레이어 구조체 정의", preCode: "", gap: "struct", postCode: " Player {\n    int x, y;\n    int hp;\n};", options: ["class", "struct", "type", "rec"], answer: "struct", explanation: "데이터를 묶을 때는 구조체(struct)를 사용합니다." },
                        { context: "Step 4: 게임 맵 메모리 할당", preCode: "int *map = (int*)", gap: "malloc", postCode: "(sizeof(int) * MAP_WIDTH);", options: ["new", "alloc", "malloc", "mem"], answer: "malloc", explanation: "동적 메모리 할당은 malloc 함수를 사용합니다." },
                        { context: "Step 5: 메모리 할당 실패 확인", preCode: "if (map == ", gap: "NULL", postCode: ") {\n    return -1;\n}", options: ["nil", "null", "NULL", "0"], answer: "NULL", explanation: "포인터가 비었음을 확인할 때는 NULL 매크로를 씁니다." },
                        { context: "Step 6: 플레이어 이름 복사", preCode: "char name[20];\n", gap: "strcpy", postCode: "(name, \"Hero\");", options: ["strcopy", "cpystr", "strcpy", "move"], answer: "strcpy", explanation: "문자열 대입(복사)은 strcpy 함수를 사용합니다." },
                        { context: "Step 7: 구조체 크기 확인", preCode: "int p_size = ", gap: "sizeof", postCode: "(struct Player);", options: ["len", "size", "sizeof", "width"], answer: "sizeof", explanation: "타입의 바이트 크기는 sizeof로 구합니다." },
                        { context: "Step 8: 포인터로 초기값 설정", preCode: "struct Player p;\nstruct Player *ptr = ", gap: "&", postCode: "p;\nptr->hp = 100;", options: ["*", "&", "@", "#"], answer: "&", explanation: "변수의 주소값은 & 연산자로 가져옵니다." },
                        { context: "Step 9: 메인 게임 루프 시작", preCode: "int running = 1;\n", gap: "while", postCode: "(running) {\n    update_game();\n}", options: ["for", "loop", "until", "while"], answer: "while", explanation: "조건이 참인 동안 반복하려면 while문을 씁니다." },
                        { context: "Step 10: 사용자 입력 처리 (포인터)", preCode: "int input;\nscanf(\"%d\", ", gap: "&", postCode: "input);", options: ["*", "&", "$", "ptr"], answer: "&", explanation: "scanf에는 변수의 주소(&)를 넘겨주어야 합니다." },
                        { context: "Step 11: 입력에 따른 분기", preCode: "switch(input) {\n    ", gap: "case", postCode: " 1: move_up(); break;\n}", options: ["when", "if", "case", "option"], answer: "case", explanation: "switch문 내부의 조건 분기는 case를 사용합니다." },
                        { context: "Step 12: 데미지 처리 (역참조)", preCode: "void hit(int *hp) {\n    ", gap: "*", postCode: "hp -= 10;\n}", options: ["&", "*", "->", "."], answer: "*", explanation: "포인터가 가리키는 값을 수정하려면 * 연산자를 씁니다." },
                        { context: "Step 13: 명령어 문자열 비교", preCode: "if (", gap: "strcmp", postCode: "(cmd, \"quit\") == 0) running = 0;", options: ["strequal", "strcmp", "compare", "eq"], answer: "strcmp", explanation: "두 문자열이 같은지 비교할 때는 strcmp를 사용합니다." },
                        { context: "Step 14: 상태 정보 출력", preCode: "", gap: "printf", postCode: "(\"HP: %d\\n\", p.hp);", options: ["print", "cout", "printf", "log"], answer: "printf", explanation: "형식화된 출력은 printf를 사용합니다." },
                        { context: "Step 15: 종료 및 값 반환", preCode: "free(map);\n", gap: "return", postCode: " 0;", options: ["exit", "back", "return", "out"], answer: "return", explanation: "함수를 종료하고 값을 반환할 때는 return을 씁니다." }
                    ]
                },
                {
                    id: 'c_traffic',
                    type: 'traffic_light',
                    title: '신호등 제어 시스템',
                    questions: [
                        { context: "Step 1: 비트 연산 헤더", preCode: "#include <", gap: "stdint.h", postCode: ">", options: ["bit.h", "inttypes.h", "stdint.h", "std.h"], answer: "stdint.h", explanation: "정해진 비트 수의 정수형을 쓰려면 stdint.h가 필요합니다." },
                        { context: "Step 2: 레지스터 주소 정의", preCode: "#define REG_LED ", gap: "(*volatile uint8_t *)", postCode: "0x4000", options: ["(int*)", "(volatile*)", "(*volatile uint8_t *)", "&int"], answer: "(*volatile uint8_t *)", explanation: "하드웨어 레지스터 접근 시 volatile 포인터 캐스팅을 합니다." },
                        { context: "Step 3: 비트 마스크 정의", preCode: "#define RED_LED ", gap: "(1 << 0)", postCode: "", options: ["1", "(1 << 0)", "0x00", "bit(0)"], answer: "(1 << 0)", explanation: "0번 비트를 켜는 마스크는 1을 0번 시프트합니다." },
                        { context: "Step 4: 상태 열거형", preCode: "typedef ", gap: "enum", postCode: " { RED, YELLOW, GREEN } State;", options: ["struct", "enum", "union", "class"], answer: "enum", explanation: "연관된 상수들의 집합은 enum으로 정의합니다." },
                        { context: "Step 5: 메인 함수 시작", preCode: "int main(", gap: "void", postCode: ") {", options: ["null", "void", "empty", "args"], answer: "void", explanation: "인자가 없는 메인 함수는 void를 명시합니다." },
                        { context: "Step 6: LED 켜기 (비트 OR)", preCode: "*REG_LED ", gap: "|=", postCode: " RED_LED;", options: ["=", "+=", "|=", "&="], answer: "|=", explanation: "특정 비트를 켤 때는 OR 연산(|=)을 사용합니다." },
                        { context: "Step 7: LED 끄기 (비트 AND NOT)", preCode: "*REG_LED ", gap: "&=", postCode: " ~YELLOW_LED;", options: ["^=", "&=", "-=", "|="], answer: "&=", explanation: "특정 비트를 끌 때는 AND NOT 연산(&= ~)을 사용합니다." },
                        { context: "Step 8: 상태 토글 (XOR)", preCode: "*REG_LED ", gap: "^=", postCode: " GREEN_LED;", options: ["|=", "^=", "&=", "~="], answer: "^=", explanation: "상태를 반전(토글)시킬 때는 XOR 연산(^=)을 씁니다." },
                        { context: "Step 9: 딜레이 루프 (volatile)", preCode: "for (", gap: "volatile", postCode: " int i=0; i<1000; i++);", options: ["static", "const", "volatile", "register"], answer: "volatile", explanation: "최적화로 루프가 삭제되지 않게 volatile을 씁니다." },
                        { context: "Step 10: 함수 포인터 타입", preCode: "typedef void ", gap: "(*Handler)", postCode: "(void);", options: ["*Handler", "Handler*", "(*Handler)", "&Handler"], answer: "(*Handler)", explanation: "함수 포인터 타입 정의 문법입니다." },
                        { context: "Step 11: 인터럽트 핸들러 등록", preCode: "Handler h = ", gap: "&", postCode: "TimerISR;", options: ["*", "&", "@", "->"], answer: "&", explanation: "함수의 주소를 가져올 때 & 연산자를 씁니다." },
                        { context: "Step 12: 조건문 (비트 검사)", preCode: "if (*REG_LED ", gap: "&", postCode: " RED_LED)", options: ["&&", "&", "==", "|"], answer: "&", explanation: "특정 비트가 켜져 있는지 확인하려면 AND 연산(&)을 합니다." },
                        { context: "Step 13: 매크로 함수", preCode: "#define SET_BIT(p,n) ((p) |= (1 << (", gap: "n", postCode: ")))", options: ["i", "x", "n", "bit"], answer: "n", explanation: "매크로 인자 n을 사용하여 시프트합니다." },
                        { context: "Step 14: 무한 루프", preCode: "", gap: "for(;;)", postCode: " { control_traffic(); }", options: ["while(0)", "for(;;)", "loop", "repeat"], answer: "for(;;)", explanation: "C언어에서 관용적인 무한 루프 표현입니다." },
                        { context: "Step 15: 시스템 종료 (도달 불가)", preCode: "", gap: "return", postCode: " 0;", options: ["exit", "end", "return", "break"], answer: "return", explanation: "함수 종료 시 return을 사용합니다." }
                    ]
                },
                {
                    id: 'c_memory',
                    type: 'memory_map',
                    title: '메모리 관리자 (Kernel)',
                    questions: [
                        { context: "Step 1: void 포인터 사용", preCode: "void* my_alloc(size_t ", gap: "size", postCode: ");", options: ["len", "size", "width", "byte"], answer: "size", explanation: "메모리 크기를 받을 때는 보통 size 변수명을 씁니다." },
                        { context: "Step 2: 힙 시작 주소", preCode: "static uint8_t ", gap: "heap", postCode: "[1024];", options: ["stack", "heap", "mem", "pool"], answer: "heap", explanation: "정적 배열을 힙 공간처럼 시뮬레이션 합니다." },
                        { context: "Step 3: 형변환 (Casting)", preCode: "Header *h = (Header*)", gap: "ptr", postCode: ";", options: ["&ptr", "ptr", "*ptr", "mem"], answer: "ptr", explanation: "void 포인터를 구체적인 타입으로 캐스팅합니다." },
                        { context: "Step 4: 포인터 연산", preCode: "void *next = (char*)ptr + ", gap: "size", postCode: ";", options: ["1", "size", "4", "8"], answer: "size", explanation: "바이트 단위 이동을 위해 char*로 변환 후 더합니다." },
                        { context: "Step 5: 구조체 멤버 접근", preCode: "h", gap: "->", postCode: "is_free = 0;", options: [".", "->", "::", ":"], answer: "->", explanation: "포인터로 구조체 멤버 접근 시 화살표 연산자를 씁니다." },
                        { context: "Step 6: 메모리 초기화 (memset)", preCode: "", gap: "memset", postCode: "(ptr, 0, size);", options: ["bzero", "memcpy", "memset", "clear"], answer: "memset", explanation: "메모리 블록을 특정 값으로 채울 때 memset을 씁니다." },
                        { context: "Step 7: 메모리 복사 (memcpy)", preCode: "", gap: "memcpy", postCode: "(dest, src, n);", options: ["strcpy", "move", "memcpy", "copy"], answer: "memcpy", explanation: "메모리 블록 복사는 memcpy를 사용합니다." },
                        { context: "Step 8: 더블 포인터", preCode: "void update_ref(int ", gap: "**", postCode: "handle);", options: ["*", "**", "&", "&&"], answer: "**", explanation: "포인터의 값을 바꾸려면 더블 포인터를 씁니다." },
                        { context: "Step 9: NULL 체크 매크로", preCode: "#define ASSERT(x) if(!(x)) ", gap: "abort()", postCode: "", options: ["exit()", "return", "abort()", "stop()"], answer: "abort()", explanation: "치명적 오류 발생 시 abort()로 강제 종료합니다." },
                        { context: "Step 10: 바이트 정렬 (Alignment)", preCode: "size = (size + 3) & ", gap: "~3", postCode: ";", options: ["~3", "0xFF", "|3", "^3"], answer: "~3", explanation: "4바이트 단위 정렬을 위한 비트 연산 트릭입니다." },
                        { context: "Step 11: 유니온 사용", preCode: "union { int i; float f; } ", gap: "u", postCode: ";", options: ["data", "u", "x", "var"], answer: "u", explanation: "메모리를 공유하는 공용체(union) 변수 선언입니다." },
                        { context: "Step 12: 비트 필드 구조체", preCode: "struct { unsigned int flag:", gap: "1", postCode: "; };", options: ["1", "int", "bool", "0"], answer: "1", explanation: "1비트 크기의 필드를 지정합니다." },
                        { context: "Step 13: 메모리 해제 시뮬레이션", preCode: "void my_free(void *ptr) { h->is_free = ", gap: "1", postCode: "; }", options: ["0", "1", "true", "null"], answer: "1", explanation: "해제된 상태를 플래그(1)로 표시합니다." },
                        { context: "Step 14: 오버플로우 방지", preCode: "if (current + size > ", gap: "END", postCode: ") return NULL;", options: ["START", "END", "MAX", "LIMIT"], answer: "END", explanation: "메모리 끝 범위를 넘는지 확인합니다." },
                        { context: "Step 15: 디버그 출력", preCode: "printf(\"Alloc: %p\\n\", ", gap: "ptr", postCode: ");", options: ["&ptr", "*ptr", "ptr", "mem"], answer: "ptr", explanation: "포인터 주소 출력 포맷은 %p이고 값을 넘깁니다." }
                    ]
                }
            ],
            'C#': [
                {
                    id: 'cs_login',
                    type: 'login_form',
                    title: '로그인 시스템',
                    questions: [
                        { context: "Step 1: 시스템 라이브러리 사용", preCode: "", gap: "using", postCode: " System;\nusing System.Windows.Forms;", options: ["import", "include", "using", "from"], answer: "using", explanation: "네임스페이스를 가져올 때는 using을 사용합니다." },
                        { context: "Step 2: 네임스페이스 선언", preCode: "", gap: "namespace", postCode: " MyApp {\n    // ...\n}", options: ["package", "module", "namespace", "region"], answer: "namespace", explanation: "코드를 그룹화하는 네임스페이스를 선언합니다." },
                        { context: "Step 3: 폼 클래스 상속", preCode: "public class LoginForm ", gap: ":", postCode: " Form {\n    // Form Logic\n}", options: ["extends", ":", "implements", "->"], answer: ":", explanation: "C#에서 상속은 콜론(:)을 사용합니다." },
                        { context: "Step 4: 상수 타이틀 정의", preCode: "    ", gap: "const", postCode: " string TITLE = \"Login App\";", options: ["final", "static", "const", "readonly"], answer: "const", explanation: "변하지 않는 값은 const로 선언합니다." },
                        { context: "Step 5: 연결 상태 열거형 정의", preCode: "    public ", gap: "enum", postCode: " State { Disconnected, Connected }", options: ["type", "enum", "list", "option"], answer: "enum", explanation: "상태 목록을 정의할 때는 enum을 사용합니다." },
                        { context: "Step 6: 유저명 프로퍼티 (Getter/Setter)", preCode: "    public string Username { get; ", gap: "set", postCode: "; }", options: ["put", "set", "let", "init"], answer: "set", explanation: "프로퍼티의 값을 설정하는 접근자는 set입니다." },
                        { context: "Step 7: 인증 인터페이스 정의", preCode: "    public ", gap: "interface", postCode: " IAuthenticator {\n        bool Validate(string u);\n    }", options: ["class", "struct", "interface", "protocol"], answer: "interface", explanation: "기능의 명세는 interface로 정의합니다." },
                        { context: "Step 8: 생성자 및 부모 초기화", preCode: "    public LoginForm() : ", gap: "base", postCode: "() {\n        InitializeComponent();\n    }", options: ["super", "parent", "base", "root"], answer: "base", explanation: "부모 클래스의 생성자를 호출할 때는 base 키워드를 사용합니다." },
                        { context: "Step 9: UI 버튼 객체 생성", preCode: "    Button btn = ", gap: "new", postCode: " Button();", options: ["alloc", "create", "new", "make"], answer: "new", explanation: "객체(인스턴스)를 생성할 때는 new 키워드를 씁니다." },
                        { context: "Step 10: 비동기 로그인 메서드", preCode: "    public ", gap: "async", postCode: " void OnLoginClick(object s, EventArgs e)", options: ["await", "async", "sync", "void"], answer: "async", explanation: "비동기 메서드를 선언할 때는 async 키워드를 붙입니다." },
                        { context: "Step 11: 타입 추론 변수 선언", preCode: "        ", gap: "var", postCode: " db = new DatabaseConnection();", options: ["let", "auto", "var", "dim"], answer: "var", explanation: "우변에서 타입을 알 수 있을 때 var를 사용합니다." },
                        { context: "Step 12: 환영 메시지 (문자열 보간)", preCode: "        string msg = ", gap: "$", postCode: "\"Welcome, {Username}!\";", options: ["@", "$", "#", "%"], answer: "$", explanation: "문자열 내 변수를 쓰려면 $를 앞에 붙입니다." },
                        { context: "Step 13: 널 조건부 연산자", preCode: "        int? len = Username", gap: "?.", postCode: "Length;", options: [".", "?.", "!!", "??"], answer: "?.", explanation: "객체가 null일 수 있을 때 안전하게 접근하려면 ?.를 씁니다." },
                        { context: "Step 14: 데이터 필터링 (LINQ)", preCode: "        var admins = users.", gap: "Where", postCode: "(u => u.IsAdmin);", options: ["Filter", "Select", "Where", "Find"], answer: "Where", explanation: "조건에 맞는 요소를 찾을 때는 LINQ의 Where를 씁니다." },
                        { context: "Step 15: 디버그 로그 출력", preCode: "        ", gap: "Console.WriteLine", postCode: "(\"Login Sequence Complete\");", options: ["print", "Console.WriteLine", "Debug.Log", "System.out"], answer: "Console.WriteLine", explanation: "콘솔에 내용을 출력할 때는 Console.WriteLine을 사용합니다." }
                    ]
                },
                {
                    id: 'cs_shop',
                    type: 'inventory_list',
                    title: '쇼핑몰 재고 관리',
                    questions: [
                        { context: "Step 1: 제네릭 리스트 사용", preCode: "List<Product> items = ", gap: "new", postCode: " List<Product>();", options: ["alloc", "create", "new", "make"], answer: "new", explanation: "객체 생성은 new 키워드를 사용합니다." },
                        { context: "Step 2: 클래스 정의", preCode: "public ", gap: "class", postCode: " Product { public int Id; }", options: ["struct", "class", "object", "type"], answer: "class", explanation: "참조 타입 정의는 class를 사용합니다." },
                        { context: "Step 3: Decimal 타입 (화폐)", preCode: "    public ", gap: "decimal", postCode: " Price { get; set; }", options: ["float", "double", "decimal", "money"], answer: "decimal", explanation: "화폐 연산에는 정밀한 decimal 타입을 씁니다." },
                        { context: "Step 4: 생성자 오버로딩", preCode: "    public Product(int id) ", gap: "{", postCode: " this.Id = id; }", options: ["{", "(", "[", ":"], answer: "{", explanation: "생성자 본문은 중괄호로 감쌉니다." },
                        { context: "Step 5: 리스트에 추가", preCode: "items.", gap: "Add", postCode: "(new Product(1));", options: ["Push", "Append", "Add", "Insert"], answer: "Add", explanation: "C# List에 요소를 넣을 때는 Add 메서드를 씁니다." },
                        { context: "Step 6: Foreach 반복문", preCode: "", gap: "foreach", postCode: " (var item in items) { ... }", options: ["for", "foreach", "loop", "in"], answer: "foreach", explanation: "컬렉션 순회는 foreach가 편리합니다." },
                        { context: "Step 7: 람다식 검색 (Find)", preCode: "var p = items.Find(x ", gap: "=>", postCode: " x.Id == 1);", options: ["->", "=>", ":", "."], answer: "=>", explanation: "람다 연산자는 => 입니다." },
                        { context: "Step 8: 예외 던지기", preCode: "if (p == null) throw ", gap: "new", postCode: " Exception(\"Not Found\");", options: ["create", "make", "new", "error"], answer: "new", explanation: "예외 객체도 new로 생성하여 던집니다." },
                        { context: "Step 9: 문자열 포맷팅", preCode: "string s = string.", gap: "Format", postCode: "(\"Price: {0:C}\", p.Price);", options: ["Print", "Format", "Join", "Concat"], answer: "Format", explanation: "string.Format을 사용하여 문자열을 구성합니다." },
                        { context: "Step 10: 딕셔너리 사용", preCode: "Dictionary<int, string> names = ", gap: "new", postCode: "();", options: ["new", "create", "alloc", "map"], answer: "new", explanation: "키-값 쌍 저장소는 Dictionary입니다." },
                        { context: "Step 11: 널 병합 연산자", preCode: "string n = name ", gap: "??", postCode: " \"Unknown\";", options: ["?:", "??", "||", "or"], answer: "??", explanation: "null일 경우 대체값을 지정하는 ?? 연산자입니다." },
                        { context: "Step 12: 확장 메서드 정의", preCode: "public static void Print( ", gap: "this", postCode: " Product p )", options: ["ref", "out", "this", "ext"], answer: "this", explanation: "확장 메서드는 첫 인자에 this 키워드를 붙입니다." },
                        { context: "Step 13: LINQ Select", preCode: "var prices = items.", gap: "Select", postCode: "(i => i.Price);", options: ["Map", "Select", "Choose", "Pick"], answer: "Select", explanation: "데이터 변환(매핑)은 LINQ Select를 씁니다." },
                        { context: "Step 14: 익명 타입", preCode: "var info = new ", gap: "{", postCode: " Name=\"A\", Cost=10 };", options: ["(", "[", "{", "<"], answer: "{", explanation: "익명 타입 초기화는 중괄호를 사용합니다." },
                        { context: "Step 15: 콘솔 키 입력 대기", preCode: "Console.", gap: "ReadKey", postCode: "();", options: ["Read", "ReadLine", "ReadKey", "Wait"], answer: "ReadKey", explanation: "키 입력을 기다릴 때 ReadKey를 씁니다." }
                    ]
                },
                {
                    id: 'cs_unity',
                    type: 'unity_box',
                    title: 'Unity 3D 스크립트',
                    questions: [
                        { context: "Step 1: 모노비헤이비어 상속", preCode: "public class Player : ", gap: "MonoBehaviour", postCode: "", options: ["Behaviour", "MonoBehaviour", "UnityObject", "Actor"], answer: "MonoBehaviour", explanation: "유니티 컴포넌트는 MonoBehaviour를 상속받습니다." },
                        { context: "Step 2: 초기화 메서드", preCode: "void ", gap: "Start", postCode: "() { }", options: ["Init", "Begin", "Start", "OnLoad"], answer: "Start", explanation: "객체 활성화 시 최초 1회 실행되는 Start 메서드입니다." },
                        { context: "Step 3: 프레임 갱신 메서드", preCode: "void ", gap: "Update", postCode: "() { }", options: ["Loop", "Update", "Tick", "Draw"], answer: "Update", explanation: "매 프레임마다 호출되는 Update 메서드입니다." },
                        { context: "Step 4: 벡터 이동", preCode: "transform.Translate(Vector3.", gap: "forward", postCode: " * speed);", options: ["front", "forward", "up", "one"], answer: "forward", explanation: "앞쪽 방향 벡터는 Vector3.forward입니다." },
                        { context: "Step 5: 델타 타임 사용", preCode: "float move = speed * Time.", gap: "deltaTime", postCode: ";", options: ["time", "deltaTime", "fixedTime", "delta"], answer: "deltaTime", explanation: "프레임 간 시간 차이를 곱해 이동 속도를 일정하게 합니다." },
                        { context: "Step 6: 키 입력 확인", preCode: "if (Input.", gap: "GetKeyDown", postCode: "(KeyCode.Space))", options: ["GetKey", "GetKeyDown", "OnKey", "Press"], answer: "GetKeyDown", explanation: "키를 누르는 순간을 감지합니다." },
                        { context: "Step 7: 컴포넌트 가져오기", preCode: "Rigidbody rb = ", gap: "GetComponent", postCode: "<Rigidbody>();", options: ["Get", "Find", "GetComponent", "Fetch"], answer: "GetComponent", explanation: "같은 객체의 다른 컴포넌트를 가져옵니다." },
                        { context: "Step 8: 물리 힘 가하기", preCode: "rb.", gap: "AddForce", postCode: "(Vector3.up * 10);", options: ["Push", "AddForce", "Move", "Velocity"], answer: "AddForce", explanation: "리지드바디에 힘을 가해 움직입니다." },
                        { context: "Step 9: 직렬화 필드 (에디터 노출)", preCode: "[", gap: "SerializeField", postCode: "]\nprivate int health;", options: ["Public", "Edit", "SerializeField", "Show"], answer: "SerializeField", explanation: "private 변수를 에디터 창에 노출시킵니다." },
                        { context: "Step 10: 충돌 감지", preCode: "void ", gap: "OnCollisionEnter", postCode: "(Collision col)", options: ["OnHit", "OnCollisionEnter", "Collide", "Touch"], answer: "OnCollisionEnter", explanation: "물리적 충돌이 시작될 때 호출됩니다." },
                        { context: "Step 11: 게임 오브젝트 파괴", preCode: "", gap: "Destroy", postCode: "(gameObject);", options: ["Delete", "Remove", "Destroy", "Kill"], answer: "Destroy", explanation: "오브젝트를 씬에서 제거할 때 Destroy를 씁니다." },
                        { context: "Step 12: 코루틴 시작", preCode: "", gap: "StartCoroutine", postCode: "(Wait());", options: ["Run", "StartCoroutine", "Async", "Await"], answer: "StartCoroutine", explanation: "비동기 작업을 위해 코루틴을 시작합니다." },
                        { context: "Step 13: 코루틴 대기 (Yield)", preCode: "yield return new ", gap: "WaitForSeconds", postCode: "(1f);", options: ["Wait", "Sleep", "WaitForSeconds", "Delay"], answer: "WaitForSeconds", explanation: "지정된 시간만큼 대기합니다." },
                        { context: "Step 14: 씬 로드", preCode: "SceneManager.", gap: "LoadScene", postCode: "(\"Level2\");", options: ["GoTo", "LoadScene", "Open", "Change"], answer: "LoadScene", explanation: "다른 씬(레벨)으로 전환합니다." },
                        { context: "Step 15: 로그 출력", preCode: "Debug.", gap: "Log", postCode: "(\"Game Over\");", options: ["Print", "Log", "Write", "Show"], answer: "Log", explanation: "유니티 콘솔에 메시지를 띄웁니다." }
                    ]
                }
            ],
            'C++': [
                {
                    id: 'cpp_engine',
                    type: 'rpg_grid', // Reusing grid but styled differently? Or separate. Let's use grid for simplicity but maybe different logic.
                    title: '게임 엔진 (Renderer)',
                    questions: [
                        { context: "Step 1: 입출력 스트림 포함", preCode: "#include <", gap: "iostream", postCode: ">", options: ["stdio.h", "iostream", "string", "vector"], answer: "iostream", explanation: "C++ 입출력은 iostream 헤더를 사용합니다." },
                        { context: "Step 2: 표준 네임스페이스 사용", preCode: "using namespace ", gap: "std", postCode: ";", options: ["cpp", "std", "stl", "core"], answer: "std", explanation: "표준 라이브러리는 std 네임스페이스 안에 있습니다." },
                        { context: "Step 3: 좌표 템플릿 정의 (제네릭)", preCode: "", gap: "template", postCode: " <typename T>\nstruct Vec2 { T x, y; };", options: ["generic", "template", "class", "meta"], answer: "template", explanation: "다양한 타입에 대응하는 구조체는 template으로 만듭니다." },
                        { context: "Step 4: 게임 엔티티 클래스", preCode: "class Entity {\npublic:\n    ", gap: "virtual", postCode: " void Update() = 0;", options: ["static", "virtual", "inline", "friend"], answer: "virtual", explanation: "자식 클래스에서 오버라이드할 함수는 virtual로 선언합니다." },
                        { context: "Step 5: 플레이어 상속", preCode: "class Player : ", gap: "public", postCode: " Entity {\n    // ...\n};", options: ["extends", "public", "virtual", "super"], answer: "public", explanation: "일반적인 상속 접근 지정자는 public입니다." },
                        { context: "Step 6: 정적 멤버 (적 카운트)", preCode: "    ", gap: "static", postCode: " int enemyCount;", options: ["const", "global", "static", "shared"], answer: "static", explanation: "모든 인스턴스가 공유하는 변수는 static입니다." },
                        { context: "Step 7: 엔티티 목록 (벡터)", preCode: "#include <vector>\n", gap: "vector", postCode: "<Entity*> entities;", options: ["list", "array", "vector", "deque"], answer: "vector", explanation: "크기가 변하는 배열은 std::vector를 사용합니다." },
                        { context: "Step 8: 스마트 포인터 사용", preCode: "#include <memory>\nstd::", gap: "unique_ptr", postCode: "<Player> p = std::make_unique<Player>();", options: ["auto_ptr", "unique_ptr", "smart_ptr", "weak_ptr"], answer: "unique_ptr", explanation: "자동으로 메모리를 해제해주는 스마트 포인터입니다." },
                        { context: "Step 9: 자동 타입 추론 반복", preCode: "for (", gap: "auto", postCode: " e : entities) {\n    e->Update();\n}", options: ["var", "let", "auto", "int"], answer: "auto", explanation: "타입을 컴파일러가 알아서 추론하게 하려면 auto를 씁니다." },
                        { context: "Step 10: 범위 기반 for문", preCode: "for (int id ", gap: ":", postCode: " activeIds) {\n    // process\n}", options: ["in", ":", "of", "from"], answer: ":", explanation: "컨테이너의 모든 요소를 순회할 때 콜론(:)을 씁니다." },
                        { context: "Step 11: 참조자에 의한 전달", preCode: "void Move(Vec2<int>", gap: "&", postCode: " pos) {\n    this->pos = pos;\n}", options: ["*", "&", "ref", "%"], answer: "&", explanation: "복사 비용을 줄이기 위해 참조자(&)를 사용합니다." },
                        { context: "Step 12: 멤버 접근 화살표", preCode: "Entity* e = new Player();\ne", gap: "->", postCode: "Update();", options: [".", "->", "::", ":"], answer: "->", explanation: "포인터로 객체 멤버에 접근할 때는 -> 연산자를 씁니다." },
                        { context: "Step 13: 사용자 입력 받기", preCode: "char key;\n", gap: "cin", postCode: " >> key;", options: ["cout", "scan", "cin", "get"], answer: "cin", explanation: "C++ 표준 입력 스트림은 cin입니다." },
                        { context: "Step 14: 화면 출력", preCode: "", gap: "cout", postCode: " << \"Game Over\" << endl;", options: ["cin", "print", "cout", "out"], answer: "cout", explanation: "C++ 표준 출력 스트림은 cout입니다." },
                        { context: "Step 15: 소멸자 정의 (메모리 해제)", preCode: "    ", gap: "~", postCode: "Player() {\n        cout << \"Destroyed\";\n    }", options: ["-", "!", "~", "#"], answer: "~", explanation: "객체가 파괴될 때 호출되는 소멸자는 ~로 시작합니다." }
                    ]
                },
                {
                    id: 'cpp_bank',
                    type: 'bank_log',
                    title: '은행 거래 시스템',
                    questions: [
                        { context: "Step 1: 맵 컨테이너 사용", preCode: "#include <map>\nstd::", gap: "map", postCode: "<string, int> accounts;", options: ["list", "map", "set", "vector"], answer: "map", explanation: "Key-Value 쌍을 저장할 때 map을 사용합니다." },
                        { context: "Step 2: 예외 처리 (Try)", preCode: "", gap: "try", postCode: " {\n    process_transaction();\n}", options: ["try", "do", "test", "attempt"], answer: "try", explanation: "예외가 발생할 수 있는 코드를 try 블록에 넣습니다." },
                        { context: "Step 3: 예외 던지기", preCode: "if (bal < amount) throw std::", gap: "runtime_error", postCode: "(\"No funds\");", options: ["error", "exception", "runtime_error", "fail"], answer: "runtime_error", explanation: "실행 중 오류는 runtime_error를 던집니다." },
                        { context: "Step 4: 예외 잡기 (Catch)", preCode: "} ", gap: "catch", postCode: " (const std::exception& e) { ... }", options: ["except", "catch", "handle", "error"], answer: "catch", explanation: "던져진 예외를 받아서 처리하는 블록입니다." },
                        { context: "Step 5: 상수 참조 전달", preCode: "void Login(const string", gap: "&", postCode: " name)", options: ["*", "&", "&&", "."], answer: "&", explanation: "복사를 피하고 원본을 보호하려면 const 참조(&)를 씁니다." },
                        { context: "Step 6: 문자열 찾기", preCode: "if (accounts.", gap: "find", postCode: "(name) == accounts.end())", options: ["search", "has", "find", "get"], answer: "find", explanation: "맵에서 키를 찾을 때 find를 씁니다." },
                        { context: "Step 7: 반복자 (Iterator)", preCode: "std::map<string, int>::", gap: "iterator", postCode: " it = accounts.begin();", options: ["ptr", "cursor", "iterator", "index"], answer: "iterator", explanation: "컨테이너를 순회하는 객체는 반복자입니다." },
                        { context: "Step 8: 화살표로 페어 접근", preCode: "cout << it", gap: "->", postCode: "first << \": \" << it->second;", options: [".", "->", "::", "."], answer: "->", explanation: "반복자는 포인터처럼 동작하므로 ->를 씁니다." },
                        { context: "Step 9: 클래스 생성자", preCode: "Account(int b) ", gap: ":", postCode: " balance(b) {}", options: ["=", ":", "{", "->"], answer: ":", explanation: "초기화 리스트는 콜론(:)으로 시작합니다." },
                        { context: "Step 10: 소멸자 (가상함수)", preCode: "virtual ", gap: "~", postCode: "Account() {}", options: ["!", "-", "~", "#"], answer: "~", explanation: "상속 시 소멸자는 반드시 가상함수(virtual ~)여야 합니다." },
                        { context: "Step 11: 동적 캐스트", preCode: "VIP* v = ", gap: "dynamic_cast", postCode: "<VIP*>(acc);", options: ["static_cast", "dynamic_cast", "cast", "convert"], answer: "dynamic_cast", explanation: "안전한 다운캐스팅에는 dynamic_cast를 씁니다." },
                        { context: "Step 12: 네임스페이스 정의", preCode: "", gap: "namespace", postCode: " BankSystem { ... }", options: ["package", "module", "namespace", "class"], answer: "namespace", explanation: "이름 충돌 방지를 위해 네임스페이스를 씁니다." },
                        { context: "Step 13: 친구 함수 (Friend)", preCode: "", gap: "friend", postCode: " void AdminFunc();", options: ["public", "friend", "static", "extern"], answer: "friend", explanation: "private 멤버에 접근 권한을 주는 friend 키워드입니다." },
                        { context: "Step 14: 파일 출력 스트림", preCode: "std::", gap: "ofstream", postCode: " file(\"log.txt\");", options: ["ifstream", "ofstream", "fstream", "file"], answer: "ofstream", explanation: "파일 쓰기용 스트림은 ofstream입니다." },
                        { context: "Step 15: 스트림 닫기", preCode: "file.", gap: "close", postCode: "();", options: ["end", "stop", "close", "flush"], answer: "close", explanation: "사용이 끝난 파일 스트림은 닫아야 합니다." }
                    ]
                },
                {
                    id: 'cpp_sort',
                    type: 'sort_visual',
                    title: '정렬 알고리즘 (Sort)',
                    questions: [
                        { context: "Step 1: 벡터 헤더", preCode: "#include <", gap: "vector", postCode: ">", options: ["list", "array", "vector", "collection"], answer: "vector", explanation: "동적 배열 벡터를 사용하기 위한 헤더입니다." },
                        { context: "Step 2: 알고리즘 헤더", preCode: "#include <", gap: "algorithm", postCode: ">", options: ["math", "sort", "algorithm", "func"], answer: "algorithm", explanation: "sort 함수 등이 포함된 헤더입니다." },
                        { context: "Step 3: 벡터 초기화", preCode: "vector<int> v = {3, 1, 4, 1, 5};\nv.", gap: "push_back", postCode: "(9);", options: ["add", "push", "push_back", "insert"], answer: "push_back", explanation: "벡터 뒤에 요소를 추가합니다." },
                        { context: "Step 4: 오름차순 정렬", preCode: "std::", gap: "sort", postCode: "(v.begin(), v.end());", options: ["order", "sort", "arrange", "qsort"], answer: "sort", explanation: "표준 정렬 함수 sort를 사용합니다." },
                        { context: "Step 5: 람다 비교 함수", preCode: "sort(v.begin(), v.end(), [](", gap: "int a, int b", postCode: ") { return a > b; });", options: ["a, b", "int a, int b", "x, y", "auto"], answer: "int a, int b", explanation: "비교 함수 인자를 정의합니다." },
                        { context: "Step 6: 반복자 사용", preCode: "for (auto it = v.begin(); it != v.", gap: "end", postCode: "(); ++it)", options: ["last", "stop", "end", "finish"], answer: "end", explanation: "반복자의 끝을 나타내는 end()입니다." },
                        { context: "Step 7: 요소 스왑", preCode: "std::", gap: "swap", postCode: "(v[0], v[1]);", options: ["change", "move", "swap", "switch"], answer: "swap", explanation: "두 변수의 값을 맞바꾸는 함수입니다." },
                        { context: "Step 8: 벡터 크기", preCode: "int n = v.", gap: "size", postCode: "();", options: ["length", "count", "size", "len"], answer: "size", explanation: "요소의 개수는 size()로 반환합니다." },
                        { context: "Step 9: 인덱스 접근", preCode: "int val = v.", gap: "at", postCode: "(2);", options: ["get", "at", "[2]", "value"], answer: "at", explanation: "범위 체크를 포함한 접근은 at() 함수를 씁니다." },
                        { context: "Step 10: 역순 정렬 객체", preCode: "sort(v.begin(), v.end(), std::", gap: "greater", postCode: "<int>());", options: ["less", "greater", "desc", "asc"], answer: "greater", explanation: "내림차순 정렬 시 greater 함수 객체를 씁니다." },
                        { context: "Step 11: 이진 탐색", preCode: "bool found = std::", gap: "binary_search", postCode: "(v.begin(), v.end(), 5);", options: ["find", "search", "binary_search", "scan"], answer: "binary_search", explanation: "정렬된 범위에서 빠르게 값을 찾습니다." },
                        { context: "Step 12: 최대값 요소", preCode: "auto max_it = std::", gap: "max_element", postCode: "(v.begin(), v.end());", options: ["max", "maximum", "max_element", "top"], answer: "max_element", explanation: "가장 큰 요소를 가리키는 반복자를 반환합니다." },
                        { context: "Step 13: 벡터 비우기", preCode: "v.", gap: "clear", postCode: "();", options: ["empty", "delete", "clear", "erase"], answer: "clear", explanation: "모든 요소를 제거합니다." },
                        { context: "Step 14: 미리 공간 확보", preCode: "v.", gap: "reserve", postCode: "(100);", options: ["alloc", "reserve", "resize", "set"], answer: "reserve", explanation: "재할당을 막기 위해 메모리를 미리 확보합니다." },
                        { context: "Step 15: 범위 기반 for (참조)", preCode: "for (auto", gap: "&", postCode: " x : v) x *= 2;", options: ["*", "&", "&&", "copy"], answer: "&", explanation: "값을 수정하려면 참조(&)로 순회해야 합니다." }
                    ]
                }
            ]
        };

        const FILLER_CODE = [
            "import sys; sys.setrecursionlimit(1000)",
            "void* memory = malloc(1024 * 1024);",
            "public static void Main(string[] args) {",
            "template <typename T> class Matrix {",
            "while(true) { process_event(e); }",
            "if (buffer_overflow) return -1;",
            "try { connect_to_server(); } catch(e) {}",
            "const int MAX_USERS = 5000;",
            "// Optimization needed here",
            "return this->value * 0.5f;",
            "await db.SaveChangesAsync();",
            "std::map<string, int> cache;",
            "for(auto it = begin; it != end; ++it)",
            "// TODO: Refactor this mess",
            "docker build -t myapp .",
            "git commit -m 'wip'",
            "npm install react-dom"
        ];

        // --- DASHBOARD PREVIEW COMPONENT (DYNAMIC) ---
        const ProjectPreview = ({ language, scenarioType, progress, isInteractive }) => {
            const [logs, setLogs] = useState([]);
            const logEndRef = useRef(null);
            
            // Visual State for various dashboards
            const [chartData, setChartData] = useState([40, 70, 50, 90]); // Python AI/Finance
            const [heroPos, setHeroPos] = useState({ x: 2, y: 3 }); // C/C++ RPG
            const [loginState, setLoginState] = useState('form'); // C# Login
            const [trafficState, setTrafficState] = useState(0); // C Traffic (0:Red, 1:Yellow, 2:Green)
            const [memBlocks, setMemBlocks] = useState(Array(16).fill(false)); // C Memory
            const [sortData, setSortData] = useState([5, 2, 8, 1, 9, 3]); // C++ Sort
            const [cubeRot, setCubeRot] = useState(0); // C# Unity

            useEffect(() => {
                if (logEndRef.current) logEndRef.current.scrollIntoView({ behavior: 'smooth' });
            }, [logs]);

            // Simulate log generation based on progress
            useEffect(() => {
                const step = Math.floor(progress / (100/15)); 
                if (step > 0) {
                    let newLog = `> [Step ${step}] Processing...`;
                    
                    // Customize logs based on language/type
                    if (language === 'Python') newLog = `> In [${step}]: executing cell...`;
                    if (language === 'C') newLog = `> [0x${(4000+step*4).toString(16)}] MOV EAX, ${step}`;
                    if (language === 'C#') newLog = `> Build: Task ${step}/15 Complete`;
                    if (language === 'C++') newLog = `> Linker: Object_${step}.o connected`;

                    setLogs(prev => {
                        const last = prev[prev.length-1];
                        if (last !== newLog) return [...prev, newLog].slice(-6);
                        return prev;
                    });
                }
            }, [progress, language]);

            // --- Interactions ---
            const refreshChart = () => { if (!isInteractive) return; setChartData(Array.from({length: 4}, () => Math.floor(Math.random() * 80) + 20)); };
            
            const moveHero = (dir) => { 
                if (!isInteractive) return; 
                let {x, y} = heroPos;
                if(dir==='L') x = Math.max(0, x-1); if(dir==='R') x = Math.min(7, x+1);
                if(dir==='U') y = Math.max(0, y-1); if(dir==='D') y = Math.min(5, y+1);
                setHeroPos({x, y});
            };

            const toggleTraffic = () => { if (!isInteractive) return; setTrafficState(p => (p+1)%3); };
            const toggleMem = (i) => { if (!isInteractive) return; const n = [...memBlocks]; n[i] = !n[i]; setMemBlocks(n); };
            const rotateCube = () => { if (!isInteractive) return; setCubeRot(r => r + 45); };
            const shuffleSort = () => { if (!isInteractive) return; setSortData([...sortData].sort(() => Math.random() - 0.5)); };
            const tryLogin = () => { if (!isInteractive) return; setLoginState('processing'); setTimeout(() => setLoginState('success'), 1000); };

            // --- Render Logic Switch ---
            const renderContent = () => {
                switch(scenarioType) {
                    // PYTHON
                    case 'ai_chart':
                        return (
                            <div className="flex flex-col h-full gap-4 p-4">
                                <div className="bg-gray-800 rounded-xl p-4 flex-1 flex items-end justify-around relative cursor-pointer group border border-gray-700 hover:border-gray-500 transition-all" onClick={refreshChart}>
                                    {chartData.map((h, i) => (
                                        <div key={i} style={{ height: `${h}%` }} className={`w-8 md:w-16 transition-all duration-500 rounded-t-md bg-blue-500 shadow-[0_0_15px_rgba(59,130,246,0.5)]`}></div>
                                    ))}
                                    {isInteractive && <div className="absolute top-2 right-2 opacity-50 group-hover:opacity-100 transition-opacity"><RefreshCw size={24}/></div>}
                                </div>
                                <div className="h-1/3 text-sm md:text-base text-green-400 font-mono bg-black p-4 rounded-xl overflow-hidden border border-gray-800 shadow-inner">
                                    <div className="border-b border-gray-800 pb-1 mb-2 text-gray-500 font-bold">TERMINAL OUTPUT</div>
                                    {logs.map((l, i) => <div key={i}>{l}</div>)}
                                    <div ref={logEndRef} />
                                </div>
                            </div>
                        );
                    case 'finance_chart':
                        return (
                            <div className="flex flex-col h-full gap-4 p-4">
                                <div className="bg-gray-800 rounded-xl p-4 flex-1 relative cursor-pointer group border border-gray-700 hover:border-gray-500 transition-all overflow-hidden" onClick={refreshChart}>
                                     <div className="absolute inset-0 flex items-center justify-center">
                                        <svg viewBox="0 0 100 100" className="w-full h-full p-4 overflow-visible" preserveAspectRatio="none">
                                            {/* Grid Lines */}
                                            <line x1="0" y1="25" x2="100" y2="25" stroke="#374151" strokeWidth="0.5" />
                                            <line x1="0" y1="50" x2="100" y2="50" stroke="#374151" strokeWidth="0.5" />
                                            <line x1="0" y1="75" x2="100" y2="75" stroke="#374151" strokeWidth="0.5" />
                                            
                                            {/* Line Graph */}
                                            <polyline 
                                                fill="none" 
                                                stroke={chartData[chartData.length-1] > chartData[0] ? "#ef4444" : "#3b82f6"} 
                                                strokeWidth="2" 
                                                strokeLinecap="round"
                                                strokeLinejoin="round"
                                                points={chartData.map((h, i) => `${i * 33},${100 - h}`).join(' ')} 
                                                className="transition-all duration-500 ease-in-out"
                                            />
                                            {/* Points */}
                                            {chartData.map((h, i) => (
                                                <circle key={i} cx={i*33} cy={100-h} r="3" fill="white" className="transition-all duration-500 ease-in-out"/>
                                            ))}
                                        </svg>
                                    </div>
                                    <div className="absolute top-2 left-2 text-xs text-gray-400 font-mono">AAPL: ${100 + chartData[chartData.length-1]}.00</div>
                                    {isInteractive && <div className="absolute top-2 right-2 opacity-50 group-hover:opacity-100 transition-opacity"><RefreshCw size={24}/></div>}
                                </div>
                                <div className="h-1/3 text-sm md:text-base text-green-400 font-mono bg-black p-4 rounded-xl overflow-hidden border border-gray-800 shadow-inner">
                                    <div className="border-b border-gray-800 pb-1 mb-2 text-gray-500 font-bold">TERMINAL OUTPUT</div>
                                    {logs.map((l, i) => <div key={i}>{l}</div>)}
                                    <div ref={logEndRef} />
                                </div>
                            </div>
                        );
                    case 'scraper_log':
                        return (
                            <div className="h-full bg-black p-6 font-mono text-base md:text-lg text-gray-300 overflow-y-auto">
                                <div className="text-green-500 mb-2 font-bold">$ python scraper.py</div>
                                {logs.map((l, i) => (
                                    <div key={i} className="mb-1 border-l-2 border-gray-800 pl-2">
                                        <span className="text-blue-400 font-bold">[INFO]</span> {l.replace('>', '')} Found {Math.floor(Math.random()*10)} items.
                                    </div>
                                ))}
                                <div className="animate-pulse mt-2">_</div>
                            </div>
                        );

                    // C / C++
                    case 'rpg_grid':
                        return (
                            <div className="relative h-full bg-[#1a1a1a] p-4 font-mono flex flex-col">
                                <div className="flex-1 grid grid-cols-8 grid-rows-6 gap-2 mb-4 bg-black p-4 rounded-xl border border-gray-800 shadow-inner">
                                    {Array.from({ length: 48 }).map((_, i) => (
                                        <div key={i} className={`rounded transition-all duration-200 border border-white/5 ${i===heroPos.y*8+heroPos.x ? 'bg-blue-500 shadow-[0_0_15px_blue] scale-90' : 'bg-gray-900'}`}></div>
                                    ))}
                                </div>
                                <div className="h-24 text-sm md:text-base text-gray-400 border-t border-gray-800 pt-2 font-mono">
                                    <div className="text-gray-600 mb-1">GAME LOG:</div>
                                    {logs.map((l, i) => <div key={i}>{l}</div>)}
                                    <div ref={logEndRef} />
                                </div>
                                {isInteractive && (
                                    <div className="absolute bottom-6 right-6 grid grid-cols-3 gap-2 opacity-80 scale-125 origin-bottom-right p-4">
                                        <div/> <button className="bg-gray-700 w-12 h-12 rounded-lg flex items-center justify-center hover:bg-blue-600 shadow-lg active:scale-95 transition-all" onClick={()=>moveHero('U')}>▲</button> <div/>
                                        <button className="bg-gray-700 w-12 h-12 rounded-lg flex items-center justify-center hover:bg-blue-600 shadow-lg active:scale-95 transition-all" onClick={()=>moveHero('L')}>◀</button>
                                        <button className="bg-gray-700 w-12 h-12 rounded-lg flex items-center justify-center hover:bg-blue-600 shadow-lg active:scale-95 transition-all" onClick={()=>moveHero('D')}>▼</button>
                                        <button className="bg-gray-700 w-12 h-12 rounded-lg flex items-center justify-center hover:bg-blue-600 shadow-lg active:scale-95 transition-all" onClick={()=>moveHero('R')}>▶</button>
                                    </div>
                                )}
                            </div>
                        );
                    case 'traffic_light':
                        return (
                            <div className="h-full bg-slate-900 flex flex-col items-center justify-center gap-8 p-4 cursor-pointer" onClick={toggleTraffic}>
                                <div className="bg-black p-10 rounded-[3rem] flex flex-col gap-6 shadow-2xl border-4 border-gray-700">
                                    <div className={`w-24 h-24 rounded-full transition-all duration-300 border-4 border-black ${trafficState===0 ? 'bg-red-500 shadow-[0_0_60px_red] scale-110' : 'bg-red-950 opacity-30'}`}></div>
                                    <div className={`w-24 h-24 rounded-full transition-all duration-300 border-4 border-black ${trafficState===1 ? 'bg-yellow-400 shadow-[0_0_60px_yellow] scale-110' : 'bg-yellow-900 opacity-30'}`}></div>
                                    <div className={`w-24 h-24 rounded-full transition-all duration-300 border-4 border-black ${trafficState===2 ? 'bg-green-500 shadow-[0_0_60px_green] scale-110' : 'bg-green-950 opacity-30'}`}></div>
                                </div>
                                <div className="text-2xl text-gray-400 font-mono tracking-widest border border-gray-700 px-6 py-3 rounded bg-black">
                                    STATUS: <span className="text-white font-bold">0x{trafficState.toString(16).toUpperCase()}</span>
                                </div>
                            </div>
                        );
                    case 'memory_map':
                        return (
                            <div className="h-full bg-slate-900 p-6 font-mono flex flex-col">
                                <div className="text-base text-gray-400 mb-4 font-bold border-b border-gray-700 pb-2">KERNEL HEAP DUMP (Start: 0x4000)</div>
                                <div className="grid grid-cols-4 gap-4 flex-1 content-start">
                                    {memBlocks.map((active, i) => (
                                        <div key={i} onClick={() => toggleMem(i)} className={`h-16 md:h-24 rounded-xl border-2 cursor-pointer transition-all flex items-center justify-center text-sm md:text-base font-bold relative group ${active ? 'bg-green-600/20 border-green-500 text-green-400 shadow-[0_0_15px_rgba(34,197,94,0.3)]' : 'bg-gray-800/50 border-gray-700 text-gray-600 hover:bg-gray-800'}`}>
                                            0x{(4000 + i*4).toString(16)}
                                            <div className="absolute inset-0 bg-white/5 opacity-0 group-hover:opacity-100 transition-opacity rounded-xl"></div>
                                        </div>
                                    ))}
                                </div>
                                <div className="mt-4 p-4 bg-black rounded-xl border border-gray-800 text-sm md:text-base text-blue-300 font-mono">
                                    > Allocated: <span className="text-white font-bold">{memBlocks.filter(Boolean).length * 64}</span> Bytes
                                    <br/>> Free: <span className="text-white font-bold">{(16 - memBlocks.filter(Boolean).length) * 64}</span> Bytes
                                </div>
                            </div>
                        );
                    case 'bank_log':
                        return (
                            <div className="h-full bg-blue-950 p-6 font-mono text-base md:text-lg text-blue-100 flex flex-col">
                                <div className="border-b-2 border-blue-800 pb-3 mb-4 font-bold flex justify-between text-xl">
                                    <span>ATM TERMINAL v2.0</span>
                                    <span className="animate-pulse text-green-400">ONLINE</span>
                                </div>
                                <div className="flex-1 overflow-hidden font-mono space-y-3">
                                    {logs.map((l, i) => (
                                        <div key={i} className="opacity-80 border-l-2 border-blue-700 pl-3">
                                            <span className="text-blue-400">[{new Date().toLocaleTimeString()}]</span> TR_ID#{1000+i}: {l.includes('Linker') ? 'Transaction Pending' : 'Verifying...'}
                                        </div>
                                    ))}
                                    <div className="text-yellow-400 mt-6 animate-bounce font-bold text-center border-2 border-yellow-400/30 p-3 rounded-lg bg-yellow-400/10 text-xl">PLEASE INSERT CARD...</div>
                                </div>
                            </div>
                        );
                    case 'sort_visual':
                        return (
                            <div className="h-full bg-slate-800 p-8 flex flex-col items-center justify-center cursor-pointer" onClick={shuffleSort}>
                                <div className="flex items-end gap-3 md:gap-6 h-80 w-full justify-center bg-black/30 p-6 rounded-2xl border border-gray-700">
                                    {sortData.map((val, i) => (
                                        <div key={i} style={{height: `${val*10}%`}} className="w-10 md:w-16 bg-gradient-to-t from-purple-700 to-purple-400 rounded-t-xl transition-all duration-300 shadow-[0_0_20px_rgba(168,85,247,0.4)] relative group">
                                            <div className="absolute -top-8 left-1/2 -translate-x-1/2 text-sm font-bold text-white opacity-0 group-hover:opacity-100 transition-opacity bg-black px-2 py-1 rounded border border-gray-700">{val}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="text-lg text-gray-400 mt-6 font-mono bg-black px-6 py-3 rounded-full border border-gray-700 hover:border-purple-500 transition-colors">Click to Shuffle Array</div>
                            </div>
                        );

                    // C#
                    case 'login_form':
                        return (
                            <div className="h-full bg-slate-800 p-8 flex flex-col items-center justify-center">
                                <div className="bg-gray-100 rounded-xl w-full max-w-md flex flex-col shadow-2xl overflow-hidden transform scale-125">
                                    <div className="bg-gradient-to-r from-blue-700 to-blue-900 h-10 flex items-center px-4 justify-between">
                                        <span className="text-white text-sm font-bold">LoginApp.exe</span>
                                        <div className="flex gap-2">
                                            <div className="w-3 h-3 rounded-full bg-red-500"></div>
                                            <div className="w-3 h-3 rounded-full bg-yellow-500"></div>
                                        </div>
                                    </div>
                                    <div className="p-10 flex flex-col gap-6 items-center justify-center min-h-[300px] bg-white">
                                        {loginState === 'success' ? (
                                            <div className="text-green-600 font-bold animate-in zoom-in duration-300 flex flex-col items-center gap-4">
                                                <div className="p-4 bg-green-100 rounded-full"><CheckCircle size={64}/></div>
                                                <span className="text-2xl">Login Successful</span>
                                            </div>
                                        ) : (
                                            <>
                                                <div className="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mb-4">
                                                    <User size={48} className="text-gray-400"/>
                                                </div>
                                                <div className="w-full h-12 bg-gray-50 border border-gray-300 rounded px-4 text-base flex items-center text-gray-400 shadow-inner">Username</div>
                                                <div className="w-full h-12 bg-gray-50 border border-gray-300 rounded px-4 text-base flex items-center text-gray-400 shadow-inner">••••••••</div>
                                                <button onClick={tryLogin} className={`w-full py-3 mt-4 bg-blue-600 hover:bg-blue-700 text-white text-base font-bold rounded shadow-lg transition-all active:scale-95 ${loginState==='processing'?'opacity-70 cursor-wait':''}`}>
                                                    {loginState==='processing'?'Connecting...':'Login'}
                                                </button>
                                            </>
                                        )}
                                    </div>
                                </div>
                                <div className="mt-10 text-sm text-gray-500 font-mono bg-black/50 px-6 py-3 rounded-full border border-gray-700">
                                    Debug Console: Waiting for user input...
                                </div>
                            </div>
                        );
                    case 'inventory_list':
                        return (
                            <div className="h-full bg-white text-black p-6 font-sans text-base flex flex-col shadow-inner">
                                <div className="font-bold border-b-2 border-gray-200 pb-3 mb-3 text-xl flex justify-between items-center">
                                    <span>Stock Manager</span>
                                    <span className="text-sm font-normal bg-green-100 text-green-800 px-3 py-1 rounded-full">Connected</span>
                                </div>
                                <table className="w-full text-left border-collapse text-lg">
                                    <thead>
                                        <tr className="bg-gray-100 text-gray-600 text-sm uppercase tracking-wider">
                                            <th className="p-3 rounded-l">ID</th>
                                            <th className="p-3">Item</th>
                                            <th className="p-3 rounded-r text-right">Qty</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-100">
                                        <tr className="hover:bg-blue-50 transition-colors"><td className="p-4 font-mono text-gray-500">#001</td><td className="p-4 font-bold">Apple MacBook</td><td className="p-4 text-right font-mono text-blue-600 font-bold text-xl">{Math.floor(progress/5)}</td></tr>
                                        <tr className="hover:bg-blue-50 transition-colors"><td className="p-4 font-mono text-gray-500">#002</td><td className="p-4 font-bold">Dell XPS 15</td><td className="p-4 text-right font-mono text-blue-600 font-bold text-xl">12</td></tr>
                                        <tr className="hover:bg-blue-50 transition-colors"><td className="p-4 font-mono text-gray-500">#003</td><td className="p-4 font-bold">Logitech Mouse</td><td className="p-4 text-right font-mono text-blue-600 font-bold text-xl">8</td></tr>
                                        <tr className="hover:bg-blue-50 transition-colors"><td className="p-4 font-mono text-gray-500">#004</td><td className="p-4 font-bold">Mechanical Key</td><td className="p-4 text-right font-mono text-blue-600 font-bold text-xl">45</td></tr>
                                    </tbody>
                                </table>
                                <div className="mt-auto bg-gray-50 p-3 text-gray-400 text-sm border-t border-gray-200 flex justify-between">
                                    <span>Database: SQL_Store_V1</span>
                                    <span>Latency: 24ms</span>
                                </div>
                            </div>
                        );
                    case 'unity_box':
                        return (
                            <div className="h-full bg-slate-800 flex flex-col items-center justify-center p-8 cursor-pointer overflow-hidden relative" onClick={rotateCube}>
                                <div className="absolute inset-0 bg-[linear-gradient(rgba(255,255,255,0.03)_1px,transparent_1px),linear-gradient(90deg,rgba(255,255,255,0.03)_1px,transparent_1px)] bg-[size:40px_40px]"></div>
                                <div className="absolute top-6 left-6 text-white/50 text-sm font-mono">
                                    <div>Transform: Rotate</div>
                                    <div>X: 0.0 Y: {cubeRot}.0 Z: 0.0</div>
                                </div>
                                <div 
                                    className="w-48 h-48 md:w-64 md:h-64 bg-gradient-to-br from-blue-500 to-indigo-600 border-4 border-blue-300/50 shadow-[0_0_80px_rgba(59,130,246,0.3)] transition-transform duration-700 ease-out flex items-center justify-center relative transform-style-3d"
                                    style={{ transform: `perspective(1000px) rotateY(${cubeRot}deg) rotateX(15deg)` }}
                                >
                                    <div className="text-white font-bold text-4xl opacity-80 mix-blend-overlay">UNITY</div>
                                    <div className="absolute inset-0 border-2 border-white/20"></div>
                                </div>
                                <div className="absolute bottom-6 text-sm text-white/30 font-mono">Click to interact with Game Object</div>
                            </div>
                        );

                    default:
                        return <div className="flex items-center justify-center h-full text-gray-500 text-xl">Preview Loading...</div>;
                }
            };

            return (
                <div className="w-full h-full bg-gray-950 border-l border-gray-800 relative shadow-2xl flex flex-col">
                    <div className="bg-black/50 backdrop-blur-sm text-sm p-4 border-b border-gray-800 flex justify-between text-gray-300 items-center select-none">
                         <div className="flex items-center gap-3">
                            <Monitor size={18} className="text-blue-500"/>
                            <span className="font-bold tracking-wider text-blue-100 text-lg">{language} BUILD PREVIEW</span>
                         </div>
                         {isInteractive ? 
                            <span className="bg-green-900/30 text-green-400 border border-green-800 px-3 py-1 rounded text-xs font-bold animate-pulse flex items-center gap-2">
                                <Activity size={14}/> INTERACTIVE
                            </span> : 
                            <span className="text-gray-600 text-xs font-mono">WAITING FOR COMPILE...</span>
                         }
                    </div>
                    <div className="flex-1 relative bg-gray-900/50 overflow-hidden">
                        {language ? renderContent() : (
                             <div className="h-full flex flex-col items-center justify-center text-gray-700 gap-6">
                                <div className="p-8 rounded-full bg-gray-900 border border-gray-800">
                                    <Code2 size={80} className="opacity-20" />
                                </div>
                                <span className="text-lg font-mono tracking-widest uppercase">Select language to initialize</span>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        const CodeRushRemastered = () => {
          const [gameState, setGameState] = useState('menu');
          const [difficulty, setDifficulty] = useState('beginner'); // 'beginner', 'hardcore', 'hell'
          const [selectedLanguage, setSelectedLanguage] = useState(null);
          const [currentScenario, setCurrentScenario] = useState(null);
          
          const [score, setScore] = useState(0);
          const [lives, setLives] = useState(3);
          const [currentQIndex, setCurrentQIndex] = useState(0);
          const [displayCode, setDisplayCode] = useState([]);
          const [typing, setTyping] = useState(false);
          const [feedback, setFeedback] = useState(null);
          
          const [userAnswer, setUserAnswer] = useState(""); 
          const [hardcoreQueue, setHardcoreQueue] = useState([]); 
          const [isHellUnlocked, setIsHellUnlocked] = useState(false);
          
          const codeEndRef = useRef(null);
          const inputRef = useRef(null);

          // Check LocalStorage for Hell Mode unlock status
          useEffect(() => {
              const unlocked = localStorage.getItem('cr_hell_unlocked') === 'true';
              setIsHellUnlocked(unlocked);
          }, []);

          const startGame = () => {
            if (!selectedLanguage) return;
            const scenarios = SCENARIOS[selectedLanguage];
            const randomScenario = scenarios[Math.floor(Math.random() * scenarios.length)];
            setCurrentScenario(randomScenario);

            setScore(0);
            setLives(3);
            setCurrentQIndex(0);
            setDisplayCode([]);
            setHardcoreQueue([]);
            setGameState('playing');
            triggerTypingEffect(randomScenario, 0);
          };

          const triggerTypingEffect = (scenario, qIndex) => {
            setTyping(true);
            let lines = [];
            let count = 0;
            const maxLines = 5;

            const interval = setInterval(() => {
                const randomLine = FILLER_CODE[Math.floor(Math.random() * FILLER_CODE.length)];
                lines = [...lines, { text: randomLine, type: 'filler' }];
                setDisplayCode([...lines]);
                if (codeEndRef.current) codeEndRef.current.scrollIntoView({ behavior: 'smooth' });
                
                count++;
                if (count >= maxLines) {
                    clearInterval(interval);
                    setTimeout(() => {
                        showQuestion(scenario, qIndex, lines);
                    }, 300);
                }
            }, 50);
          };

          const showQuestion = (scenario, qIndex, currentLines) => {
            const q = scenario.questions[qIndex];
            if (!q) { endGame(true); return; }
            
            setTyping(false);
            setUserAnswer("");
            
            if (difficulty === 'hardcore') {
                const fullLine = q.preCode + q.gap + q.postCode;
                const tokens = fullLine.split(/([a-zA-Z0-9_]+)/).filter(t => t.length > 0);
                const wordIndices = tokens.map((t, i) => /^[a-zA-Z0-9_]+$/.test(t) ? i : -1).filter(i => i !== -1);
                
                const numGaps = Math.min(wordIndices.length, Math.floor(Math.random() * 2) + 2);
                const shuffledIndices = [...wordIndices].sort(() => 0.5 - Math.random());
                const targetIndices = shuffledIndices.slice(0, numGaps).sort((a,b) => a-b);
                
                const queue = targetIndices.map(i => ({ index: i, answer: tokens[i] }));
                setHardcoreQueue(queue);

                const segments = tokens.map((t, i) => ({
                    text: t,
                    isGap: targetIndices.includes(i),
                    solved: false
                }));

                const questionLine = {
                    type: 'hardcore_question',
                    segments: segments,
                    context: q.context,
                    explanation: q.explanation 
                };
                
                setDisplayCode([...currentLines, questionLine]);
                setTimeout(() => inputRef.current?.focus(), 100);

            } else if (difficulty === 'hell') {
                // HELL MODE: Full Sentence Typing
                const questionLine = {
                    type: 'hell_question',
                    context: q.context,
                    fullLine: (q.preCode + q.gap + q.postCode).trim() // Correct answer for checking
                };
                setDisplayCode([...currentLines, questionLine]);
                setTimeout(() => inputRef.current?.focus(), 100);

            } else {
                // Beginner
                const questionLine = { 
                    text: `// ${q.context}`, 
                    type: 'comment' 
                };
                const codeLine = {
                    text: q.preCode, 
                    gap: q.gap, 
                    postCode: q.postCode, 
                    type: 'question',
                    options: q.options,
                    answer: q.answer,
                    explanation: q.explanation
                };
                setDisplayCode([...currentLines, questionLine, codeLine]);
            }
            
            if (codeEndRef.current) codeEndRef.current.scrollIntoView({ behavior: 'smooth' });
          };

          const handleAnswer = (answer) => {
            if (!currentScenario) return;

            // --- HELL MODE LOGIC ---
            if (difficulty === 'hell') {
                const q = currentScenario.questions[currentQIndex];
                const targetLine = (q.preCode + q.gap + q.postCode).trim();
                
                // Normalize spaces for fair comparison
                const normalize = (str) => str.replace(/\s+/g, ' ').trim();
                
                const isCorrect = normalize(answer) === normalize(targetLine);

                if (isCorrect) {
                    setScore(s => s + 200); // Higher score for Hell mode
                    setFeedback({ correct: true, msg: "PERFECT SYNTAX" });
                    setGameState('feedback');
                } else {
                    setLives(l => l - 1);
                    setScore(s => Math.max(0, s - 100)); // Harsher penalty
                    // Visual shake feedback
                    const input = inputRef.current;
                    if(input) {
                        input.classList.add('animate-shake', 'bg-red-900/50');
                        setTimeout(() => input.classList.remove('animate-shake', 'bg-red-900/50'), 500);
                    }
                }
                return;
            }

            // --- HARDCORE LOGIC ---
            if (difficulty === 'hardcore') {
                if (hardcoreQueue.length === 0) return;

                const currentTarget = hardcoreQueue[0];
                const isCorrect = answer.trim() === currentTarget.answer;

                if (isCorrect) {
                    setScore(s => s + 50); 
                    setUserAnswer("");
                    
                    setDisplayCode(prev => {
                        const newCode = [...prev];
                        const lastLine = {...newCode[newCode.length - 1]};
                        const newSegments = [...lastLine.segments];
                        newSegments[currentTarget.index] = { ...newSegments[currentTarget.index], solved: true };
                        lastLine.segments = newSegments;
                        newCode[newCode.length - 1] = lastLine;
                        return newCode;
                    });

                    const newQueue = hardcoreQueue.slice(1);
                    setHardcoreQueue(newQueue);

                    if (newQueue.length === 0) {
                        setFeedback({ correct: true, msg: "LINE COMPLETE" });
                        setGameState('feedback');
                    }
                } else {
                    setLives(l => l - 1);
                    setScore(s => Math.max(0, s - 20));
                    const input = inputRef.current;
                    if(input) {
                        input.classList.add('animate-shake', 'bg-red-900/50'); // Changed to shake animation
                        setTimeout(() => input.classList.remove('animate-shake', 'bg-red-900/50'), 500);
                    }
                }
                return;
            } 
            
            // --- BEGINNER LOGIC ---
            const q = currentScenario.questions[currentQIndex];
            const isCorrect = answer.trim() === q.answer;

            if (isCorrect) {
                setScore(s => s + 100);
                setFeedback({ correct: true, msg: "OK" });
            } else {
                setLives(l => l - 1);
                setScore(s => Math.max(0, s - 50));
                setFeedback({ correct: false, msg: `Error.` }); 
            }
            setGameState('feedback');
          };

          const nextQuestion = () => {
            if (lives <= 0) { endGame(false); return; }
            const nextIdx = currentQIndex + 1;
            
            // Game Clear Condition
            if (nextIdx >= currentScenario.questions.length) { 
                endGame(true); 
                return; 
            }

            setCurrentQIndex(nextIdx);
            setFeedback(null);
            setGameState('playing');
            triggerTypingEffect(currentScenario, nextIdx);
          };

          const retryQuestion = () => {
            if (lives <= 0) { endGame(false); return; }
            setFeedback(null);
            setGameState('playing');
            setUserAnswer(""); 
            if (difficulty === 'hardcore' || difficulty === 'hell') setTimeout(() => inputRef.current?.focus(), 100);
          };

          const endGame = (success) => {
            setGameState('gameover');
            
            // Unlock Hell Mode logic
            if (success && difficulty === 'hardcore') {
                localStorage.setItem('cr_hell_unlocked', 'true');
                setIsHellUnlocked(true);
            }
          };

          const restartGame = () => {
            setGameState('menu');
            setFeedback(null);
            setDisplayCode([]);
            setCurrentScenario(null);
          };

          if (gameState === 'menu') {
            return (
              <div className={`w-full h-full text-white flex flex-col items-center justify-center p-4 font-sans animate-fade-in relative overflow-hidden ${difficulty === 'hell' ? 'bg-black' : 'bg-slate-900'}`}>
                <div className="absolute inset-0 bg-[linear-gradient(rgba(255,255,255,0.02)_1px,transparent_1px),linear-gradient(90deg,rgba(255,255,255,0.02)_1px,transparent_1px)] bg-[size:40px_40px]"></div>
                
                {/* Background Decor for Hell Mode */}
                {difficulty === 'hell' && <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-red-900/20 via-black to-black pointer-events-none"></div>}

                <div className={`backdrop-blur-xl p-10 rounded-3xl shadow-2xl max-w-lg w-full border text-center relative z-10 ${difficulty === 'hell' ? 'bg-red-950/30 border-red-800' : 'bg-slate-800/80 border-slate-700'}`}>
                  <div className="flex justify-center mb-8">
                    <div className={`p-5 rounded-2xl shadow-lg transform -rotate-3 hover:rotate-0 transition-transform ${difficulty === 'hell' ? 'bg-red-600 shadow-red-500/30' : 'bg-blue-600 shadow-blue-500/30'}`}>
                      {difficulty === 'hell' ? <Skull size={56} className="text-white" /> : <Code2 size={56} className="text-white" />}
                    </div>
                  </div>
                  <h1 className={`text-5xl font-black mb-3 bg-clip-text text-transparent tracking-tight ${difficulty === 'hell' ? 'bg-gradient-to-r from-red-500 to-orange-500' : 'bg-gradient-to-r from-blue-400 to-purple-400'}`}>
                    Code Rush
                  </h1>
                  <p className="text-slate-400 mb-10 text-lg">{difficulty === 'hell' ? "Welcome to Logic Hell." : "Syntax Savior: 마스터가 되세요!"}</p>
                  
                  <div className="mb-4 p-1 bg-slate-900/50 rounded-xl flex gap-2">
                        <button onClick={() => setDifficulty('beginner')} className={`flex-1 py-3 rounded-lg text-sm font-bold transition-all ${difficulty === 'beginner' ? 'bg-green-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-800 hover:text-white'}`}>BEGINNER</button>
                        <button onClick={() => setDifficulty('hardcore')} className={`flex-1 py-3 rounded-lg text-sm font-bold transition-all ${difficulty === 'hardcore' ? 'bg-red-600 text-white shadow-lg' : 'text-slate-400 hover:bg-slate-800 hover:text-white'}`}>HARDCORE</button>
                  </div>
                  
                  {/* HELL MODE BUTTON (Dynamic Show) */}
                  <div className={`transition-all duration-700 ease-out overflow-hidden ${isHellUnlocked ? 'max-h-20 opacity-100 mb-8 animate-pop-in' : 'max-h-0 opacity-0 mb-0'}`}>
                      {isHellUnlocked && (
                          <button 
                            onClick={() => setDifficulty('hell')} 
                            className={`w-full py-3 rounded-lg text-sm font-bold transition-all flex items-center justify-center gap-2 ${difficulty === 'hell' ? 'bg-gradient-to-r from-purple-700 to-red-600 text-white shadow-lg shadow-purple-900/50 scale-105' : 'bg-slate-800 text-purple-400 border border-purple-900/50 hover:bg-purple-900/20 animate-pulse'}`}
                          >
                              <Skull size={16}/> HELL MODE (FULL TYPING)
                          </button>
                      )}
                  </div>

                  <div className="grid grid-cols-2 gap-3 mb-8">
                      {Object.keys(SCENARIOS).map(lang => (
                        <button
                          key={lang}
                          onClick={() => setSelectedLanguage(lang)}
                          className={`py-3 text-sm font-bold rounded-xl transition-all border-2 ${
                            selectedLanguage === lang 
                            ? (difficulty === 'hell' ? 'bg-red-900/20 border-red-500 text-red-400' : 'bg-blue-600/20 border-blue-500 text-blue-400')
                            : 'bg-slate-700/50 border-transparent text-slate-400 hover:bg-slate-700 hover:border-slate-600'
                          }`}
                        >
                          {lang}
                        </button>
                      ))}
                  </div>

                  <button 
                    onClick={startGame}
                    disabled={!selectedLanguage}
                    className={`w-full font-bold py-4 rounded-xl transition-all transform flex items-center justify-center gap-3 shadow-xl ${
                        selectedLanguage 
                        ? (difficulty === 'hell' ? 'bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white text-lg' : 'bg-gradient-to-r from-blue-600 to-purple-600 hover:scale-105 hover:from-blue-500 hover:to-purple-500 text-white text-lg')
                        : 'bg-slate-700 text-slate-500 cursor-not-allowed'
                    }`}
                  >
                    <Play size={24} fill="currentColor" />
                    {selectedLanguage ? 'START GAME' : 'SELECT LANGUAGE'}
                  </button>
                </div>
              </div>
            );
          }

          // FULL SCREEN PLAYING VIEW
          return (
            <div className="w-full h-full bg-black text-white flex flex-col md:flex-row font-sans overflow-hidden">
                {/* LEFT PANEL (CODE) */}
                <div className="flex-1 flex flex-col border-r border-slate-800 bg-[#1e1e1e] relative">
                    {/* Header */}
                    <div className={`flex justify-between items-center px-6 py-4 border-b select-none backdrop-blur-md ${difficulty === 'hell' ? 'bg-red-950/20 border-red-900/30' : 'bg-slate-900/50 border-slate-800'}`}>
                        <div className="flex items-center gap-4">
                            <div className={`p-2 rounded-lg ${difficulty === 'hell' ? 'bg-red-900/20' : 'bg-slate-800'}`}>
                                <Cpu className={`w-5 h-5 ${difficulty === 'hell' ? 'text-red-500' : 'text-blue-400'}`} />
                            </div>
                            <div>
                                <div className="text-xs text-slate-500 font-bold uppercase tracking-wider">Project</div>
                                <div className="font-bold text-slate-200 text-lg leading-none">{currentScenario?.title}</div>
                            </div>
                            <div className="h-8 w-px bg-slate-700 mx-2"></div>
                            <span className={`text-xs font-bold px-2 py-1 rounded ${
                                difficulty === 'hardcore' ? 'bg-red-900/30 text-red-400 border border-red-900' : 
                                difficulty === 'hell' ? 'bg-purple-900/30 text-purple-400 border border-purple-900' :
                                'bg-green-900/30 text-green-400 border border-green-900'
                            }`}>
                                {difficulty.toUpperCase()}
                            </span>
                        </div>
                        <div className="flex items-center gap-6">
                            <div className="text-right">
                                <div className="text-xs text-slate-500 font-bold uppercase">Score</div>
                                <div className="text-yellow-400 font-mono text-xl leading-none">{score.toLocaleString()}</div>
                            </div>
                            <div className="text-right">
                                <div className="text-xs text-slate-500 font-bold uppercase">Lives</div>
                                <div className="text-red-400 font-bold text-xl leading-none">{"♥".repeat(lives)}<span className="text-slate-700">{"♥".repeat(3-lives)}</span></div>
                            </div>
                        </div>
                    </div>

                    {/* Content */}
                    {gameState === 'gameover' ? (
                        <div className="flex-1 flex flex-col items-center justify-center p-12 animate-fade-in bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-slate-800/30 to-transparent">
                            <Trophy size={120} className={`mb-8 drop-shadow-2xl ${lives > 0 ? 'text-yellow-400' : 'text-slate-700'}`} />
                            <h2 className="text-5xl font-black mb-4 tracking-tight">{lives > 0 ? "BUILD COMPLETE" : "SYSTEM FAILURE"}</h2>
                            <p className="text-slate-400 mb-12 text-center max-w-md text-lg">
                                {lives > 0 ? (difficulty === 'hardcore' ? "축하합니다! 하드코어 클리어로 'HELL MODE'가 해금되었습니다!" : "대단합니다! 이 구역의 진정한 코딩 마스터입니다.") : "치명적인 오류가 발생하여 빌드가 중단되었습니다."}
                            </p>
                            
                            <button 
                                onClick={restartGame}
                                className="bg-white hover:bg-gray-200 text-black font-black py-4 px-10 rounded-full transition-all flex items-center gap-3 shadow-xl hover:scale-105 hover:shadow-2xl"
                            >
                                <RotateCcw size={20} />
                                REBOOT SYSTEM
                            </button>
                        </div>
                    ) : (
                        <>
                            {/* Code Area */}
                            <div className="flex-1 overflow-y-auto p-6 md:p-8 font-mono text-lg md:text-xl leading-loose relative custom-scrollbar" onClick={() => (difficulty === 'hardcore' || difficulty === 'hell') && inputRef.current?.focus()}>
                                {displayCode.map((line, idx) => (
                                    <div key={idx} className={`${line.type === 'filler' ? 'text-slate-600 opacity-30 blur-[0.5px]' : ''} mb-2 whitespace-pre-wrap`}>
                                        {/* COMMENT LINE */}
                                        {(line.type === 'comment' || line.context) && (
                                            <span className="text-green-600/80 italic font-bold block mb-1">
                                                // {line.text || line.context}
                                            </span>
                                        )}
                                        
                                        {/* Beginner Question */}
                                        {line.type === 'question' && (
                                            <div className="flex flex-wrap items-center bg-slate-800/40 p-4 -mx-4 rounded-lg border-l-4 border-blue-500 my-4 shadow-lg backdrop-blur-sm">
                                                <span className="text-blue-200">{line.text}</span>
                                                {gameState === 'feedback' ? (
                                                    <span className={`px-3 py-1 rounded font-bold mx-2 border ${feedback.correct ? 'bg-green-500/20 text-green-400 border-green-500/50' : 'bg-red-500/20 text-red-400 border-red-500/50'}`}>
                                                        {feedback.correct ? line.gap : line.gap}
                                                    </span>
                                                ) : (
                                                    <span className="inline-block px-4 py-1 bg-slate-700/80 rounded animate-pulse mx-2 text-center text-slate-400 text-sm font-bold border border-slate-600 shadow-inner">???</span>
                                                )}
                                                <span className="text-blue-200">{line.postCode}</span>
                                            </div>
                                        )}

                                        {/* Hardcore Question (Multi-Gap) */}
                                        {line.type === 'hardcore_question' && (
                                            <div className="my-6 bg-slate-900/80 p-6 -mx-6 rounded-xl border-l-4 border-red-500 shadow-2xl">
                                                <div className="flex flex-wrap gap-x-2 gap-y-4 items-center text-blue-100 text-xl md:text-2xl font-bold">
                                                    {line.segments.map((seg, sIdx) => (
                                                        <span key={sIdx} className={`${
                                                            seg.isGap 
                                                                ? (seg.solved 
                                                                    ? "text-green-400 transition-colors duration-300" 
                                                                    : (sIdx === hardcoreQueue[0]?.index 
                                                                        ? "text-transparent border-b-4 border-red-500 min-w-[60px] animate-pulse bg-red-500/10 px-1" 
                                                                        : "text-transparent border-b-2 border-slate-700 min-w-[40px] px-1")) 
                                                                : ""
                                                        }`}>
                                                            {seg.isGap && !seg.solved ? "____" : seg.text}
                                                        </span>
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        {/* HELL MODE Question (Full Typing) */}
                                        {line.type === 'hell_question' && (
                                            <div className="my-6 bg-black/50 p-6 -mx-6 rounded-xl border-l-4 border-purple-500 shadow-2xl">
                                                <div className="text-slate-500 font-mono text-sm mb-2 opacity-50 select-none">Enter complete line:</div>
                                                <div className="text-purple-300 font-bold text-xl md:text-2xl font-mono min-h-[2rem] relative">
                                                    {/* User's current typing reflection could go here, or just keep it in input area */}
                                                    <span className="animate-pulse">_</span>
                                                </div>
                                            </div>
                                        )}

                                        {/* Filler Code */}
                                        {line.type === 'filler' && <span className="text-slate-500">{line.text}</span>}
                                    </div>
                                ))}
                                <div ref={codeEndRef} />
                            </div>

                            {/* Input / Options Area */}
                            {!typing && gameState === 'playing' && (
                                <div className={`border-t animate-slide-up p-8 z-20 shadow-[0_-10px_40px_rgba(0,0,0,0.5)] ${difficulty === 'hell' ? 'bg-black border-purple-900/30' : 'bg-slate-900 border-slate-800'}`}>
                                    {difficulty === 'hardcore' || difficulty === 'hell' ? (
                                        <div className="flex items-center gap-4 max-w-6xl mx-auto">
                                            <div className={`flex-1 flex items-center bg-black p-6 rounded-2xl border transition-all shadow-inner ${difficulty === 'hell' ? 'border-purple-800 focus-within:border-purple-500 focus-within:ring-2 focus-within:ring-purple-500/20' : 'border-slate-700 focus-within:border-blue-500 focus-within:ring-2 focus-within:ring-blue-500/20'}`}>
                                                <span className={`${difficulty === 'hell' ? 'text-purple-500' : 'text-green-500'} font-mono font-bold mr-4 animate-pulse text-2xl`}>{'>'}</span>
                                                <form 
                                                    className="flex-1"
                                                    onSubmit={(e) => { e.preventDefault(); handleAnswer(userAnswer); }}
                                                >
                                                    <input 
                                                        ref={inputRef}
                                                        type="text" 
                                                        value={userAnswer}
                                                        onChange={(e) => setUserAnswer(e.target.value)}
                                                        className="w-full bg-transparent border-none outline-none text-white font-mono text-2xl placeholder-slate-700"
                                                        placeholder={difficulty === 'hell' ? "Type the entire line of code..." : (hardcoreQueue.length > 0 ? "Type the missing keyword..." : "Processing...")}
                                                        autoFocus
                                                        autoComplete="off"
                                                        spellCheck="false"
                                                    />
                                                </form>
                                            </div>
                                            <div className="flex flex-col items-end min-w-[120px]">
                                                {difficulty === 'hell' ? (
                                                    <div className="flex flex-col items-end">
                                                        <span className="text-purple-500 font-bold animate-pulse text-xl">HELL MODE</span>
                                                        <span className="text-[10px] text-slate-500">NO MERCY</span>
                                                    </div>
                                                ) : (
                                                    <>
                                                        <span className="text-4xl font-bold text-white">{hardcoreQueue.length}</span>
                                                        <span className="text-sm text-slate-500 uppercase font-bold tracking-wider">Remaining</span>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="grid grid-cols-2 gap-6 max-w-6xl mx-auto">
                                            {currentScenario.questions[currentQIndex].options.map((opt, idx) => (
                                                <button
                                                    key={idx}
                                                    onClick={() => handleAnswer(opt)}
                                                    className="bg-slate-800 hover:bg-blue-600 p-6 rounded-2xl text-left font-mono text-xl border border-slate-700 hover:border-blue-400 transition-all text-white group flex justify-between items-center shadow-lg hover:-translate-y-1"
                                                >
                                                    <span className="flex items-center">
                                                        <span className="text-slate-500 mr-4 group-hover:text-blue-200 font-bold">{String.fromCharCode(65+idx)}.</span>
                                                        {opt}
                                                    </span>
                                                    <ChevronRight size={24} className="opacity-0 group-hover:opacity-100 transition-opacity text-white" />
                                                </button>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Feedback Overlay */}
                            {gameState === 'feedback' && (
                                <div className={`p-8 border-t backdrop-blur-md z-30 animate-slide-up shadow-[0_-10px_50px_rgba(0,0,0,0.5)] ${
                                    feedback.correct 
                                        ? 'bg-green-900/90 border-green-500' 
                                        : 'bg-red-900/90 border-red-500'
                                }`}>
                                    <div className="max-w-6xl mx-auto flex flex-col md:flex-row gap-8 items-center justify-between">
                                        <div>
                                            <div className="flex items-center mb-2">
                                                {feedback.correct ? <CheckCircle className="text-green-400 mr-3" size={32}/> : <XCircle className="text-red-400 mr-3" size={32}/>}
                                                <span className={`font-black text-3xl ${feedback.correct ? 'text-green-100' : 'text-red-100'}`}>
                                                    {feedback.correct ? (difficulty === 'hell' ? "GODLIKE CODING!" : "COMPILATION SUCCESS") : "SYNTAX ERROR"}
                                                </span>
                                            </div>
                                            <p className="text-xl md:text-2xl text-slate-200 font-mono pl-12 opacity-90">
                                                {currentScenario.questions[currentQIndex].explanation}
                                                {/* In Hell Mode, show the correct answer if failed? Maybe too easy. Let's show it only on success or fail. */}
                                                {!feedback.correct && difficulty === 'hell' && (
                                                    <div className="mt-2 text-sm text-yellow-300">
                                                        Hint: {currentScenario.questions[currentQIndex].preCode + currentScenario.questions[currentQIndex].gap + currentScenario.questions[currentQIndex].postCode}
                                                    </div>
                                                )}
                                            </p>
                                        </div>
                                        
                                        <div className="flex gap-4 w-full md:w-auto">
                                            {feedback.correct ? (
                                                <button onClick={nextQuestion} className="w-full md:w-auto bg-white text-black hover:bg-gray-200 px-10 py-4 rounded-2xl text-lg font-bold flex items-center justify-center transition-all shadow-lg hover:scale-105">
                                                    NEXT STEP <Play className="w-5 h-5 ml-2 fill-current" />
                                                </button>
                                            ) : (
                                                <button onClick={lives > 0 ? retryQuestion : () => endGame(false)} className={`w-full md:w-auto px-10 py-4 rounded-2xl text-lg font-bold flex items-center justify-center transition-all shadow-lg hover:scale-105 ${lives > 0 ? 'bg-slate-800 text-white hover:bg-slate-700' : 'bg-red-600 text-white hover:bg-red-500'}`}>
                                                    {lives > 0 ? "RETRY (DEBUG)" : "SYSTEM FAILURE"} <RotateCcw className="w-5 h-5 ml-2" />
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </>
                    )}
                </div>

                {/* RIGHT PANEL: Live Preview */}
                <div className="w-full md:w-[45%] border-t md:border-t-0 md:border-l border-slate-800 bg-black h-[35vh] md:h-full transition-all duration-300 relative z-10 shadow-2xl">
                     <ProjectPreview 
                        language={selectedLanguage} 
                        scenarioType={currentScenario ? currentScenario.type : null}
                        progress={currentScenario ? (currentQIndex / currentScenario.questions.length) * 100 : 0}
                        isInteractive={gameState === 'gameover' && lives > 0} 
                    />
                </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CodeRushRemastered />);
    </script>
</body>
</html>